<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Macros - C3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Macros";
    var mkdocs_page_input_path = "macros.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C3 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">About C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Installing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../firstproject/">Your first project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../primer/">A quick primer on C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../changesfromc/">Changes from C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compare/">Comparisons with other languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../define/">Define</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statements/">Statements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../expressions/">Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../errorhandling/">Errors</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../undefinedbehaviour/">Undefined behaviour</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../conversion/">Conversions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../builtinmacros/">Built-in Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../precedence/">Precedence</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../generics/">Generics</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Macros</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#a-quick-comparison-of-c-and-c3-macros">A quick comparison of C and C3 macros</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#conditional-compilation">Conditional compilation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#macros_1">Macros</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dynamic-scoping">Dynamic scoping</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reference-arguments">Reference arguments</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#first-class-types">First class types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#trailing-blocks-for-macros">Trailing blocks for macros</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#first-class-names">First class names</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#declaration-attributes">Declaration attributes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#declaration-macros">Declaration macros</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#stringingification">Stringingification</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#top-level-evaluation">Top level evaluation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-declarations">Macro declarations</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-methods">Macro methods</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#capturing-a-trailing-block">Capturing a trailing block</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macros-returning-values">Macros returning values</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#calling-macros">Calling macros</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-directives">Macro directives</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#if-else-and-elif">$if, $else and $elif</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#loops-using-foreach-and-for">Loops using $foreach and $for</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#switching-on-type-with-switch">Switching on type with $switch</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#escape-macros">Escape macros</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#conditional-macros-at-the-top-level">Conditional macros at the top level</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#conditional-compilation_1">Conditional compilation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#global-constants">Global constants</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../reflection/">Reflection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../preconditions/">Pre and post conditions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../library/">Library</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ideas/">Crazy ideas</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../naming/">Naming rules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../comments/">Comments & Docs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../attributes/">Attributes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cinterop/">C Interop</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../syntax/">Grammar</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../sample/">More code examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../specification/">Specification</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Build system</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../buildintro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../project/">Project Structure</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../buildcommands/">Commands</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../contribute/">Contribute</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../changes/">Changes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../rejectedideas/">Rejected ideas</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C3 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Macros</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="macros">Macros</h1>
<p>The macro capabilities of C3 reaches across several constructs: macros (prefixed with <code>@</code> at invocation), <a href="../generics/#generic-functions">generic functions</a>, <a href="../generics/#generic-modules">generic modules</a>, compile time variables (prefixed with <code>$</code>), macro compile time execution (using <code>$if</code>, <code>$for</code>, <code>$foreach</code>, <code>$switch</code>) and attributes.</p>
<h2 id="a-quick-comparison-of-c-and-c3-macros">A quick comparison of C and C3 macros</h2>
<h3 id="conditional-compilation">Conditional compilation</h3>
<pre><code>// C
#if defined(x) &amp;&amp; Y &gt; 3
int z;
#endif

// C3
$if ($defined(x) &amp;&amp; $y &gt; 3):
    int z;
$endif;
</code></pre>
<h3 id="macros_1">Macros</h3>
<pre><code>// C
#define M(x) ((x) + 2)
#define RETURN(x) return x;
#define u32 unsigned int

// Use:
int y = M(foo() + 2);
RETURN(bar());
u32 b = y;

// C3
macro m(x)
{
    return x + 2;
}
macro ret(x) @escape
{
    return x;
}
define u32 = uint;

// Use:
int y = @m(foo() + 2);
@ret(bar());
u32 b = y;
</code></pre>
<h3 id="dynamic-scoping">Dynamic scoping</h3>
<p><em>Note This is not currenctly implemented and may possibly not be included.</em></p>
<pre><code>// C
#define Z() ptr-&gt;x-&gt;y-&gt;z
int x = Z();

// C3
macro z(implicit ptr)
{
    return ptr-&gt;x-&gt;y-&gt;z;
}
int x = @z();
</code></pre>
<h3 id="reference-arguments">Reference arguments</h3>
<p>Use <code>&amp;</code> in front of a parameter to capture the a variable and pass it by reference without having to explicitly use <code>&amp;</code> and pass a pointer. 
(Note that in C++ this is allowed for normal functions, whereas for C3 it is only permitted with macros.)</p>
<pre><code>// C
#define M(x, y) x = 2 * (y);

// C3
macro m(int &amp;x, int y)
{
    x = 2 * y;
}
</code></pre>
<h3 id="first-class-types">First class types</h3>
<pre><code>// C
#define SIZE(T) (sizeof(T) + sizeof(int))

// C3
macro size($Type)
{
    return $sizeof($Type) + $sizeof(int);
}
</code></pre>
<h3 id="trailing-blocks-for-macros">Trailing blocks for macros</h3>
<pre><code>// C
#define FOR_EACH(x, list) \
for (x = (list); x; x = x-&gt;next)

// Use:
Foo *it;
FOR_EACH(it, list) 
{
    if (!process(it)) return;
}


// C3
macro for_each(list; @body(it))
{
    for ($typeof(list) x = list; x; x = x.next)
    {
        @body(x);
    }    
}

// Use:
@for_each(list; Foo* x)
{
    if (!process(x)) return;
}
</code></pre>
<h3 id="first-class-names">First class names</h3>
<pre><code>// C
#define offsetof(T, field) (size_t)(&amp;((T*)0)-&gt;field)

// C3
... Currently no corresponding functionality ...
</code></pre>
<h3 id="declaration-attributes">Declaration attributes</h3>
<p><em>Note: this is not implemented yet</em></p>
<pre><code>// C
#define PURE_INLINE __attribute__((pure)) __attribute__((always_inline))
int foo(int x) PURE_INLINE { ... }

// C3
attribute pure_inline = @pure, @inline;
func int foo(int) @pure_inline { ... }
</code></pre>
<h3 id="declaration-macros">Declaration macros</h3>
<pre><code>// C
#define DECLARE_LIST(name) List name = { .head = NULL };
// Use:
DECLARE_LIST(hello)

// C3
... currently no corresponding functionality ...
</code></pre>
<h3 id="stringingification">Stringingification</h3>
<pre><code>#define DECLARE_STRING(name, s) char *name##_str = #s;

// C3
... currently no corresponding functionality ...
</code></pre>
<h2 id="top-level-evaluation">Top level evaluation</h2>
<p>Script languages, and also upcoming languages like <em>Jai</em>, usually have unbounded top level evaluation. The flexibility of this style of meta programming has a trade off in making the code more challenging to understand. </p>
<p>In C3, top level compile time evaluation is limited to <code>$if</code> and <code>$switch</code> constructs + macros with constant expression evaluation. This makes the code easier to read, but at the cost of expressive power.</p>
<h2 id="macro-declarations">Macro declarations</h2>
<p>A macro is defined using <code>macro &lt;name&gt;(&lt;parameters&gt;)</code>. All user defined macros use the @ symbol.</p>
<p>The parameters have different sigils: <code>$</code> means compile time evaluated (constant expression or type). <code>#</code> indicates an expression that is not yet evaluated, but is bound to where it was defined. Finally <code>&amp;</code> is used to <em>implicitly</em> pass a parameter by reference.</p>
<p>A basic swap:</p>
<pre><code>/**
 * @checked a = b, b = a
 */
macro void swap(&amp;a, &amp;b)
{
    $typeof(a) temp = a;
    a = b;
    b = temp;
}
</code></pre>
<p>This expands on usage like this:</p>
<pre><code>func void test()
{
    int a = 10;
    int b = 20;
    @swap(a, b);
}
// Equivalent to:
func void test()
{
    int a = 10;
    int b = 20;
    {
        int __temp = a;
        a = b;
        b = __temp;
    }
}
</code></pre>
<p>Note the necessary <code>&amp;</code>. Here is an incorrect swap and what it would expand to:</p>
<pre><code>macro void badswap(a, b)
{
    typeof(a) temp = a;
    a = b;
    b = temp;
}

func void test()
{
    int a = 10;
    int b = 20;
    @badswap(a, b);
}
// Equivalent to:
func void test()
{
    int a = 10;
    int b = 20;
    {
        int __a = a;
        int __b = b;
        int __temp = __a;
        __a = __b;
        __b = __temp;
    }
}
</code></pre>
<h2 id="macro-methods">Macro methods</h2>
<p>Similar to regular <em>methods</em> a macro may also be associated with a particular type:</p>
<pre><code>struct Foo { ... }

macro Foo.generate(Foo *foo) { ... }
Foo f;
f.@generate();
</code></pre>
<h2 id="capturing-a-trailing-block">Capturing a trailing block</h2>
<p>It is often useful for a macro to take a trailing compound statement as an argument. In C++ this pattern is usually expressed with a lambda, but in C3 this is completely inlined.</p>
<p>To accept a trailing block, <code>; @name(param1, ...)</code> is placed after declaring the regular macro parameters.</p>
<p>Here's an example to illustrate its use:</p>
<pre><code>/**
 * A macro looping through a list of values, executing the body once
 * every pass.
 *
 * @checked { int i = a.len; value2 = a[i]; }
 **/
macro foreach(a; @body(index, value))
{
    for (int i = 0; i &lt; a.len; i++)
    {
        @body(i, a[i]);
    }
}

func void test()
{
    double[] a = { 1.0, 2.0, 3.0 };
    @foreach(a; int index, double value)
    {
        io::printf("a[%d] = %f\n", index, value);
    }
}

// Expands to code similar to:
func void test()
{
    int[] a = { 1, 2, 3 };
    {
        int[] __a = a;
        for (int __i = 0; i &lt; __a.len; i++)
        {
            io::printf("Value: %d, x2: %d\n", __value1, __value2);
        }
    }
}
</code></pre>
<h2 id="macros-returning-values">Macros returning values</h2>
<p>A macro may return a value, it is then considered an expression rather than a statement:</p>
<pre><code>macro square(x)
{
    return x * x;
}

int getTheSquare(int x)
{
    return @square(x);
}

double getTheSquare2(double x)
{
    return @square(x);
}
</code></pre>
<h2 id="calling-macros">Calling macros</h2>
<p>It's perfectly fine for a macro to invoke another macro or itself.</p>
<pre><code>macro square(x) { return x * x; }

macro squarePlusOne(x)
{
    return @square(x) + 1; // Expands to "return x * x + 1;"
}
</code></pre>
<p>The maximum recursion depth is limited to the <code>macro-recursion-depth</code> build setting.</p>
<h2 id="macro-directives">Macro directives</h2>
<p>Inside of a macro, we can use the compile time statements <code>$if</code>, <code>$for</code> and <code>$switch</code>. Macros may also be recursively invoked. As previously mentioned, <code>$if</code> and <code>$switch</code> may also be invoked on the top level.</p>
<h3 id="if-else-and-elif">$if, $else and $elif</h3>
<p><code>$if (&lt;const expr&gt;):</code> takes a compile time constant value and evaluates it to true or false.</p>
<pre><code>macro foo($x, $y)
{
    $if ($x &gt; 3):
        $y += $x * $x;
    $else:
        $y += $x;
    $endif;    
}

const int FOO = 10;

func void test()
{
    int a = 5;
    int b = 4;
    @foo(1, a); // Allowed, expands to a += 1;
    // @foo(b, a); // Error: b is not a compile time constant.
    @foo(FOO, a); // Allowed, expands to a += FOO * FOO;
}
</code></pre>
<h3 id="loops-using-foreach-and-for">Loops using $foreach and $for</h3>
<p><code>$foreach (&lt;range&gt; : &lt;variable&gt;): ... $endforeach;</code> allows compile time recursion. <code>$foreach</code> may recurse over enums, struct fields or constant ranges. Everything must be known at compile time.</p>
<p>Compile time looping:</p>
<pre><code>macro foo($a)
{
    $for (var $x = 0; $x &lt; $a; $x++):
        io::printf("%d\n", $x);     
    $endfor;
}

func void test()
{
    @foo(2);
    // Expands to -&gt;
    // io::printf("%d\n", 0);     
    // io::printf("%d\n", 1);         
}
</code></pre>
<p>Looping over enums:</p>
<pre><code>macro foo_enum($SomeEnum)
{
    $foreach ($x : $SomeEnum.elements):
        io::printf("%d\n", (int)($x));     
    $endforeach;
}

enum MyEnum
{
    A,
    B,
}

func void test()
{
    @foo_enum(MyEnum);
    // Expands to -&gt;
    // io::printf("%d\n", (int)(MyEnum.A));
    // io::printf("%d\n", (int)(MyEnum.B));    
}
</code></pre>
<p>An important thing to note is that the content of the <code>$foreeach</code> or <code>$for</code> body must be a complete statement.
It's not possible to compile partial statements.</p>
<h3 id="switching-on-type-with-switch">Switching on type with $switch</h3>
<p>It's possible to switch on type:</p>
<pre><code>macro void foo(a, b)
{
    $switch(a, b):
        $case int, int: 
            return a * b;
    $endswitch;
    return a + b;
}
</code></pre>
<h2 id="escape-macros">Escape macros</h2>
<p>Usually macro will generate its own scope, so that break, return, continue and next only stays valid inside of the macro's "scope". A <code>return</code> from inside a macro does not normally escape the scope into which it's called:</p>
<pre><code>macro void @foo() { return; }

func void test()
{
    @foo(); // Doesn't do anything.
    io::printf("Test");
}
</code></pre>
<p>However, sometimes macros are needed that does not create its own scope, allowing return, break etc work as if it was part of the included scope. Escape macros does exactly that. Adding the attribute <code>@escape</code> removes capturing return.</p>
<pre><code>macro void @foo() @escape 
{ 
    return; 
}

func void test()
{
    @foo(); // The function returns here.
    io::printf("Test"); // Never printed!
}
</code></pre>
<p>This is not limited to return: <code>break</code>, <code>continue</code> and <code>next</code> is allowed.</p>
<pre><code>macro next($f) @escape
{ 
    nextcase $f;
}

func void test()
{
    int i = 1;
    switch (i)
    {
        case 1:
            @next(3);
            io::println("Foo");
        case 3:
            io::println("Bar!")
    }
}
</code></pre>
<p>The above code will print "Bar!"</p>
<h2 id="conditional-macros-at-the-top-level">Conditional macros at the top level</h2>
<p>A limitation with the macros is that they are only used <em>within</em> functions. 
This is deliberate – macros expanding at the top level are much harder to 
reason about since they should be able to define new types or change the
meaning of the code that follows.</p>
<p>Still, the usefulness of top level macros is great, which is why C3 offers 
three pieces of functionality for the top level: conditional compilation,
global constants and attributes</p>
<h3 id="conditional-compilation_1">Conditional compilation</h3>
<p>Conditional compilation is done with <code>$if</code> and <code>$else</code>, which works just like
inside of functions.</p>
<pre><code>$if ($defined(platform::OS) &amp;&amp; platform::OS == WIN32):

func void doSomethingWin32Specific()
{
    /* .... */
}

$endif;
</code></pre>
<h3 id="global-constants">Global constants</h3>
<p>Global constant on the top level work like compile time variables in macros – with the exception
that they must always be declared constant. They are always evaluated in order, which 
has to be taken into account when used in conjunction with @defined.</p>
<p>Consider this code:</p>
<pre><code>macro foo()
{
    $if ($defined(A)): 
        return A + 1; 
    endif;
    return 1;
}
const Z = @foo(); // Z = 1
const A = @foo(); // A = 1
const B = @foo(); // B = 2
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../reflection/" class="btn btn-neutral float-right" title="Reflection">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../generics/" class="btn btn-neutral" title="Generics"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../generics/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../reflection/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>

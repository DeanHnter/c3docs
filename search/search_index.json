{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is C3? C3 is a systems language based on C. It is an evolution C enabling the same paradigms and retaining the same syntax (as far as possible). C3 started as an extension of the C2 language by Bas van den Berg . It has since departed substantially in regards to error handling, macros, generics and strings. The C3 compiler can be found on github: https://github.com/c3lang/c3c . Last updated: Revision 2021-05-08 . Features Compile directly using LLVM C to C3 conversion (for a subset of C) TODO Module system Generic modules [IN PROGRESS] Zero overhead errors Struct subtyping Built-in safe arrays Zero cost simple gradual & opt-in pre/post conditions. [IN PROGRESS] High level containers and string handling. [IN PROGRESS] Design principles Procedural \"get things done\"-type of language. Stay close to C - only change where there is a significant need. Flawless C integration. Learning C3 should be easy for a C programmer. Dare add convienences if the value is great. Data is inert. Avoid \"big ideas\". Avoid the kitchen sink language trap. Thank yous Special thank yous to: Bas van der Berg (Author of C2 ), Jon Goodwin (Author of Cone ) and Andrey Penechko (Author of Vox ).","title":"About C3"},{"location":"#what-is-c3","text":"C3 is a systems language based on C. It is an evolution C enabling the same paradigms and retaining the same syntax (as far as possible). C3 started as an extension of the C2 language by Bas van den Berg . It has since departed substantially in regards to error handling, macros, generics and strings. The C3 compiler can be found on github: https://github.com/c3lang/c3c . Last updated: Revision 2021-05-08 .","title":"What is C3?"},{"location":"#features","text":"Compile directly using LLVM C to C3 conversion (for a subset of C) TODO Module system Generic modules [IN PROGRESS] Zero overhead errors Struct subtyping Built-in safe arrays Zero cost simple gradual & opt-in pre/post conditions. [IN PROGRESS] High level containers and string handling. [IN PROGRESS]","title":"Features"},{"location":"#design-principles","text":"Procedural \"get things done\"-type of language. Stay close to C - only change where there is a significant need. Flawless C integration. Learning C3 should be easy for a C programmer. Dare add convienences if the value is great. Data is inert. Avoid \"big ideas\". Avoid the kitchen sink language trap.","title":"Design principles"},{"location":"#thank-yous","text":"Special thank yous to: Bas van der Berg (Author of C2 ), Jon Goodwin (Author of Cone ) and Andrey Penechko (Author of Vox ).","title":"Thank yous"},{"location":"arrays/","text":"Arrays Arrays has a central role in programming. C3 offers 3 types of arrays: Fixed arrays <type>[<size>] e.g. int[4] . These are treated as values and will be copied if given as parameter. Unlike C, the number is part of its type. Taking a pointer to a fixed array will create a pointer to a fixed array, e.g. int[4]* . Unlike C, fixed arrays do not decay into pointers, instead an int[4]* may be implicitly converted into an int* . // C int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(x); // C3 func int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(&x); When you want to initialize a fixed array without specififying the size, use the [+] array syntax: int[3] a = { 1, 2, 3}; int[+] b = { 4, 5, 6}; // Type inferred to be int[3] Variable arrays Variable arrays are specially allocated arrays that are prefixed with both a size and a capacity. If allocated on the heap, they cannot expand, but heap allocated variable arrays will do so automatically using whatever memory allocator was used to create it. THIS PART WILL BE SUBJECT TO REVISION int[*] x = @malloc(int[*]); x += 10; x += 11; x.size; // => 2 x[1]; // => 11 A variable array can implicitly convert to a pointer: int[*] x = @malloc(int[*]); int *z = x; A variable array's reference is not stable under expansion, so any alias may be invalidated if appending occurs. int[*] x = @malloc(int[*]); int[*] *y = &x; int *z = x; for (int i = 0; i < 33; i++) x += 10; assert(y != &x); int *w = x; assert(z != w); Assigning a fixed array to a variable array will copy the contents: int[3] b = { 1, 2, 3}; int[*] a = @malloc(int[*]); a = b; Built-in functions on variable arrays pop() Removes the last element. last() Retrieves the last element. remove(index) Removes an element in the array in O(n) time. capacity Return the capacity of the array. size return the size of the array. resize(size) Resize the array to the given size. Subarray The final type is the subarray <type>[] e.g. int[] . A subarray is a view into either a fixed or variable array. Internally it is represented as a struct containing a pointer and a size. Both fixed and variable arrays may be converted into slices, and slices may be implicitly converted to pointers: int[4] a = { 1, 2, 3, 4}; int[] b = &a; // Implicit conversion is always ok. int[4] c = cast(b as int[4]); // Will copy the value of b into c. int[4]* d = cast(b as int[4]); // Equivalent to d = &a int[*] e = @malloc(int[]); b.size; // Returns 4 e.size; // Returns 0 e += 1; e += 2; e.size; // Returns 2 int* f = b; // Equivalent to e = &a f = d; // implicit conversion ok. f = e; // implicit conversion ok. d = e; // ERROR! Not allowed d = cast(e as int[4]*); // Fine b = e; // Implicit conversion ok Slicing arrays It's possible to use a range syntax to create subarrays from pointers, arrays, vararrays and other subarrays. The usual syntax is arr[<start index>..<end index>] . The end index is included in the final result. int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; // The whole array as a slice. int[] c = a[1..2]; // { 20, 50 } It's possible to omit the first and last index, in which case the start and the len is inferred. Note that omitting the last index is not allowed for pointers. The following are all equivalent: int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; int[] c = a[..4]; int[] d = a[0..]; int[] e = a[..]; One may also slice from the end. Again this is not allowed for pointers. int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[1..^2]; // { 20, 50, 100 } int[] c = a[^3..]; // { 50, 100, 200 } One may also use assign to slices: int[3] a = { 1, 20, 50 }; a[1..2] = 0; // a = { 1, 0, 0} Or copy slices to slices: int[3] a = { 1, 20, 50 }; int[3] b = { 2, 4, 5 } a[1..2] = b[0..1]; // a = { 1, 2, 4} Copying overlapping ranges, e.g. a[1..2] = a[0..1] is undefined behaviour. Conversion list int[4] int[*] int[] int[4]* int* int[4] copy - - - - int[*] copy assign cast cast cast int[] - assign assign assign - int[4]* - cast cast assign cast int* - assign assign assign assign Note that all casts above are inherently unsafe and will only work if the type cast is indeed compatible. For example: int[4] a; int[4]* b = &a; int* c = b; // Safe cast: int[4]* d = cast(c as int[4]*); // Faulty code with undefined behaviour: int[*] e = cast(c as int[*]*); int[*] a = @malloc(int[*]); a += 11; a += 12; a += 13; // Safe (2 is less than the dynamic size of a) int[2]* b = cast(a as int[2]*); // Faulty code with undefined behaviour // (4 is greater than the dynamic size of a) int[4]* c = cast(a as int[4]*); Internals Internally the layout of a slice is guaranteed to be struct { <type>* ptrToArray; usize arraySize; } . There is a built in struct __ArrayType_C3 which has the exact data layout of the fat array pointers. It is defined to be struct __ArrayType_C3 { void* ptrToArray; usize arraySize; } Iteration over arrays Slices, fixed and variable arrays may all be iterated over using for (Type x : array) : int[4] a = { 1, 2, 3, 5 }; for (int x : a) { ... } It is possible for any type to get this iteration by implementing the macro iterator(<Type> *type : value) : struct Vector { usize size; int* elements; } macro Vector.iterator(Vector *vector : value) { for (int i = 0; i < vector.size; i++) { yield value; } } Vector v = Vector.new(); v.add(3); v.add(7); // Will print 3 and 7 for (int i : v) { printf(\"%d\\n\"); }","title":"Arrays"},{"location":"arrays/#arrays","text":"Arrays has a central role in programming. C3 offers 3 types of arrays:","title":"Arrays"},{"location":"arrays/#fixed-arrays","text":"<type>[<size>] e.g. int[4] . These are treated as values and will be copied if given as parameter. Unlike C, the number is part of its type. Taking a pointer to a fixed array will create a pointer to a fixed array, e.g. int[4]* . Unlike C, fixed arrays do not decay into pointers, instead an int[4]* may be implicitly converted into an int* . // C int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(x); // C3 func int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(&x); When you want to initialize a fixed array without specififying the size, use the [+] array syntax: int[3] a = { 1, 2, 3}; int[+] b = { 4, 5, 6}; // Type inferred to be int[3]","title":"Fixed arrays"},{"location":"arrays/#variable-arrays","text":"Variable arrays are specially allocated arrays that are prefixed with both a size and a capacity. If allocated on the heap, they cannot expand, but heap allocated variable arrays will do so automatically using whatever memory allocator was used to create it. THIS PART WILL BE SUBJECT TO REVISION int[*] x = @malloc(int[*]); x += 10; x += 11; x.size; // => 2 x[1]; // => 11 A variable array can implicitly convert to a pointer: int[*] x = @malloc(int[*]); int *z = x; A variable array's reference is not stable under expansion, so any alias may be invalidated if appending occurs. int[*] x = @malloc(int[*]); int[*] *y = &x; int *z = x; for (int i = 0; i < 33; i++) x += 10; assert(y != &x); int *w = x; assert(z != w); Assigning a fixed array to a variable array will copy the contents: int[3] b = { 1, 2, 3}; int[*] a = @malloc(int[*]); a = b;","title":"Variable arrays"},{"location":"arrays/#built-in-functions-on-variable-arrays","text":"","title":"Built-in functions on variable arrays"},{"location":"arrays/#pop","text":"Removes the last element.","title":"pop()"},{"location":"arrays/#last","text":"Retrieves the last element.","title":"last()"},{"location":"arrays/#removeindex","text":"Removes an element in the array in O(n) time.","title":"remove(index)"},{"location":"arrays/#capacity","text":"Return the capacity of the array.","title":"capacity"},{"location":"arrays/#size","text":"return the size of the array.","title":"size"},{"location":"arrays/#resizesize","text":"Resize the array to the given size.","title":"resize(size)"},{"location":"arrays/#subarray","text":"The final type is the subarray <type>[] e.g. int[] . A subarray is a view into either a fixed or variable array. Internally it is represented as a struct containing a pointer and a size. Both fixed and variable arrays may be converted into slices, and slices may be implicitly converted to pointers: int[4] a = { 1, 2, 3, 4}; int[] b = &a; // Implicit conversion is always ok. int[4] c = cast(b as int[4]); // Will copy the value of b into c. int[4]* d = cast(b as int[4]); // Equivalent to d = &a int[*] e = @malloc(int[]); b.size; // Returns 4 e.size; // Returns 0 e += 1; e += 2; e.size; // Returns 2 int* f = b; // Equivalent to e = &a f = d; // implicit conversion ok. f = e; // implicit conversion ok. d = e; // ERROR! Not allowed d = cast(e as int[4]*); // Fine b = e; // Implicit conversion ok","title":"Subarray"},{"location":"arrays/#slicing-arrays","text":"It's possible to use a range syntax to create subarrays from pointers, arrays, vararrays and other subarrays. The usual syntax is arr[<start index>..<end index>] . The end index is included in the final result. int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; // The whole array as a slice. int[] c = a[1..2]; // { 20, 50 } It's possible to omit the first and last index, in which case the start and the len is inferred. Note that omitting the last index is not allowed for pointers. The following are all equivalent: int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; int[] c = a[..4]; int[] d = a[0..]; int[] e = a[..]; One may also slice from the end. Again this is not allowed for pointers. int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[1..^2]; // { 20, 50, 100 } int[] c = a[^3..]; // { 50, 100, 200 } One may also use assign to slices: int[3] a = { 1, 20, 50 }; a[1..2] = 0; // a = { 1, 0, 0} Or copy slices to slices: int[3] a = { 1, 20, 50 }; int[3] b = { 2, 4, 5 } a[1..2] = b[0..1]; // a = { 1, 2, 4} Copying overlapping ranges, e.g. a[1..2] = a[0..1] is undefined behaviour.","title":"Slicing arrays"},{"location":"arrays/#conversion-list","text":"int[4] int[*] int[] int[4]* int* int[4] copy - - - - int[*] copy assign cast cast cast int[] - assign assign assign - int[4]* - cast cast assign cast int* - assign assign assign assign Note that all casts above are inherently unsafe and will only work if the type cast is indeed compatible. For example: int[4] a; int[4]* b = &a; int* c = b; // Safe cast: int[4]* d = cast(c as int[4]*); // Faulty code with undefined behaviour: int[*] e = cast(c as int[*]*); int[*] a = @malloc(int[*]); a += 11; a += 12; a += 13; // Safe (2 is less than the dynamic size of a) int[2]* b = cast(a as int[2]*); // Faulty code with undefined behaviour // (4 is greater than the dynamic size of a) int[4]* c = cast(a as int[4]*);","title":"Conversion list"},{"location":"arrays/#internals","text":"Internally the layout of a slice is guaranteed to be struct { <type>* ptrToArray; usize arraySize; } . There is a built in struct __ArrayType_C3 which has the exact data layout of the fat array pointers. It is defined to be struct __ArrayType_C3 { void* ptrToArray; usize arraySize; }","title":"Internals"},{"location":"arrays/#iteration-over-arrays","text":"Slices, fixed and variable arrays may all be iterated over using for (Type x : array) : int[4] a = { 1, 2, 3, 5 }; for (int x : a) { ... } It is possible for any type to get this iteration by implementing the macro iterator(<Type> *type : value) : struct Vector { usize size; int* elements; } macro Vector.iterator(Vector *vector : value) { for (int i = 0; i < vector.size; i++) { yield value; } } Vector v = Vector.new(); v.add(3); v.add(7); // Will print 3 and 7 for (int i : v) { printf(\"%d\\n\"); }","title":"Iteration over arrays"},{"location":"attributes/","text":"Attributes Attributes are compile time annotations on functions, types, global constants and variables. Similar to Java annotations, a decoration may also take arguments. A attribute can also represent a bundle of attributes. Built in attributes packed (struct, union, enum) If used on a struct or enum: packs the type, including any components to minimum size. On an enum, it uses the smallest representation containing all its values. section(name) (var, func) Declares that a global variable or function should appear in a specific section. inline (func) Declares a function to always be inlined. aligned(alignment) (struct, union, var, func) This attribute sets the minimum alignment for a field or a variable. noreturn (func) Declares that the function will never return. weak (func, var) Emits a weak symbol rather than a global. opaque (struct, union, enum) Prevents the union or struct from being statically allocated by other modules. In the case of enums, prevents the enum from being converted to a value. New attributes The basic syntax for creating a new attribute is attribute <declaration type> @<name> . The type category is one of var , const , func , union , struct , enum , typedef and error . For example: attribute func myattribute; func void foo() myattribute { ... } Multi type attributes It's possible to make an attribute match more than a single declaration type, by separating them using comma: attribute func, enum, struct fooattribute; func void foo() @fooattribute { /* ... */ } struct Bar @fooattribute { int i; } Arguments An attribute may take a number of arguments, similar to a function. All such arguments must be compile time constants. attribute func intdec(int i) void foo() @intdec(2) { ... } Just like for function calls, the arguments may have defaults, use named arguments etc. However, varargs are not allowed. attribute func dec(int d, int i = 0, float f = 1.0) void foo() @dec(2) { ... } void bar() @dec(7, f = 3.0) { ... } Compile time attribute access What's useful about attributes is that they can be accessed during compile time: macro fooCheck($a) { $if (@defined($a.foo) { return \"Was fooed\"; } return \"Ok\"; } struct TestA { int i; } struct TestB @foo { float f; } func void test() { printf(\"Check TestA: \" @fooCheck(TestA) \"\\n\"); printf(\"Check TestB: \" @fooCheck(TestB) \"\\n\"); // Prints: // Check TestA: Ok // Check TestB: Was fooed } The values may be recovered: It's also possible to get hold of the values: attribute func myvar(int i = 0); func void test() @myvar(200) { /* ... */ } func void test() { printf(\"%d\", test.myvar.i); // Prints 200 } Bundled attributes It's also possible to create bundles of attributes, that simply contain other attributes. Unlike a normal attribute, an attribute bundle is a simple alias, so it has no real compile time information. attribute func foodec; attribute func bardec(int i = 0); attribute mixdec alias foodec, bardec(3); // As if we had added foodec, bardec(3) func void test() @mixdec { /* ... */ } A attribute bundle might also be completely empty. Iterating over attributes Within a macro it's possible to iterate in compile time over all non-alias attributes using $each . attribute struct special; struct TestA @special { int i; } struct TestB { float f; } struct TestC @special { float f; } macro @specialStructs() { string[+] res = {}; $each(@special as $x) { res += @name($x); } // The above expands to: // res += \"TestA\"; // res += \"TestC\"; return res; } // SPECIAL_STRUCTS = { \"TestA\", \"TestB\" } const string[] SPECIAL_STRUCTS = @specialStructs();","title":"Attributes"},{"location":"attributes/#attributes","text":"Attributes are compile time annotations on functions, types, global constants and variables. Similar to Java annotations, a decoration may also take arguments. A attribute can also represent a bundle of attributes.","title":"Attributes"},{"location":"attributes/#built-in-attributes","text":"","title":"Built in attributes"},{"location":"attributes/#packed-struct-union-enum","text":"If used on a struct or enum: packs the type, including any components to minimum size. On an enum, it uses the smallest representation containing all its values.","title":"packed (struct, union, enum)"},{"location":"attributes/#sectionname-var-func","text":"Declares that a global variable or function should appear in a specific section.","title":"section(name) (var, func)"},{"location":"attributes/#inline-func","text":"Declares a function to always be inlined.","title":"inline (func)"},{"location":"attributes/#alignedalignment-struct-union-var-func","text":"This attribute sets the minimum alignment for a field or a variable.","title":"aligned(alignment) (struct, union, var, func)"},{"location":"attributes/#noreturn-func","text":"Declares that the function will never return.","title":"noreturn (func)"},{"location":"attributes/#weak-func-var","text":"Emits a weak symbol rather than a global.","title":"weak (func, var)"},{"location":"attributes/#opaque-struct-union-enum","text":"Prevents the union or struct from being statically allocated by other modules. In the case of enums, prevents the enum from being converted to a value.","title":"opaque (struct, union, enum)"},{"location":"attributes/#new-attributes","text":"The basic syntax for creating a new attribute is attribute <declaration type> @<name> . The type category is one of var , const , func , union , struct , enum , typedef and error . For example: attribute func myattribute; func void foo() myattribute { ... }","title":"New attributes"},{"location":"attributes/#multi-type-attributes","text":"It's possible to make an attribute match more than a single declaration type, by separating them using comma: attribute func, enum, struct fooattribute; func void foo() @fooattribute { /* ... */ } struct Bar @fooattribute { int i; }","title":"Multi type attributes"},{"location":"attributes/#arguments","text":"An attribute may take a number of arguments, similar to a function. All such arguments must be compile time constants. attribute func intdec(int i) void foo() @intdec(2) { ... } Just like for function calls, the arguments may have defaults, use named arguments etc. However, varargs are not allowed. attribute func dec(int d, int i = 0, float f = 1.0) void foo() @dec(2) { ... } void bar() @dec(7, f = 3.0) { ... }","title":"Arguments"},{"location":"attributes/#compile-time-attribute-access","text":"What's useful about attributes is that they can be accessed during compile time: macro fooCheck($a) { $if (@defined($a.foo) { return \"Was fooed\"; } return \"Ok\"; } struct TestA { int i; } struct TestB @foo { float f; } func void test() { printf(\"Check TestA: \" @fooCheck(TestA) \"\\n\"); printf(\"Check TestB: \" @fooCheck(TestB) \"\\n\"); // Prints: // Check TestA: Ok // Check TestB: Was fooed } The values may be recovered: It's also possible to get hold of the values: attribute func myvar(int i = 0); func void test() @myvar(200) { /* ... */ } func void test() { printf(\"%d\", test.myvar.i); // Prints 200 }","title":"Compile time attribute access"},{"location":"attributes/#bundled-attributes","text":"It's also possible to create bundles of attributes, that simply contain other attributes. Unlike a normal attribute, an attribute bundle is a simple alias, so it has no real compile time information. attribute func foodec; attribute func bardec(int i = 0); attribute mixdec alias foodec, bardec(3); // As if we had added foodec, bardec(3) func void test() @mixdec { /* ... */ } A attribute bundle might also be completely empty.","title":"Bundled attributes"},{"location":"attributes/#iterating-over-attributes","text":"Within a macro it's possible to iterate in compile time over all non-alias attributes using $each . attribute struct special; struct TestA @special { int i; } struct TestB { float f; } struct TestC @special { float f; } macro @specialStructs() { string[+] res = {}; $each(@special as $x) { res += @name($x); } // The above expands to: // res += \"TestA\"; // res += \"TestC\"; return res; } // SPECIAL_STRUCTS = { \"TestA\", \"TestB\" } const string[] SPECIAL_STRUCTS = @specialStructs();","title":"Iterating over attributes"},{"location":"buildcommands/","text":"Build Commands When starting out, with C3 it's natural to use run to try things out. For larger projects, the built-in build system is instead recommended. By default the compiler is compiling stand-alone files to output an executable binary. c3c <file1> <file2> <file3> run The run command works same as compilation, but also immediately runs the resulting executable. c3c run <file1> <file2> <file3> Common additional parameters Additional parameters: - --lib <path> add a library to search. - --output <path> override the output directory. - --path <path> execute as if standing at init c3c init <project_name> [optional path] . Create a new project structure in the current directory. Use the --template to select a template. The following are built in: default - the default template, produces an executable. lib - template for producing a library. staticlib - template for producing a static library. It is also possible to give the path to a custom template. Additional parameters: - --template <path> indicate an alternative template to use. c3c init hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world build build [target] Build the project in the current path. It doesn't matter where in the project structure you are. The built in templates define two targets: debug (which is the default) and release . clean clean build-run build-run [target] Build the target (if needed) and run the executable. clean-run clean-run [target] Clean, build and run the target. dist dist [target] Clean, build and package the target. docs docs [target] Rebuilds the documentation. bench bench [target] Runs benchmarks on a target.","title":"Commands"},{"location":"buildcommands/#build-commands","text":"When starting out, with C3 it's natural to use run to try things out. For larger projects, the built-in build system is instead recommended. By default the compiler is compiling stand-alone files to output an executable binary. c3c <file1> <file2> <file3>","title":"Build Commands"},{"location":"buildcommands/#run","text":"The run command works same as compilation, but also immediately runs the resulting executable. c3c run <file1> <file2> <file3>","title":"run"},{"location":"buildcommands/#common-additional-parameters","text":"Additional parameters: - --lib <path> add a library to search. - --output <path> override the output directory. - --path <path> execute as if standing at","title":"Common additional parameters"},{"location":"buildcommands/#init","text":"c3c init <project_name> [optional path] . Create a new project structure in the current directory. Use the --template to select a template. The following are built in: default - the default template, produces an executable. lib - template for producing a library. staticlib - template for producing a static library. It is also possible to give the path to a custom template. Additional parameters: - --template <path> indicate an alternative template to use. c3c init hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world","title":"init"},{"location":"buildcommands/#build","text":"build [target] Build the project in the current path. It doesn't matter where in the project structure you are. The built in templates define two targets: debug (which is the default) and release .","title":"build"},{"location":"buildcommands/#clean","text":"clean","title":"clean"},{"location":"buildcommands/#build-run","text":"build-run [target] Build the target (if needed) and run the executable.","title":"build-run"},{"location":"buildcommands/#clean-run","text":"clean-run [target] Clean, build and run the target.","title":"clean-run"},{"location":"buildcommands/#dist","text":"dist [target] Clean, build and package the target.","title":"dist"},{"location":"buildcommands/#docs","text":"docs [target] Rebuilds the documentation.","title":"docs"},{"location":"buildcommands/#bench","text":"bench [target] Runs benchmarks on a target.","title":"bench"},{"location":"buildintro/","text":"Build System Building a project is done by invoking the C3 compiler with the build or run command inside of the project structure. The compiler will search upwards in the file hierachy until a project.toml file is found.","title":"Introduction"},{"location":"buildintro/#build-system","text":"Building a project is done by invoking the C3 compiler with the build or run command inside of the project structure. The compiler will search upwards in the file hierachy until a project.toml file is found.","title":"Build System"},{"location":"builtinmacros/","text":"Built-in macros There are several built-in macros to inspect the code during compile and runtime. @bitcast @cast @describe @elements @name @sizeof @typeof @bitcast Bitcast reinterprets the contents of a variable without any conversion. Bitsize must be the same for both types. float f = 12.3; int i = @bitcast(f, int); printf(\"%x\", i); // Prints 4144cccd @describe Creates a runtime description of a value. enum FooEnum { A, B } func char[] test() { FooEnum x = FooEnum.A; return @describe(x); // Returns \"FooEnum.A\" } struct Foo { int x; char[] y; } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @describe(x); // Returns \"Foo { x: 2, y: \"bar\" }\" } @elements Returns an array of an error set or enum set. FooEnum[] values = @elements(FooEnum); // Same as FooEnum[] values = { FooEnum.A, FooEnum.B }; @name Creates a runtime name of a value. func char[] test() { FooEnum x = FooEnum.B; return @name(x); // Returns \"B\" } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @name(x); // Returns \"Foo\" } @offset Returns the byte offset in a structure, like offsetof in C @offset(Foo, y); // => returns 4 or 8 @sizeof Returns the size of a type or an expression func usize size_test() { return @sizeof(Foo); // Might compile to 16 } func usize size_test2() { return @sizeof(size_test()); // Usually returns 8 (the size of usize) } @typeof Returns the type of an expression @typeof(size_test()) x = size_test(); @typeof(x) y = x + 1;","title":"Built-in Macros"},{"location":"builtinmacros/#built-in-macros","text":"There are several built-in macros to inspect the code during compile and runtime. @bitcast @cast @describe @elements @name @sizeof @typeof","title":"Built-in macros"},{"location":"builtinmacros/#bitcast","text":"Bitcast reinterprets the contents of a variable without any conversion. Bitsize must be the same for both types. float f = 12.3; int i = @bitcast(f, int); printf(\"%x\", i); // Prints 4144cccd","title":"@bitcast"},{"location":"builtinmacros/#describe","text":"Creates a runtime description of a value. enum FooEnum { A, B } func char[] test() { FooEnum x = FooEnum.A; return @describe(x); // Returns \"FooEnum.A\" } struct Foo { int x; char[] y; } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @describe(x); // Returns \"Foo { x: 2, y: \"bar\" }\" }","title":"@describe"},{"location":"builtinmacros/#elements","text":"Returns an array of an error set or enum set. FooEnum[] values = @elements(FooEnum); // Same as FooEnum[] values = { FooEnum.A, FooEnum.B };","title":"@elements"},{"location":"builtinmacros/#name","text":"Creates a runtime name of a value. func char[] test() { FooEnum x = FooEnum.B; return @name(x); // Returns \"B\" } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @name(x); // Returns \"Foo\" }","title":"@name"},{"location":"builtinmacros/#offset","text":"Returns the byte offset in a structure, like offsetof in C @offset(Foo, y); // => returns 4 or 8","title":"@offset"},{"location":"builtinmacros/#sizeof","text":"Returns the size of a type or an expression func usize size_test() { return @sizeof(Foo); // Might compile to 16 } func usize size_test2() { return @sizeof(size_test()); // Usually returns 8 (the size of usize) }","title":"@sizeof"},{"location":"builtinmacros/#typeof","text":"Returns the type of an expression @typeof(size_test()) x = size_test(); @typeof(x) y = x + 1;","title":"@typeof"},{"location":"changes/","text":"Change log Revision 2020-05-08 Added rationale for some changes from C. Updated undefined and undefined behaviour . Removed many of the fine grained module features. Removed \"local\" visibility in modules . All modules are now distinct, parent modules do not have any special access to sub modules. Added as module imports. Revision 2020-04-05 \"next\" is now \"nextcase\". Added link to the C3 discord. The conversions page updated with new conversion rules. Updated compound literal syntax. Removed undefined behaviour behaviour on integer overflow and added a list of unspecified behaviour. Revision 2020-12-23 Updated slice behaviour. Updated expression block syntax. Added link to specification-in-progress. Revision 2020-12-04 Local variables are implicitly zero. Removed in-block declarations. Changed struct member initialization syntax. Changed named parameter syntax. Updated on macro syntax. Removed built in c types. Revision 2020-08-22 Added slice operations. Changed cast syntax to cast(<expr> as <type>) . Revision 2020-07-08 Additions to error handling . Introduction of labelled nextcase , break and continue . Removal of goto . Revision 2020-06-17 Alternate casts in idea . Method functions simply renamed to \"method\". Completely revised error handling . Revision 2020-04-23 Updated error handling, adding try-else-jump and changed how errors are passed. Included reflection page Revision 2020-03-30 Added Odin and D to comparisons. Updated text on how to contribute. Updated the example on undefined behaviour. Updated text on conversions. Moved double -> float conversion to \"ideas\" Fixed some typos. Revision 2020-03-29 Type inference for enums. Included macro page. Corrected precedence rules with try and @ . Type functions. Managed variables back to ideas. Volatile moved back to ideas. Removed implicit lossy signed conversions. Introducing safe signed-unsigned comparisons. \"Function block\" renamed \"expression block\". @ sigil removed from macros and is only used with macro invocations. Changed cast syntax from @cast(Type, var) to cast(var, Type) Revision 2019-12-26 Added module versioning system idea . Fleshed out polymorphic functions. Unsigned to signed promotion mentioned in \"changes from C\" Revision 2019-12-25 Changes how generic modules work. Switched so that vararrays use Type[*] and sub arrays use Type[] . Added sub module granularity, partial imports (only importing selected functions and types), removal of local , extended aliasing. See modules . Updated \"changes from C\" with removal of multiple declarations. Revision 2019-12-11 Updated the setup page. Revision 2019-12-03 Added page on conversions . Added page on undefined behaviour . Revision 2019-11-01 Updated \"changes from C\" with the lack of array decays. Added FourCC to the language Added name alias to ideas Added align asserts to ideas Added built in tests to ideas Added arrays page Added function blocks to statements page . Added expressions page . Added variables page . Moved managed pointers from idea to the variables page . Revision 2019-09-30 Removed references (non nullable pointers) Removed idea with aliasing in import Revision 2019-08-14 Compile time run-include and include ideas. New module system idea. Revision 2019-08-14 Namespace separator changed to :: instead of . to simplify parsing. Added FourCC, Macro text interpolation to ideas. Added Yacc grammar (incomplete) Added \"attribute\" keyword. Changed type alias declaration to use typedef ... as ... . Introduced type operator. Added section about attributes. Revision 2019-08-02 Added error example. Added generics example. Added method function example. Added idea implicit method functions Expanded the types page somewhat. Revision 2019-07-30 Added default and named arguments to the functions page . Added varargs to the functions page . Added idea about hierarchal memory. Added idea of raw dynamic safe arrays & strings. Volatile sections are no longer prefixed by '@' Added idea regarding c3 interop Added page about c interop . Removed c_ichar and c_uchar types as they are redundant. Updates to keywords on the grammar page ../syntax). Revision 2019-07-27 Updated grammar with keywords. Added the docs & comments page. Updated the pre and post conditions . Revision 2019-07-24 Idea: typed varargs. Added \"pure\" post condition Updated c3c commands. Removed the type keyword for defining union/struct/enum/error. Revision 2019-07-23 Added to generic functions examples for [] and []= Developed ideas about vectors in the idea section . Defined 2's complement for signed integers. Idea: Managed pointers. Updated naming rules for types. Added more naming rules + examples of them. Removed \"defer on function signatures\" from ideas. Removed \"managed qualifier\" from ideas. Removed \"defer sugar\" from ideas. Removed \"built in dynamic arrays\" from ideas. Added library section. Added more about pre and post conditions . Revision 2019-07-22 Added \"Design Principles\" to the index page. Revision 2019-07-21 \"return\" rather than function name is used in post conditions. See Functions Added \"@include\" macro for textual includes. See Modules . Files to without module for single file compilations is now ok as a special case. See Modules Added cone style array idea to the idea section . Added idea about defer on error to the idea section . Added idea for aliasing generic structs in the import to the idea section . Added idea for changing automatic signed <-> unsigned conversion to the idea section . Added Changes from C and Statements sections. Removal of volatile . See Changes from C and Statements Removal of const See Changes from C","title":"Changes"},{"location":"changes/#change-log","text":"","title":"Change log"},{"location":"changes/#revision-2020-05-08","text":"Added rationale for some changes from C. Updated undefined and undefined behaviour . Removed many of the fine grained module features. Removed \"local\" visibility in modules . All modules are now distinct, parent modules do not have any special access to sub modules. Added as module imports.","title":"Revision 2020-05-08"},{"location":"changes/#revision-2020-04-05","text":"\"next\" is now \"nextcase\". Added link to the C3 discord. The conversions page updated with new conversion rules. Updated compound literal syntax. Removed undefined behaviour behaviour on integer overflow and added a list of unspecified behaviour.","title":"Revision 2020-04-05"},{"location":"changes/#revision-2020-12-23","text":"Updated slice behaviour. Updated expression block syntax. Added link to specification-in-progress.","title":"Revision 2020-12-23"},{"location":"changes/#revision-2020-12-04","text":"Local variables are implicitly zero. Removed in-block declarations. Changed struct member initialization syntax. Changed named parameter syntax. Updated on macro syntax. Removed built in c types.","title":"Revision 2020-12-04"},{"location":"changes/#revision-2020-08-22","text":"Added slice operations. Changed cast syntax to cast(<expr> as <type>) .","title":"Revision 2020-08-22"},{"location":"changes/#revision-2020-07-08","text":"Additions to error handling . Introduction of labelled nextcase , break and continue . Removal of goto .","title":"Revision 2020-07-08"},{"location":"changes/#revision-2020-06-17","text":"Alternate casts in idea . Method functions simply renamed to \"method\". Completely revised error handling .","title":"Revision 2020-06-17"},{"location":"changes/#revision-2020-04-23","text":"Updated error handling, adding try-else-jump and changed how errors are passed. Included reflection page","title":"Revision 2020-04-23"},{"location":"changes/#revision-2020-03-30","text":"Added Odin and D to comparisons. Updated text on how to contribute. Updated the example on undefined behaviour. Updated text on conversions. Moved double -> float conversion to \"ideas\" Fixed some typos.","title":"Revision 2020-03-30"},{"location":"changes/#revision-2020-03-29","text":"Type inference for enums. Included macro page. Corrected precedence rules with try and @ . Type functions. Managed variables back to ideas. Volatile moved back to ideas. Removed implicit lossy signed conversions. Introducing safe signed-unsigned comparisons. \"Function block\" renamed \"expression block\". @ sigil removed from macros and is only used with macro invocations. Changed cast syntax from @cast(Type, var) to cast(var, Type)","title":"Revision 2020-03-29"},{"location":"changes/#revision-2019-12-26","text":"Added module versioning system idea . Fleshed out polymorphic functions. Unsigned to signed promotion mentioned in \"changes from C\"","title":"Revision 2019-12-26"},{"location":"changes/#revision-2019-12-25","text":"Changes how generic modules work. Switched so that vararrays use Type[*] and sub arrays use Type[] . Added sub module granularity, partial imports (only importing selected functions and types), removal of local , extended aliasing. See modules . Updated \"changes from C\" with removal of multiple declarations.","title":"Revision 2019-12-25"},{"location":"changes/#revision-2019-12-11","text":"Updated the setup page.","title":"Revision 2019-12-11"},{"location":"changes/#revision-2019-12-03","text":"Added page on conversions . Added page on undefined behaviour .","title":"Revision 2019-12-03"},{"location":"changes/#revision-2019-11-01","text":"Updated \"changes from C\" with the lack of array decays. Added FourCC to the language Added name alias to ideas Added align asserts to ideas Added built in tests to ideas Added arrays page Added function blocks to statements page . Added expressions page . Added variables page . Moved managed pointers from idea to the variables page .","title":"Revision 2019-11-01"},{"location":"changes/#revision-2019-09-30","text":"Removed references (non nullable pointers) Removed idea with aliasing in import","title":"Revision 2019-09-30"},{"location":"changes/#revision-2019-08-14","text":"Compile time run-include and include ideas. New module system idea.","title":"Revision 2019-08-14"},{"location":"changes/#revision-2019-08-14_1","text":"Namespace separator changed to :: instead of . to simplify parsing. Added FourCC, Macro text interpolation to ideas. Added Yacc grammar (incomplete) Added \"attribute\" keyword. Changed type alias declaration to use typedef ... as ... . Introduced type operator. Added section about attributes.","title":"Revision 2019-08-14"},{"location":"changes/#revision-2019-08-02","text":"Added error example. Added generics example. Added method function example. Added idea implicit method functions Expanded the types page somewhat.","title":"Revision 2019-08-02"},{"location":"changes/#revision-2019-07-30","text":"Added default and named arguments to the functions page . Added varargs to the functions page . Added idea about hierarchal memory. Added idea of raw dynamic safe arrays & strings. Volatile sections are no longer prefixed by '@' Added idea regarding c3 interop Added page about c interop . Removed c_ichar and c_uchar types as they are redundant. Updates to keywords on the grammar page ../syntax).","title":"Revision 2019-07-30"},{"location":"changes/#revision-2019-07-27","text":"Updated grammar with keywords. Added the docs & comments page. Updated the pre and post conditions .","title":"Revision 2019-07-27"},{"location":"changes/#revision-2019-07-24","text":"Idea: typed varargs. Added \"pure\" post condition Updated c3c commands. Removed the type keyword for defining union/struct/enum/error.","title":"Revision 2019-07-24"},{"location":"changes/#revision-2019-07-23","text":"Added to generic functions examples for [] and []= Developed ideas about vectors in the idea section . Defined 2's complement for signed integers. Idea: Managed pointers. Updated naming rules for types. Added more naming rules + examples of them. Removed \"defer on function signatures\" from ideas. Removed \"managed qualifier\" from ideas. Removed \"defer sugar\" from ideas. Removed \"built in dynamic arrays\" from ideas. Added library section. Added more about pre and post conditions .","title":"Revision 2019-07-23"},{"location":"changes/#revision-2019-07-22","text":"Added \"Design Principles\" to the index page.","title":"Revision 2019-07-22"},{"location":"changes/#revision-2019-07-21","text":"\"return\" rather than function name is used in post conditions. See Functions Added \"@include\" macro for textual includes. See Modules . Files to without module for single file compilations is now ok as a special case. See Modules Added cone style array idea to the idea section . Added idea about defer on error to the idea section . Added idea for aliasing generic structs in the import to the idea section . Added idea for changing automatic signed <-> unsigned conversion to the idea section . Added Changes from C and Statements sections. Removal of volatile . See Changes from C and Statements Removal of const See Changes from C","title":"Revision 2019-07-21"},{"location":"changesfromc/","text":"Changes from C Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes: No mandatory header files There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications. Removal of the old C macro system The old C macro system is replaced by a new C3 macro system. Import and modules C3 uses module imports instead of header includes to link modules together. Member access using . even for pointers The -> operator is removed, access uses dot for both direct and pointer access. Note that this is just single access: to access a pointer of a pointer (e.g. int** ) an explicit dereference would be needed. Different operator precedence Notably bit operations have higher precedence than +/-, making code like this: a & b == c evaluate like (a & b) == c instead of C's a & (b == c) . See the page about precedence rules . Removal of the const type qualifier The const qualifier is only retained for actual constant variables. C3 uses a special type of post condition for functions to indicate that they do not alter in parameters. /** * This function ensures that foo is not changed in the function, nor is bar.x altered. * @ensure const(foo), const(bar.x) **/ func void test(Foo* foo, Bar* bar) { bar.y = foo.x; // bar.x = foo.x - compile time error! // foo.x = bar.y - compile time error! } Rationale: const correctness requires littering const across the code base. Although const is useful, it provides weaker guarantees that it appears. Fixed arrays do not decay and have copy sematics C3 has three different array types. Variable arrays and slices decay to pointers, but fixed arrays are value objects and do not decay. int[3] a = { 1, 2, 3 }; int[4]* b = &a; // No conversion int* c = a; // ERROR int* d = &a; // Valid implicit conversion int* e = b; // Valid implicit conversion int[3] f = a; // Copy by value! Removal of multiple declaration syntax Only a single declaration is allowed per statement in C3: int i, j; // ERROR int a; // Fine In conditionals, a special form of multiple declarations are allowed but each must then provide its type: for (int i = 0, int j = 1; i < 10; i++, j++) { ... } Integer promotions rules and safe signed-unsigned comparisons Promotion rules for integer types are different from C. Most prominently, C3 does left side widening in the case of long x = intValue1 + intValue2 . In C this becomes: long x = (long)(intValue1 + intValue2), whereas in C3 it would behaves as long x = (long)intValue1 + (long)intValue2` to minimize chance of overflow. (read more on the conversion page . C3 also adds safe signed-unsigned comparisons , this means that comparing signed and unsigned values will always yield the correct result: // The code below will print \"Hello C3!\" on C3 and \"Hello C!\" in C. int i = -1; uint j = 1; // int z = i + j; <- Error, explicit cast needed. if (i < j) { printf(\"Hello C3!\\n\"); } else { printf(\"Hello C!\\n\"); } Goto removed goto is removed and replaced with labelled break and continue together with the nextcase statement that allows you to jump between cases in a switch statement. *Rationale: It is very difficult to make goto work well with defer and implicit unwrapping of failables. It is not just making the compiler harder to write, but the code is harder to understand as well. The replacements together with defer cover many if not all usages of goto in regular code. Locals variables are implictly zeroed In C global variables are implicitly zeroed out, but local variables aren't. In C3 local variables are zeroed out by default, but may be explicitly undefined to get the C behaviour. Rationale: In the \"zero-is-initialization\" paradigm, zeroing variables, in particular structs, is very common. By offering zero initialization by default this avoids a whole class of vulnerabilites. Another alternative that was considered for C3 was mandatory initialization, but this adds a lot of extra boilerplate. C3 also offers a way to opt out of zero-initialization, so the change comes at no performance loss.","title":"Changes from C"},{"location":"changesfromc/#changes-from-c","text":"Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes:","title":"Changes from C"},{"location":"changesfromc/#no-mandatory-header-files","text":"There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications.","title":"No mandatory header files"},{"location":"changesfromc/#removal-of-the-old-c-macro-system","text":"The old C macro system is replaced by a new C3 macro system.","title":"Removal of the old C macro system"},{"location":"changesfromc/#import-and-modules","text":"C3 uses module imports instead of header includes to link modules together.","title":"Import and modules"},{"location":"changesfromc/#member-access-using-even-for-pointers","text":"The -> operator is removed, access uses dot for both direct and pointer access. Note that this is just single access: to access a pointer of a pointer (e.g. int** ) an explicit dereference would be needed.","title":"Member access using . even for pointers"},{"location":"changesfromc/#different-operator-precedence","text":"Notably bit operations have higher precedence than +/-, making code like this: a & b == c evaluate like (a & b) == c instead of C's a & (b == c) . See the page about precedence rules .","title":"Different operator precedence"},{"location":"changesfromc/#removal-of-the-const-type-qualifier","text":"The const qualifier is only retained for actual constant variables. C3 uses a special type of post condition for functions to indicate that they do not alter in parameters. /** * This function ensures that foo is not changed in the function, nor is bar.x altered. * @ensure const(foo), const(bar.x) **/ func void test(Foo* foo, Bar* bar) { bar.y = foo.x; // bar.x = foo.x - compile time error! // foo.x = bar.y - compile time error! } Rationale: const correctness requires littering const across the code base. Although const is useful, it provides weaker guarantees that it appears.","title":"Removal of the const type qualifier"},{"location":"changesfromc/#fixed-arrays-do-not-decay-and-have-copy-sematics","text":"C3 has three different array types. Variable arrays and slices decay to pointers, but fixed arrays are value objects and do not decay. int[3] a = { 1, 2, 3 }; int[4]* b = &a; // No conversion int* c = a; // ERROR int* d = &a; // Valid implicit conversion int* e = b; // Valid implicit conversion int[3] f = a; // Copy by value!","title":"Fixed arrays do not decay and have copy sematics"},{"location":"changesfromc/#removal-of-multiple-declaration-syntax","text":"Only a single declaration is allowed per statement in C3: int i, j; // ERROR int a; // Fine In conditionals, a special form of multiple declarations are allowed but each must then provide its type: for (int i = 0, int j = 1; i < 10; i++, j++) { ... }","title":"Removal of multiple declaration syntax"},{"location":"changesfromc/#integer-promotions-rules-and-safe-signed-unsigned-comparisons","text":"Promotion rules for integer types are different from C. Most prominently, C3 does left side widening in the case of long x = intValue1 + intValue2 . In C this becomes: long x = (long)(intValue1 + intValue2), whereas in C3 it would behaves as long x = (long)intValue1 + (long)intValue2` to minimize chance of overflow. (read more on the conversion page . C3 also adds safe signed-unsigned comparisons , this means that comparing signed and unsigned values will always yield the correct result: // The code below will print \"Hello C3!\" on C3 and \"Hello C!\" in C. int i = -1; uint j = 1; // int z = i + j; <- Error, explicit cast needed. if (i < j) { printf(\"Hello C3!\\n\"); } else { printf(\"Hello C!\\n\"); }","title":"Integer promotions rules and safe signed-unsigned comparisons"},{"location":"changesfromc/#goto-removed","text":"goto is removed and replaced with labelled break and continue together with the nextcase statement that allows you to jump between cases in a switch statement. *Rationale: It is very difficult to make goto work well with defer and implicit unwrapping of failables. It is not just making the compiler harder to write, but the code is harder to understand as well. The replacements together with defer cover many if not all usages of goto in regular code.","title":"Goto removed"},{"location":"changesfromc/#locals-variables-are-implictly-zeroed","text":"In C global variables are implicitly zeroed out, but local variables aren't. In C3 local variables are zeroed out by default, but may be explicitly undefined to get the C behaviour. Rationale: In the \"zero-is-initialization\" paradigm, zeroing variables, in particular structs, is very common. By offering zero initialization by default this avoids a whole class of vulnerabilites. Another alternative that was considered for C3 was mandatory initialization, but this adds a lot of extra boilerplate. C3 also offers a way to opt out of zero-initialization, so the change comes at no performance loss.","title":"Locals variables are implictly zeroed"},{"location":"cinterop/","text":"C Interop C3 aims at seamless C interop. That means that you should be able to use import with C as easy as if it was a C3 module. See the idea section for more details","title":"C Interop"},{"location":"cinterop/#c-interop","text":"C3 aims at seamless C interop. That means that you should be able to use import with C as easy as if it was a C3 module. See the idea section for more details","title":"C Interop"},{"location":"comments/","text":"Comments and docs C3 uses three distinct comment types: The normal // line comment, which is terminated at the end of the line. The classic /* ... */ C style comment. Documentation comments /** ... **/ the text within these comments will be parsed as documentation and optional contracts on the following code. Nested comments /+ ... +/ . Like C style comments, but they are allowed to nest. Documentation Documentation comments start with /** and must be terminated using */ . Note that any number of * may follow /** and any number of stars may preceed */ . Any space and * in the beginning of each line will be ignored. Here is an example: /** * Here are som docs. * @param foo The number of foos. * @required foo > 4 * @deprecated * @mycustom 2 **/ void bar(int foo) { printf(\"%d\", foo); } In the example above, the following is parsed as description: \"Here are the docs.\" , then there is a description associated with the foo parameter: \"The number of foos\" . On top of that there are two annotations for the compiler: @required foo > 4 which tells the compiler and a user of the function that a precondition is that foo must be greater than 4. It is also marked as @deprecated, which can be used to display warnings. Finally a custom annotation, \"@mycustom\" is added. The compiler is free to silently ignore such annotations, but can optionally emit warnings for them, it is otherwise ignored. Available annotations Name format @param @param <param> <description> @return @return <description> @throws @throws <description> @deprecated @deprecated <optional description> @require @require <expr1>, <expr2>, ... @ensure @ensure <expre1>, <expr2>, ... @const @const <param1>, <param2>, ... @pure @pure @reqparse @reqparse <expr1>, <expr2>, ... See pre and post conditions for information regarding @require , @ensure , @const , @pure , @reqparse .","title":"Comments & Docs"},{"location":"comments/#comments-and-docs","text":"C3 uses three distinct comment types: The normal // line comment, which is terminated at the end of the line. The classic /* ... */ C style comment. Documentation comments /** ... **/ the text within these comments will be parsed as documentation and optional contracts on the following code. Nested comments /+ ... +/ . Like C style comments, but they are allowed to nest.","title":"Comments and docs"},{"location":"comments/#documentation","text":"Documentation comments start with /** and must be terminated using */ . Note that any number of * may follow /** and any number of stars may preceed */ . Any space and * in the beginning of each line will be ignored. Here is an example: /** * Here are som docs. * @param foo The number of foos. * @required foo > 4 * @deprecated * @mycustom 2 **/ void bar(int foo) { printf(\"%d\", foo); } In the example above, the following is parsed as description: \"Here are the docs.\" , then there is a description associated with the foo parameter: \"The number of foos\" . On top of that there are two annotations for the compiler: @required foo > 4 which tells the compiler and a user of the function that a precondition is that foo must be greater than 4. It is also marked as @deprecated, which can be used to display warnings. Finally a custom annotation, \"@mycustom\" is added. The compiler is free to silently ignore such annotations, but can optionally emit warnings for them, it is otherwise ignored.","title":"Documentation"},{"location":"comments/#available-annotations","text":"Name format @param @param <param> <description> @return @return <description> @throws @throws <description> @deprecated @deprecated <optional description> @require @require <expr1>, <expr2>, ... @ensure @ensure <expre1>, <expr2>, ... @const @const <param1>, <param2>, ... @pure @pure @reqparse @reqparse <expr1>, <expr2>, ... See pre and post conditions for information regarding @require , @ensure , @const , @pure , @reqparse .","title":"Available annotations"},{"location":"compare/","text":"Language comparisons An important question to answer is \"How does C3 compare to other similar programming languages?\". Here is an extremely brief (and not yet complete) overview. C As C3 is an evolution of C, the languages are quite similar. C3 adds features, but also removes a few. In C3 but not in C Module system Integrated build system Generics Semantic Macros Error handling Defer Value methods Associated enum data Subtypes Optional contracts Built-in strings, maps, subarrays and vararrays In C but not in C3 Qualified types ( const , volatile etc) Unsafe implicit conversions C++ C++ is a very complex object oriented \"almost superset\" of C. It tries to be everything to everyone, while squeezing this into a C syntax. The language is well known for its many pitfalls and quirky corners \u2013 as well as its long compile times. C3 is in many ways different from C++ in the same way that C is different from C++, but the semantic macro system and the generics close the gap in terms of writing reusable generic code. The module system and error handling is also very different from how C++ does things. In C++ but not in C3 Objects and classes RAII Exceptions In C3 but not in C++ Module system (yet) Integrated build system Semantic macros Error handling Defer Associated enum data Built-in strings, maps, subarrays and vararrays Rust Rust is a safe systems programming language. While not quite as complex as C++, it is still a feature rich programming language with semantic macros, traits and pattern matching to mention a few. Error handling is handled using Result and Optional which is similar to how C3 works. C3 compares to Rust much like C, although the presence of built in subarrays and strings reduces the places where C3 is unsafe. Rust provides arrays and strings, but they are not built in. Subarrays are the same as Rust's slices. In Rust but not in C3 RAII Memory safety Safe union types with functions Different syntax from C Pattern matching Async built in In C3 but not in Rust Same ease of programming as C Built-in strings, maps, vararrays Optional contracts Familiar C syntax and behaviour Zig Zig is a systems programming language with extensive compile time execution to enable polymorphic functions and parameterized types. It aims to be a C replacement. Compared to C3, Zig tries to be a completely new language in terms of syntax and feel. C3 uses macros to a modest degree where it is more pervasive in Zig, and does not depart from C in the same degree. Like Rust it features slices as a first class type. The standard library uses an explicit allocator to allow it to work with many different allocation strategies. Zig is a very ambitious project, aiming to support as many types of platforms as possible. In Zig but not in C3 Pervasive compile time execution. Memory allocation failure is an error. Zig's compile time execution is the build system. Different syntax and behaviour compared to C. Structs define namespace. Async primitives built in. In C3 but not in Zig Module system Integrated build system Built-in strings, maps, vararrays Optional contracts Familiar C syntax and behaviour Jai Jai is a programming language aimed at high performance game programming. It has an extensive compile time meta programming functionality, even to the point of being able to run programs at compile time. It also has compile time polymorphism, a powerful macro system and uses an implicit context system to switch allocation schemes. In Jai but not in C3 Pervasive compile time execution. Jai's compile time execution is the build system. Different syntax and behaviour compared to C. More poweful macro system than C3. Implicit constructors In C3 but not in Jai Module system Integrated build system Built-in strings and maps Optional contracts Familiar C syntax and behaviour Fairly small language Odin Odin is a language built for high performance but tries to remain a simple language to learn. Superficially the syntax shares much with Jai, and some of Jai's features things \u2013 like an implicit context \u2013 also shows up in Odin. In contrast with both Jai and Zig, Odin uses only minimal compile time evaluation and instead only relies on parametric polymorphism to ensure reuse. It also contains conveniences, like maps and arrays built into the language. For error handling it relies on Go style tuple returns. In Odin but not in C3 Different syntax and behaviour compared to C Ad hoc parametric polymorphism Tuple returns A rich built in set of types In C3 but not in Odin Familiar C syntax and behaviour Semantic macros Value methods Optional contracts Error handling support D D is a huge language. Where C++ is big, D provides all that C++ does and adds anything else you might think of. There is very little you can't do in D that isn't supported one way or the other. In D but not in C3 Objects and classes RAII Exceptions ... and almost any other feature in the universe ... In C3 but not in D Small language that provides what you need and not more","title":"Comparisons with other languages"},{"location":"compare/#language-comparisons","text":"An important question to answer is \"How does C3 compare to other similar programming languages?\". Here is an extremely brief (and not yet complete) overview.","title":"Language comparisons"},{"location":"compare/#c","text":"As C3 is an evolution of C, the languages are quite similar. C3 adds features, but also removes a few.","title":"C"},{"location":"compare/#in-c3-but-not-in-c","text":"Module system Integrated build system Generics Semantic Macros Error handling Defer Value methods Associated enum data Subtypes Optional contracts Built-in strings, maps, subarrays and vararrays","title":"In C3 but not in C"},{"location":"compare/#in-c-but-not-in-c3","text":"Qualified types ( const , volatile etc) Unsafe implicit conversions","title":"In C but not in C3"},{"location":"compare/#c_1","text":"C++ is a very complex object oriented \"almost superset\" of C. It tries to be everything to everyone, while squeezing this into a C syntax. The language is well known for its many pitfalls and quirky corners \u2013 as well as its long compile times. C3 is in many ways different from C++ in the same way that C is different from C++, but the semantic macro system and the generics close the gap in terms of writing reusable generic code. The module system and error handling is also very different from how C++ does things.","title":"C++"},{"location":"compare/#in-c-but-not-in-c3_1","text":"Objects and classes RAII Exceptions","title":"In C++ but not in C3"},{"location":"compare/#in-c3-but-not-in-c_1","text":"Module system (yet) Integrated build system Semantic macros Error handling Defer Associated enum data Built-in strings, maps, subarrays and vararrays","title":"In C3 but not in C++"},{"location":"compare/#rust","text":"Rust is a safe systems programming language. While not quite as complex as C++, it is still a feature rich programming language with semantic macros, traits and pattern matching to mention a few. Error handling is handled using Result and Optional which is similar to how C3 works. C3 compares to Rust much like C, although the presence of built in subarrays and strings reduces the places where C3 is unsafe. Rust provides arrays and strings, but they are not built in. Subarrays are the same as Rust's slices.","title":"Rust"},{"location":"compare/#in-rust-but-not-in-c3","text":"RAII Memory safety Safe union types with functions Different syntax from C Pattern matching Async built in","title":"In Rust but not in C3"},{"location":"compare/#in-c3-but-not-in-rust","text":"Same ease of programming as C Built-in strings, maps, vararrays Optional contracts Familiar C syntax and behaviour","title":"In C3 but not in Rust"},{"location":"compare/#zig","text":"Zig is a systems programming language with extensive compile time execution to enable polymorphic functions and parameterized types. It aims to be a C replacement. Compared to C3, Zig tries to be a completely new language in terms of syntax and feel. C3 uses macros to a modest degree where it is more pervasive in Zig, and does not depart from C in the same degree. Like Rust it features slices as a first class type. The standard library uses an explicit allocator to allow it to work with many different allocation strategies. Zig is a very ambitious project, aiming to support as many types of platforms as possible.","title":"Zig"},{"location":"compare/#in-zig-but-not-in-c3","text":"Pervasive compile time execution. Memory allocation failure is an error. Zig's compile time execution is the build system. Different syntax and behaviour compared to C. Structs define namespace. Async primitives built in.","title":"In Zig but not in C3"},{"location":"compare/#in-c3-but-not-in-zig","text":"Module system Integrated build system Built-in strings, maps, vararrays Optional contracts Familiar C syntax and behaviour","title":"In C3 but not in Zig"},{"location":"compare/#jai","text":"Jai is a programming language aimed at high performance game programming. It has an extensive compile time meta programming functionality, even to the point of being able to run programs at compile time. It also has compile time polymorphism, a powerful macro system and uses an implicit context system to switch allocation schemes.","title":"Jai"},{"location":"compare/#in-jai-but-not-in-c3","text":"Pervasive compile time execution. Jai's compile time execution is the build system. Different syntax and behaviour compared to C. More poweful macro system than C3. Implicit constructors","title":"In Jai but not in C3"},{"location":"compare/#in-c3-but-not-in-jai","text":"Module system Integrated build system Built-in strings and maps Optional contracts Familiar C syntax and behaviour Fairly small language","title":"In C3 but not in Jai"},{"location":"compare/#odin","text":"Odin is a language built for high performance but tries to remain a simple language to learn. Superficially the syntax shares much with Jai, and some of Jai's features things \u2013 like an implicit context \u2013 also shows up in Odin. In contrast with both Jai and Zig, Odin uses only minimal compile time evaluation and instead only relies on parametric polymorphism to ensure reuse. It also contains conveniences, like maps and arrays built into the language. For error handling it relies on Go style tuple returns.","title":"Odin"},{"location":"compare/#in-odin-but-not-in-c3","text":"Different syntax and behaviour compared to C Ad hoc parametric polymorphism Tuple returns A rich built in set of types","title":"In Odin but not in C3"},{"location":"compare/#in-c3-but-not-in-odin","text":"Familiar C syntax and behaviour Semantic macros Value methods Optional contracts Error handling support","title":"In C3 but not in Odin"},{"location":"compare/#d","text":"D is a huge language. Where C++ is big, D provides all that C++ does and adds anything else you might think of. There is very little you can't do in D that isn't supported one way or the other.","title":"D"},{"location":"compare/#in-d-but-not-in-c3","text":"Objects and classes RAII Exceptions ... and almost any other feature in the universe ...","title":"In D but not in C3"},{"location":"compare/#in-c3-but-not-in-d","text":"Small language that provides what you need and not more","title":"In C3 but not in D"},{"location":"contribute/","text":"The C3 language is still in its design phase , which means functionality and specification are subject to change. That also means that any contribution right now will have a big impact on the language. So if you find the project interesting, here's what you can do to help: Discuss the language on the C3 Discord https://discord.gg/qN76R87 Suggest improvements by filing an issue: https://github.com/c3lang/c3docs/issues/new Offer to work on the compiler being written here: https://github.com/c3lang/c3c","title":"Contribute"},{"location":"conversion/","text":"Conversions and promotions C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 widening float conversions do not require a cast narrowing conversions require a cast(*) widening conversions do not require a cast signed <-> unsigned conversions do not require a cast. In conditionals float to bool do not require a cast, any non zero float value considered true Implicit conversion to bool only occurs in conditionals or when the value is enclosed in () e.g. bool x = (1.0) or if (1.0) { ... } C3 uses two's complement arithmetic for all integer math. Target type The left hand side of an assignment, or the parameter type in a call is known as the target type the target type is used for implicit widening and inferring struct initialization. Implicit promotion Like C, C3 uses implicit promotion of integer and floating point variables: For any floating point type with a bit width smaller than 32 bits, widen to float . E.g. half -> float After 1, for any floatimg point type with a bit width smaller than the target type widen to the target type. For an integer type smaller than the minimum arithmetic width , promote the value to a signed integer of the minimum arithmetic width (this usually corresponds to a c int). E.g. uchar -> int After 3, for an integer type smaller than the target type , promote the value to an integer of the the same bit width. E.g. ulong = int + int -> ulong = long + long Maximum type The maximum type is a concept used when unifying two or more types. The algorithm follows: First perform implicit promotion. If both types are the same, the maximum type is this type. If one type is a floating point type, and the other is an integer type, the maximum type is the floating point type. E.g. int + float -> float . If both types are floating point types, the maximum type is the widest floating point type. E.g. float + double -> double . If both types are integer types with the same signedness, the maximum type is the widest integer type of the two. E.g. uint + ulong -> ulong . If both types are integer types with different signedness, the maximum type is a signed integer with the same bit width as the maximum integer type. ulong + int -> long If at least one side is a struct or a pointer to a struct with an inline directive on a member, check recursively check if the type of the inline member can be used to find a maximum type (see below under sub struct conversions) All other cases are errors. Sub struct conversions Substructs may be used in place of its parent structs in many cases. The rule is as follows: A substruct pointer may implicitly convert to a parent struct. A substruct value may be implicitly assigned to a variable with the parent struct type, This will truncate the value, copying only the parent part of the substruct. However, a substruct value cannot be assigned its parent struct. Substruct subarrays, vararrays and arrays can not be cast (implicitly or explicitly) to an array of the parent struct type. Pointer conversions Pointer conversion between types usually need explicit casts. The exception is void * which any type may implicitly convert to or from . Conversion rules from and to arrays are detailed under arrays Implicit narrowing Implicit narrowing is only allowed for floating point values and integer types. The following must hold: To narrow to a floating point type, all sub expressions must be integers or a floating point as narrow or more narrow than the target type. To narrow to an integer type, all sub expressions must be integers and as narrow or mor narrow than the target type, ignoring signedness. half h = 12.0; float f = 13.0; double d = 22.0; char x = 1; short y = -3; int z = 0xFFFFF; ulong w = -0xFFFFFFF; x = x + x; // => calculated as x = cast(cast(x as int) + cast(x as int), char); x = y + x; // => error w = x + y; // => calculated as w = cast(cast(cast(x as long) + cast(y as long) as ulong); h = x * h; // => calculated as h = cast(cast(x as float) * cast(h as float) as half); h = f + x; // => error d = f * h; // => calculated as d = cast(f as double) * cast(h as double); Binary conversions 1. Multiplication, division, remainder, subtraction / addition with both operands being numbers These operations are only valid for integer and float types. Resolve the operands, left to right, pushing down the target type. Find the maximum type of the two operands. Promote both operands to the resulting type. The resulting type of the expression is the resulting type. 2. Addition with left side being a pointer Resolve the left hand operand pushing down the target type. Resolve the right hand operand pushing down iptrdiff as the target type. If the rhs is not an integer, this is an error. If the rhs has a bit width that exceeds iptrdiff, this is an error. The result of the expression is the lhs type. 3. Subtraction with lhs pointer and rhs integer Resolve the left hand operand pushing down the target type. Resolve the right hand operand pushing down iptrdiff as the target type. If the right hand type has a bit width that exceeds iptrdiff, this is an error. The result of the expression is the left hand type. 4. Subtraction with both sides pointers Resolve the operands, left to right. If the either side is a void * , it is cast to the other type. If the types of the sides are different, this is an error. The result of the expression is iptrdiff. If this result exceeds the target width, this is an error. 6. Bit operations ^ & | These operations are only valid for integers and booleans. Resolve the operands, left to right, pushing down the target type. Find the maximum type of the two operands. Promote both operands to the resulting type. The result of the expression is the resulting type. 6. Shift operations << >> These operations are only valid for integers. Resolve the left operand pushing down the target type. Resolve the right operand without pushing down a target type. In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. The result of the expression is the lhs type. 7. Assignment operations += -= *= *= /= %= ^= |= &= Resolve the type of the left operand. Resolve the right operand pushing down the lhs type as target type The result of the expression is the lhs type. 8. Assignment shift >>= <<= Resolve both operands In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. The result of the expression is the lhs type. 9. && and || Resolve both operands. Insert bool cast of both operands. The type is bool. 10. <= == >= != Resolve the operands, left to right. Find the maximum type of the two operands. Promote both operands to the resulting type. The type is bool. Unary conversions 1. Bit negate Resolve the inner operand, pushing down the target type. If the inner type is not an integer this is an error. The type is the inner type. 2. Boolean not Resolve the inner operand. The type is bool. 3. Negation Resolve the inner operand, pushing down the target type. If the type inner type is not a number this is an error. If the inner type is an unsigned integer, cast it to the same signed type. The type is the type of the result from (3) 4. & and && Resolve the inner operand. The type is a pointer to the type of the inner operand. 5. * Resolve the inner operand. If the operand is not a pointer, or is a void * pointer, this is an error. The type is the pointee of the inner operand's type. Dereferencing 0 is implementation defined. 6. ++ and -- Resolve the inner operand. If the type is not a number, this is an error. The type is the same as the inner operand. Base expressions 1. Typed identifiers The type is that of the declaration. If the width of the type is less than that of the target type, widen to the target type. If the width of the type is greater than that of the target type, it is an error. 2. Constants and literals If it is untyped, the type is that of the smallest type that the constant can fit in. If the width of the type is less than that of the target type, widen to the target type. If the width of the type is greater than that of the target type, it is an error. Ternary and return type conversions In some cases an expression may have more than one branch and those branches have different types. A simple example is the ternary expressions. To resolve this, C3 does return type conversion . In essence this involves trying to implicitly cast each of the branches to the expected return type . C3 resolves the type in this manner: Is there an expected return type? Proceed error checking with the expected return type as the target type Is there no expected return type? Find the maximum type of all results and promote all results to the value. int a = foo(); short b = bar(); // This is using return type conversion: long c = baz() ? a : b; // The above will compile to: long c = baz() ? cast(a as long) : cast(c as long); char d = foobar(); // This is using maximum type because the ternary // is inside of an addition. baz() ? a : b; // The above will compile to: baz() ? a : cast(b as int);","title":"Conversions"},{"location":"conversion/#conversions-and-promotions","text":"C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 widening float conversions do not require a cast narrowing conversions require a cast(*) widening conversions do not require a cast signed <-> unsigned conversions do not require a cast. In conditionals float to bool do not require a cast, any non zero float value considered true Implicit conversion to bool only occurs in conditionals or when the value is enclosed in () e.g. bool x = (1.0) or if (1.0) { ... } C3 uses two's complement arithmetic for all integer math.","title":"Conversions and promotions"},{"location":"conversion/#target-type","text":"The left hand side of an assignment, or the parameter type in a call is known as the target type the target type is used for implicit widening and inferring struct initialization.","title":"Target type"},{"location":"conversion/#implicit-promotion","text":"Like C, C3 uses implicit promotion of integer and floating point variables: For any floating point type with a bit width smaller than 32 bits, widen to float . E.g. half -> float After 1, for any floatimg point type with a bit width smaller than the target type widen to the target type. For an integer type smaller than the minimum arithmetic width , promote the value to a signed integer of the minimum arithmetic width (this usually corresponds to a c int). E.g. uchar -> int After 3, for an integer type smaller than the target type , promote the value to an integer of the the same bit width. E.g. ulong = int + int -> ulong = long + long","title":"Implicit promotion"},{"location":"conversion/#maximum-type","text":"The maximum type is a concept used when unifying two or more types. The algorithm follows: First perform implicit promotion. If both types are the same, the maximum type is this type. If one type is a floating point type, and the other is an integer type, the maximum type is the floating point type. E.g. int + float -> float . If both types are floating point types, the maximum type is the widest floating point type. E.g. float + double -> double . If both types are integer types with the same signedness, the maximum type is the widest integer type of the two. E.g. uint + ulong -> ulong . If both types are integer types with different signedness, the maximum type is a signed integer with the same bit width as the maximum integer type. ulong + int -> long If at least one side is a struct or a pointer to a struct with an inline directive on a member, check recursively check if the type of the inline member can be used to find a maximum type (see below under sub struct conversions) All other cases are errors.","title":"Maximum type"},{"location":"conversion/#sub-struct-conversions","text":"Substructs may be used in place of its parent structs in many cases. The rule is as follows: A substruct pointer may implicitly convert to a parent struct. A substruct value may be implicitly assigned to a variable with the parent struct type, This will truncate the value, copying only the parent part of the substruct. However, a substruct value cannot be assigned its parent struct. Substruct subarrays, vararrays and arrays can not be cast (implicitly or explicitly) to an array of the parent struct type.","title":"Sub struct conversions"},{"location":"conversion/#pointer-conversions","text":"Pointer conversion between types usually need explicit casts. The exception is void * which any type may implicitly convert to or from . Conversion rules from and to arrays are detailed under arrays","title":"Pointer conversions"},{"location":"conversion/#implicit-narrowing","text":"Implicit narrowing is only allowed for floating point values and integer types. The following must hold: To narrow to a floating point type, all sub expressions must be integers or a floating point as narrow or more narrow than the target type. To narrow to an integer type, all sub expressions must be integers and as narrow or mor narrow than the target type, ignoring signedness. half h = 12.0; float f = 13.0; double d = 22.0; char x = 1; short y = -3; int z = 0xFFFFF; ulong w = -0xFFFFFFF; x = x + x; // => calculated as x = cast(cast(x as int) + cast(x as int), char); x = y + x; // => error w = x + y; // => calculated as w = cast(cast(cast(x as long) + cast(y as long) as ulong); h = x * h; // => calculated as h = cast(cast(x as float) * cast(h as float) as half); h = f + x; // => error d = f * h; // => calculated as d = cast(f as double) * cast(h as double);","title":"Implicit narrowing"},{"location":"conversion/#binary-conversions","text":"","title":"Binary conversions"},{"location":"conversion/#1-multiplication-division-remainder-subtraction-addition-with-both-operands-being-numbers","text":"These operations are only valid for integer and float types. Resolve the operands, left to right, pushing down the target type. Find the maximum type of the two operands. Promote both operands to the resulting type. The resulting type of the expression is the resulting type.","title":"1. Multiplication, division, remainder, subtraction / addition with both operands being numbers"},{"location":"conversion/#2-addition-with-left-side-being-a-pointer","text":"Resolve the left hand operand pushing down the target type. Resolve the right hand operand pushing down iptrdiff as the target type. If the rhs is not an integer, this is an error. If the rhs has a bit width that exceeds iptrdiff, this is an error. The result of the expression is the lhs type.","title":"2. Addition with left side being a pointer"},{"location":"conversion/#3-subtraction-with-lhs-pointer-and-rhs-integer","text":"Resolve the left hand operand pushing down the target type. Resolve the right hand operand pushing down iptrdiff as the target type. If the right hand type has a bit width that exceeds iptrdiff, this is an error. The result of the expression is the left hand type.","title":"3. Subtraction with lhs pointer and rhs integer"},{"location":"conversion/#4-subtraction-with-both-sides-pointers","text":"Resolve the operands, left to right. If the either side is a void * , it is cast to the other type. If the types of the sides are different, this is an error. The result of the expression is iptrdiff. If this result exceeds the target width, this is an error.","title":"4. Subtraction with both sides pointers"},{"location":"conversion/#6-bit-operations","text":"These operations are only valid for integers and booleans. Resolve the operands, left to right, pushing down the target type. Find the maximum type of the two operands. Promote both operands to the resulting type. The result of the expression is the resulting type.","title":"6. Bit operations ^ &amp; |"},{"location":"conversion/#6-shift-operations","text":"These operations are only valid for integers. Resolve the left operand pushing down the target type. Resolve the right operand without pushing down a target type. In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. The result of the expression is the lhs type.","title":"6. Shift operations &lt;&lt; &gt;&gt;"},{"location":"conversion/#7-assignment-operations-","text":"Resolve the type of the left operand. Resolve the right operand pushing down the lhs type as target type The result of the expression is the lhs type.","title":"7. Assignment operations += -= *= *= /= %= ^= |= &amp;="},{"location":"conversion/#8-assignment-shift","text":"Resolve both operands In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. The result of the expression is the lhs type.","title":"8. Assignment shift &gt;&gt;= &lt;&lt;="},{"location":"conversion/#9-and","text":"Resolve both operands. Insert bool cast of both operands. The type is bool.","title":"9. &amp;&amp; and ||"},{"location":"conversion/#10","text":"Resolve the operands, left to right. Find the maximum type of the two operands. Promote both operands to the resulting type. The type is bool.","title":"10. &lt;= == &gt;= !="},{"location":"conversion/#unary-conversions","text":"","title":"Unary conversions"},{"location":"conversion/#1-bit-negate","text":"Resolve the inner operand, pushing down the target type. If the inner type is not an integer this is an error. The type is the inner type.","title":"1. Bit negate"},{"location":"conversion/#2-boolean-not","text":"Resolve the inner operand. The type is bool.","title":"2. Boolean not"},{"location":"conversion/#3-negation","text":"Resolve the inner operand, pushing down the target type. If the type inner type is not a number this is an error. If the inner type is an unsigned integer, cast it to the same signed type. The type is the type of the result from (3)","title":"3. Negation"},{"location":"conversion/#4-and","text":"Resolve the inner operand. The type is a pointer to the type of the inner operand.","title":"4. &amp; and &amp;&amp;"},{"location":"conversion/#5","text":"Resolve the inner operand. If the operand is not a pointer, or is a void * pointer, this is an error. The type is the pointee of the inner operand's type. Dereferencing 0 is implementation defined.","title":"5. *"},{"location":"conversion/#6-and-","text":"Resolve the inner operand. If the type is not a number, this is an error. The type is the same as the inner operand.","title":"6. ++ and --"},{"location":"conversion/#base-expressions","text":"","title":"Base expressions"},{"location":"conversion/#1-typed-identifiers","text":"The type is that of the declaration. If the width of the type is less than that of the target type, widen to the target type. If the width of the type is greater than that of the target type, it is an error.","title":"1. Typed identifiers"},{"location":"conversion/#2-constants-and-literals","text":"If it is untyped, the type is that of the smallest type that the constant can fit in. If the width of the type is less than that of the target type, widen to the target type. If the width of the type is greater than that of the target type, it is an error.","title":"2. Constants and literals"},{"location":"conversion/#ternary-and-return-type-conversions","text":"In some cases an expression may have more than one branch and those branches have different types. A simple example is the ternary expressions. To resolve this, C3 does return type conversion . In essence this involves trying to implicitly cast each of the branches to the expected return type . C3 resolves the type in this manner: Is there an expected return type? Proceed error checking with the expected return type as the target type Is there no expected return type? Find the maximum type of all results and promote all results to the value. int a = foo(); short b = bar(); // This is using return type conversion: long c = baz() ? a : b; // The above will compile to: long c = baz() ? cast(a as long) : cast(c as long); char d = foobar(); // This is using maximum type because the ternary // is inside of an addition. baz() ? a : b; // The above will compile to: baz() ? a : cast(b as int);","title":"Ternary and return type conversions"},{"location":"errorhandling/","text":"Error Handling Unlike usual exception handling, errors in C3 build on normal returns. A function returning errors add a ! to the return type. In C3 this called a \"failable\" type. Error returns From C, a function returning an error value will appear as an out parameter \u2013 if the function returns a union of error codes \u2013 or as the return parameter if the function would a single enum.: C3 code: func int! getValue(); Corresponding C code: int getValue(Error *error); The int! here is the failable return type, which is a tagged union: it might hold either the error or an int. // Open a file, we will get a failable: // Either a File* or an error. File*! file = openFile(\"foo.txt\"); // We can extract the error using \"catch\" catch (err = file) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.name()); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.fullName()); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", cast(err as ulong)); return; } // We can also just execute of success: File*! file2 = openFile(\"bar.txt\"); // Only true if there is no error. if (file2) { // Inside here file2 is a regular File* } A function, method or macro call with one or more parameters will only execute if the failable has no error. This makes error returns composable. func int! fooMayError() { ... } func int mult(int i) { ... } func int! save(int i) { ... } func void test() ( int! i = fooMayError(); // \"mult\" is only called if \"fooMayError()\" // returns a non error result. int! j = mult(fooMayError()); int! k = save(mult(fooMAyError())); catch (err = k) { // The error may be from fooMayError // or save! } ) If a catch returns or jumps out of the current scope in a different way, then the variable becomes unwrapped to it's non-failable type. Some simple examples. Defining an error Errors may either be flat or contain additional data. error FileNotFoundError; error ParseError { int line; int col; } Returning an error Returning an error looks like a normal return but with the ! func void! findFile() { if (File.doesFileExist(\"foo.txt\")) return FileNotFoundError!; /* ... */ } Calling a function automatically returning any error The !! suffix will create an implicit return on error. func void! findFileAndTest() { findFile()!!; // Implictly: // catch (err = findFile()) return err!; } Catching errors Catching an error and returning will implicitly unwrap the checked variable. func void findFileAndNoErr() { File*! res = findFile(); catch (res) { printf(\"An error occurred!\\n\"); return; } // res is implicitly unwrapped here. // and have an effective type of File* here. } Only do if no error func void doSomethingToFile() { void! res = findFile(); try (res) { printf(\"I found the file\\n\"); } } Catching some errors func void! findFileAndParse2() { catch (err = findFileAndParse()) { case FileNotFoundError: printf(\"Error loading the file!\\n\"); default: return err; } } Default values A function returning an error may be followed by an else and an expression. The call then executes and returns the expression. func int testDefault() { return getIntNumberOrFail() else -1; } // The above is equivalent to: func int testDefault() { int! i = getIntNumberOrFail(); catch (i) return -1; return i; } Default jump The else can also be followed by a jump statement: return , break or continue . func int testBreak(int times) { int index; for (index = 0; i < times; i++) { callTest(index) else break; } if (index < times) { printf(\"Aborted test at index: %d\\n\", index); } return index; } Check for error or success try and catch without a statements returns a boolean true / false: func int testResult() { int! result = getValue(); if (try(result)) { printf(\"Success!\\n\"); } if (catch(result)) { printf(\"Failure\\n\"); } }","title":"Errors"},{"location":"errorhandling/#error-handling","text":"Unlike usual exception handling, errors in C3 build on normal returns. A function returning errors add a ! to the return type. In C3 this called a \"failable\" type.","title":"Error Handling"},{"location":"errorhandling/#error-returns","text":"From C, a function returning an error value will appear as an out parameter \u2013 if the function returns a union of error codes \u2013 or as the return parameter if the function would a single enum.: C3 code: func int! getValue(); Corresponding C code: int getValue(Error *error); The int! here is the failable return type, which is a tagged union: it might hold either the error or an int. // Open a file, we will get a failable: // Either a File* or an error. File*! file = openFile(\"foo.txt\"); // We can extract the error using \"catch\" catch (err = file) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.name()); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.fullName()); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", cast(err as ulong)); return; } // We can also just execute of success: File*! file2 = openFile(\"bar.txt\"); // Only true if there is no error. if (file2) { // Inside here file2 is a regular File* } A function, method or macro call with one or more parameters will only execute if the failable has no error. This makes error returns composable. func int! fooMayError() { ... } func int mult(int i) { ... } func int! save(int i) { ... } func void test() ( int! i = fooMayError(); // \"mult\" is only called if \"fooMayError()\" // returns a non error result. int! j = mult(fooMayError()); int! k = save(mult(fooMAyError())); catch (err = k) { // The error may be from fooMayError // or save! } ) If a catch returns or jumps out of the current scope in a different way, then the variable becomes unwrapped to it's non-failable type.","title":"Error returns"},{"location":"errorhandling/#some-simple-examples","text":"","title":"Some simple examples."},{"location":"errorhandling/#defining-an-error","text":"Errors may either be flat or contain additional data. error FileNotFoundError; error ParseError { int line; int col; }","title":"Defining an error"},{"location":"errorhandling/#returning-an-error","text":"Returning an error looks like a normal return but with the ! func void! findFile() { if (File.doesFileExist(\"foo.txt\")) return FileNotFoundError!; /* ... */ }","title":"Returning an error"},{"location":"errorhandling/#calling-a-function-automatically-returning-any-error","text":"The !! suffix will create an implicit return on error. func void! findFileAndTest() { findFile()!!; // Implictly: // catch (err = findFile()) return err!; }","title":"Calling a function automatically returning any error"},{"location":"errorhandling/#catching-errors","text":"Catching an error and returning will implicitly unwrap the checked variable. func void findFileAndNoErr() { File*! res = findFile(); catch (res) { printf(\"An error occurred!\\n\"); return; } // res is implicitly unwrapped here. // and have an effective type of File* here. }","title":"Catching errors"},{"location":"errorhandling/#only-do-if-no-error","text":"func void doSomethingToFile() { void! res = findFile(); try (res) { printf(\"I found the file\\n\"); } }","title":"Only do if no error"},{"location":"errorhandling/#catching-some-errors","text":"func void! findFileAndParse2() { catch (err = findFileAndParse()) { case FileNotFoundError: printf(\"Error loading the file!\\n\"); default: return err; } }","title":"Catching some errors"},{"location":"errorhandling/#default-values","text":"A function returning an error may be followed by an else and an expression. The call then executes and returns the expression. func int testDefault() { return getIntNumberOrFail() else -1; } // The above is equivalent to: func int testDefault() { int! i = getIntNumberOrFail(); catch (i) return -1; return i; }","title":"Default values"},{"location":"errorhandling/#default-jump","text":"The else can also be followed by a jump statement: return , break or continue . func int testBreak(int times) { int index; for (index = 0; i < times; i++) { callTest(index) else break; } if (index < times) { printf(\"Aborted test at index: %d\\n\", index); } return index; }","title":"Default jump"},{"location":"errorhandling/#check-for-error-or-success","text":"try and catch without a statements returns a boolean true / false: func int testResult() { int! result = getValue(); if (try(result)) { printf(\"Success!\\n\"); } if (catch(result)) { printf(\"Failure\\n\"); } }","title":"Check for error or success"},{"location":"examples/","text":"if-statement func void if_example(int a) { if (a > 0) { // .. } else { // .. } } for-loop func void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io::printf(\"%d\\n\", i); } // also equal for (;;) { // .. } } while-loop func void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } } enum + switch Switches have implicit break and scope. Use \"nextcase\" to implicitly fallthrough or use comma: enum Height : uint { LOW = 0, MEDIUM, HIGH, } func void demo_enum(Height h) { switch (h) { case LOW, MEDIUM: io::printf(\"Not high\"); // Implicit break. case HIGH: io::printf(\"High\"); } // This also works switch (h) { case LOW, case MEDIUM: io::printf(\"Not high\"); // Implicit break. case Height.HIGH: io::printf(\"High\"); } // Completely empty cases are not allowed. switch (h) { case LOW: break; // Explicit break required, since switches can't be empty. case MEDIUM: io::printf(\"Medium\"); case HIGH: break; } // special checking of switching on enum types switch (h) { case LOW, case MEDIUM, case HIGH, break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"nextcase\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case LOW: int a = 1; printf(\"A\\n\"); nextcase; case MEDIUM, int a = 2; printf(\"B\\n\"); nextcase; case HIGH, // a is not defined here printf(\"C\\n\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .all returns an array with all enums. enum State : uint { Start, Stop, } const uint lowest = State.min; const uint highest = State.max; State start = State.all[0]; defer Defer will be invoked on scope exit. func void test(int x) { defer printf(\"A\"); if (x == 1) return; { defer printf(\"B\"); if (x == 0) return; } printf(\"!\") } test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"B!A\" Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. func void! test(int x) { defer printf(\"A\"); defer catch printf(\"B\") defer catch (err) printf(\"%s\", e.message); if (x = 1) return FooError!; printf(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and returns a FooError struct types type Callback func int(char c); enum Status : int { IDLE, BUSY, DONE, } struct MyData { char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } } Function pointers module demo; type Callback func int(char* text, int value); // also shows function attribute func int my_callback(char* text, int value) @(unused_params) { return 0; } Callback cb = demo.my_callback; func void example_cb() { int result = cb(\"demo\", 123); // .. } Error handling Errors are sent as a result value, called a \"failable\": error DivisionByZero; func double divide(int a, int b) { if (b == 0) return DivisionByZero!; return cast(a as double) / cast(b as double); } // Rethrowing an error uses \"try\" func void! testMayError() { try divide(foo(), bar()); } func void testHandlingError() { // ratio has a failable type. double! ratio = divide(foo(), bar()); // Handle the error catch (err = ratio) { case DivisionByZero: io::printf(\"Division by zero\\n\"); return; default: io::printf(\"Unexpected error!\"); return; } // Flow typing makes \"ratio\" // have the type double here. printf(\"Ratio was %f\\n\", ratio); } import std::io; func void printFile(string filename) { string! file = io::load_file(filename); // The following function is not executed on error. io::printf(\"Loaded %s and got:\\n%s\", filename, file); catch (err = file) { case FileNotFoundError: printf(\"I could not find the file %s\\n\", filename); default: printf(\"Could not load %s: '%s'\", filename, error.message()); } } Pre and post conditions Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure testFoo < 10000, testFoo > 0 **/ func int testFoo(int foo) { return foo * 10; } /** * @param array : the array to test * @param length : length of the array * @require length > 0 **/ func int getLastElement(int? array, int length) { return array[length - 1]; } Macros Macro arguments may be immediately evaluated. macro foo(a, b) { return *a(b); } func int square(int x) { return x * x; } func int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion. macro foo($a, b, $c) { c = a(b) * b; } macro foo2($a) { return a * a; } func int square(int x) { return x * x; } func int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } func int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x : value to square * @require x * x >= 0 : \"cannot multiply\" **/ macro square(x) { return x * x; } func void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' } Value functions It's possible to namespace functions with a union, struct or enum type to enable \"dot syntax\" calls: struct Foo { int i; } func void Foo.next(Foo* this) { if (this) this.i++; } func void test() { Foo foo = { 2 }; foo.next(); foo.next(); // Prints 4 printf(\"%d\", foo.i); } Generic modules Generic modules implements a generic system. module stack(Type) struct Stack { Type[] elems; } func Stack.init(Stack* this) { this.elems = nil; } func void Stack.push(Stack* this, Type element) { this.elems.add(element); } func $A Stack.pop(Stack* this) { assert(this.elems.size > 0); this.elems.removeLast(); } func bool Stack.empty(Stack* this) { return this.elems.size == 0; } Testing it out: import stack; define Stack(int) as IntStack; define Stack(double) as DoubleStack; func void test() { IntStack stack; stack.init(); stack.push(1); stack.push(2); // Prints pop: 2 printf(\"pop: %d\\n\", stack.pop()) // Prints pop: 1 printf(\"pop: %d\\n\", stack.pop()) DoubleStack dstack; dstack.init(); dstack.push(2.3); dstack.push(3.141); dstack.push(1.1235) // Prints pop: 1.1235 printf(\"pop: %f\\n\", dstack.pop()) }","title":"Examples"},{"location":"examples/#if-statement","text":"func void if_example(int a) { if (a > 0) { // .. } else { // .. } }","title":"if-statement"},{"location":"examples/#for-loop","text":"func void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io::printf(\"%d\\n\", i); } // also equal for (;;) { // .. } }","title":"for-loop"},{"location":"examples/#while-loop","text":"func void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } }","title":"while-loop"},{"location":"examples/#enum-switch","text":"Switches have implicit break and scope. Use \"nextcase\" to implicitly fallthrough or use comma: enum Height : uint { LOW = 0, MEDIUM, HIGH, } func void demo_enum(Height h) { switch (h) { case LOW, MEDIUM: io::printf(\"Not high\"); // Implicit break. case HIGH: io::printf(\"High\"); } // This also works switch (h) { case LOW, case MEDIUM: io::printf(\"Not high\"); // Implicit break. case Height.HIGH: io::printf(\"High\"); } // Completely empty cases are not allowed. switch (h) { case LOW: break; // Explicit break required, since switches can't be empty. case MEDIUM: io::printf(\"Medium\"); case HIGH: break; } // special checking of switching on enum types switch (h) { case LOW, case MEDIUM, case HIGH, break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"nextcase\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case LOW: int a = 1; printf(\"A\\n\"); nextcase; case MEDIUM, int a = 2; printf(\"B\\n\"); nextcase; case HIGH, // a is not defined here printf(\"C\\n\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .all returns an array with all enums. enum State : uint { Start, Stop, } const uint lowest = State.min; const uint highest = State.max; State start = State.all[0];","title":"enum + switch"},{"location":"examples/#defer","text":"Defer will be invoked on scope exit. func void test(int x) { defer printf(\"A\"); if (x == 1) return; { defer printf(\"B\"); if (x == 0) return; } printf(\"!\") } test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"B!A\" Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. func void! test(int x) { defer printf(\"A\"); defer catch printf(\"B\") defer catch (err) printf(\"%s\", e.message); if (x = 1) return FooError!; printf(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and returns a FooError","title":"defer"},{"location":"examples/#struct-types","text":"type Callback func int(char c); enum Status : int { IDLE, BUSY, DONE, } struct MyData { char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } }","title":"struct types"},{"location":"examples/#function-pointers","text":"module demo; type Callback func int(char* text, int value); // also shows function attribute func int my_callback(char* text, int value) @(unused_params) { return 0; } Callback cb = demo.my_callback; func void example_cb() { int result = cb(\"demo\", 123); // .. }","title":"Function pointers"},{"location":"examples/#error-handling","text":"Errors are sent as a result value, called a \"failable\": error DivisionByZero; func double divide(int a, int b) { if (b == 0) return DivisionByZero!; return cast(a as double) / cast(b as double); } // Rethrowing an error uses \"try\" func void! testMayError() { try divide(foo(), bar()); } func void testHandlingError() { // ratio has a failable type. double! ratio = divide(foo(), bar()); // Handle the error catch (err = ratio) { case DivisionByZero: io::printf(\"Division by zero\\n\"); return; default: io::printf(\"Unexpected error!\"); return; } // Flow typing makes \"ratio\" // have the type double here. printf(\"Ratio was %f\\n\", ratio); } import std::io; func void printFile(string filename) { string! file = io::load_file(filename); // The following function is not executed on error. io::printf(\"Loaded %s and got:\\n%s\", filename, file); catch (err = file) { case FileNotFoundError: printf(\"I could not find the file %s\\n\", filename); default: printf(\"Could not load %s: '%s'\", filename, error.message()); } }","title":"Error handling"},{"location":"examples/#pre-and-post-conditions","text":"Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure testFoo < 10000, testFoo > 0 **/ func int testFoo(int foo) { return foo * 10; } /** * @param array : the array to test * @param length : length of the array * @require length > 0 **/ func int getLastElement(int? array, int length) { return array[length - 1]; }","title":"Pre and post conditions"},{"location":"examples/#macros","text":"Macro arguments may be immediately evaluated. macro foo(a, b) { return *a(b); } func int square(int x) { return x * x; } func int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion. macro foo($a, b, $c) { c = a(b) * b; } macro foo2($a) { return a * a; } func int square(int x) { return x * x; } func int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } func int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x : value to square * @require x * x >= 0 : \"cannot multiply\" **/ macro square(x) { return x * x; } func void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' }","title":"Macros"},{"location":"examples/#value-functions","text":"It's possible to namespace functions with a union, struct or enum type to enable \"dot syntax\" calls: struct Foo { int i; } func void Foo.next(Foo* this) { if (this) this.i++; } func void test() { Foo foo = { 2 }; foo.next(); foo.next(); // Prints 4 printf(\"%d\", foo.i); }","title":"Value functions"},{"location":"examples/#generic-modules","text":"Generic modules implements a generic system. module stack(Type) struct Stack { Type[] elems; } func Stack.init(Stack* this) { this.elems = nil; } func void Stack.push(Stack* this, Type element) { this.elems.add(element); } func $A Stack.pop(Stack* this) { assert(this.elems.size > 0); this.elems.removeLast(); } func bool Stack.empty(Stack* this) { return this.elems.size == 0; } Testing it out: import stack; define Stack(int) as IntStack; define Stack(double) as DoubleStack; func void test() { IntStack stack; stack.init(); stack.push(1); stack.push(2); // Prints pop: 2 printf(\"pop: %d\\n\", stack.pop()) // Prints pop: 1 printf(\"pop: %d\\n\", stack.pop()) DoubleStack dstack; dstack.init(); dstack.push(2.3); dstack.push(3.141); dstack.push(1.1235) // Prints pop: 1.1235 printf(\"pop: %f\\n\", dstack.pop()) }","title":"Generic modules"},{"location":"expressions/","text":"Expressions Expressions work like in C. Compound literals C3 has C's compound literals, but unlike C's cast style syntax (MyStruct) { 1, 2 } , it uses a slightly different syntax, similar to C++: MyStruct({ 1, 2 }) . struct Foo { int a; double b; } ... func void test(Foo x) { ... } test(Foo({ 1, 2.0 })); Literals are allocated on the stack, and similarly it's possible to allocate fixed size integers: // By value func void test1(int[3] x) { ... } // By slice func void test2(int[] y) { ... } // By reference func void test2(int[3]* z) { ... } test1(int[3]({ 1, 2, 3 })); test2(&&int[3]({ 1, 2, 3 })); test3(&&int[3]({ 1, 2, 3 })); Array literals Syntax and implementation under consideration! Arrays can be initialized using compound literals, but there is also a special format for array initialization using [] . In this case, the type is inferred. It allows uniform initialization of all types of arrays: int[*] x = [1, 2, 3]; // Variable array allocated on the stack int[3] y = [1, 2, 3]; // Fixed array allocated on the stack int[] z = [1, 2, 3]; // Slice pointing at literal allocated on the stack It offers some convenience when calling functions taking arrays: func void test1(int[3] x) { ... } func void test2(int[] y) { ... } func void test2(int[3]* z) { ... } test1([ 1, 2, 3 ]); test2([ 1, 2, 3 ]); test3([ 1, 2, 3 ]); Associative array literals Syntax and implementation under consideration! Associative arrays are mappings between keys and values: IntStringMap x = { \"a\": 2, \"b\": { \"3\" : \"foo\" } }; To use an associative array, the struct needs to define the following method macros: @map_init() @map_init_add() . In the example above, the actual code is compiled to: IntStringMap x; x.@map_init(); x.@map_init_add(\"a\", 2); IntStringMap _temp; _temp.@map_init(); _temp.@map_init_add(\"3\", \"foo\"); x.@map_init_add(\"b\", _temp);","title":"Expressions"},{"location":"expressions/#expressions","text":"Expressions work like in C.","title":"Expressions"},{"location":"expressions/#compound-literals","text":"C3 has C's compound literals, but unlike C's cast style syntax (MyStruct) { 1, 2 } , it uses a slightly different syntax, similar to C++: MyStruct({ 1, 2 }) . struct Foo { int a; double b; } ... func void test(Foo x) { ... } test(Foo({ 1, 2.0 })); Literals are allocated on the stack, and similarly it's possible to allocate fixed size integers: // By value func void test1(int[3] x) { ... } // By slice func void test2(int[] y) { ... } // By reference func void test2(int[3]* z) { ... } test1(int[3]({ 1, 2, 3 })); test2(&&int[3]({ 1, 2, 3 })); test3(&&int[3]({ 1, 2, 3 }));","title":"Compound literals"},{"location":"expressions/#array-literals","text":"Syntax and implementation under consideration! Arrays can be initialized using compound literals, but there is also a special format for array initialization using [] . In this case, the type is inferred. It allows uniform initialization of all types of arrays: int[*] x = [1, 2, 3]; // Variable array allocated on the stack int[3] y = [1, 2, 3]; // Fixed array allocated on the stack int[] z = [1, 2, 3]; // Slice pointing at literal allocated on the stack It offers some convenience when calling functions taking arrays: func void test1(int[3] x) { ... } func void test2(int[] y) { ... } func void test2(int[3]* z) { ... } test1([ 1, 2, 3 ]); test2([ 1, 2, 3 ]); test3([ 1, 2, 3 ]);","title":"Array literals"},{"location":"expressions/#associative-array-literals","text":"Syntax and implementation under consideration! Associative arrays are mappings between keys and values: IntStringMap x = { \"a\": 2, \"b\": { \"3\" : \"foo\" } }; To use an associative array, the struct needs to define the following method macros: @map_init() @map_init_add() . In the example above, the actual code is compiled to: IntStringMap x; x.@map_init(); x.@map_init_add(\"a\", 2); IntStringMap _temp; _temp.@map_init(); _temp.@map_init_add(\"3\", \"foo\"); x.@map_init_add(\"b\", _temp);","title":"Associative array literals"},{"location":"firstproject/","text":"Your First Project Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import std::io; public func int main(int argc, char*[] argv) { io::println(\"Hello World!\"); return 0; } Now in the terminal type: $ c3c hello_world.c3 $ ./hello_world.a Hello World $ A real project Once you go beyond simple files, you want to create a real project. Do so by entering c3c -new hello_world . You will get the following structure: $ c3c -new hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"Your first project"},{"location":"firstproject/#your-first-project","text":"Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import std::io; public func int main(int argc, char*[] argv) { io::println(\"Hello World!\"); return 0; } Now in the terminal type: $ c3c hello_world.c3 $ ./hello_world.a Hello World $","title":"Your First Project"},{"location":"firstproject/#a-real-project","text":"Once you go beyond simple files, you want to create a real project. Do so by entering c3c -new hello_world . You will get the following structure: $ c3c -new hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"A real project"},{"location":"functions/","text":"Functions C3 has both regular functions and member functions. Member functions are name spaced using a type name, and allows invocations using the dot syntax. Regular functions Regular functions looks similar to C. It starts with the keyword func , followed by the conventional C declaration of <return type> <name>(<parameter list>) . C3 adds a throws declaration, that will declare that the function might return an error instead of its usual return value. func void test(int times) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i); } } Function arguments C3 allows use of default arguments as well as named arguments. func int testWithDefault(int foo = 1) { return foo; } func void test() { testWithDefault(); testWithDefault(100); } Named arguments func void testNamed(int times, double data) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(.data = 3.0, .times = 1) testNamed(3, 4.0); } Named arguments with defaults: func void testNamedDefault(int times = 1, double data = 3.0, bool dummy = false) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(.data = 3.0) // Mixing named and defaults: testNamed(3, .dummy = false); // Mixing named and defaults leaving out initial values: testNamed(,,false, .times = 1); } Varargs There are two types of varargs: the usual C-style untyped varargs and typed varargs. Untyped varargs will always send arguments as-is, whereas typed arguments will do normal conversions. func void varargsUntyped(string foo, ...) { /* ... */ } func void varargsTyped(string bar, int... ints) { /* ... */ } func void test() { varargsUntyped(\"Hello\", 2, 1.0, cast(1 as byte), \"Test\"); varargsTyped(\"Test\", 2, cast(1 as byte)); // The second parameter will be converted to an int implicitly. } Functions and failables The return parameter may be a failable \u2013 a type suffixed by ! indicating that this function might either return a regular value or an error. The below example might throw errors from both the SomeError error domain as well as the OtherError error domain. func double! testError() throws { double val = random_value();_ if (val >= 0.2) return BadJossError!; if (val > 0.5) return BadLuckError!; return val; } A function that is passed a failable value will only conditionally execute if and only if all failable values evaluate to true, otherwise the first error is returned. func void test() { // The following line is either prints a value less than 0.2 // or does not print at all: printf(\"%d\\n\", testError()); double x = (testError() + testError()) else 100; // This prints either a value less than 0.4 or 100: printf(\"%d\\n\", x); } This allows us to chain functions: func void printInputWithExplicitChecks() { string! line = readLine(); if (line) { // line is a regular \"string\" here. int! val = atoi(line); if (val) { printf(\"You typed the number %d\\n\", val); return; } } printf(\"You didn't type an integer :(\\n\"); } func void printInputWithChaining() { if (int val = atoi(readLine())) { printf(\"You typed the number %d\\n\", val); return; } printf(\"You didn't type an integer :(\\n\"); } Methods Methods look exactly like functions, but are prefixed with the struct, union or enum name and is (usually) invoked using dot syntax: struct Point { int x; int y; } func void Point.add(Point* p, int x) { p.x = x; } func void example() { Point p = { 1, 2 } // with struct-functions p.add(10); // Also callable as: Point.add(&p, 10); } If a method does not take the type as the first parameter, then it may only be invoked qualified with the type name: func Point* Point.new(int x, int y) { Point* p = malloc(@sizeof(Point)); p.x = x; p.y = y; return p; } func void example2() { Point* p = Point.new(1, 2); } Struct and unions will always take pointer, whereas enums take the enum value. enum State { STOPPED, RUNNING } func bool State.mayOpen(State state) { switch (state) { case State.STOPPED: return true; case State.RUNNING: return false; } } Restrictions on methods Methods on a struct/union may not have the same name as a member. Methods only works on distinct, struct, union and enum types. When taking a function pointer of a method, use the full name. Using sub types, overlapping function names will be shadowed. Pre and post conditions C3's error handling is not intended to use errors to signal invalid data or to check invariants and post conditions. Instead C3's approach is to add annotations to the function, that conditionally will be compiled into asserts. As an example, the following code: /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure return < 10000, return > 0 **/ func int testFoo(int foo) { return foo * 10; } Will in debug builds be compiled into something like this: func int testFoo(int foo) { assert(foo > 0); assert(foo < 1000); int _return = foo * 10; assert(_return < 10000); assert(_return > 0); return _return; } The compiler is allowed to use the pre and post conditions for optimizations. For example this: func int testExample(int bar) { if (testFoo(bar) == 0) return -1; return 1; } May be optimized to: func int testExample(int bar) { return 1; } In this case the compiler can look at the post condition of result > 0 to determine that testFoo(foo) == 0 must always be false. Looking closely at this code, we not that nothing guarantees that bar is not violating the preconditions. In debug builds this will usually be checked in runtime, but a sufficiently smart compiler will warn about the lack of checks on bar . Execution of code violating pre and post conditions has undefined behaviour.","title":"Functions"},{"location":"functions/#functions","text":"C3 has both regular functions and member functions. Member functions are name spaced using a type name, and allows invocations using the dot syntax.","title":"Functions"},{"location":"functions/#regular-functions","text":"Regular functions looks similar to C. It starts with the keyword func , followed by the conventional C declaration of <return type> <name>(<parameter list>) . C3 adds a throws declaration, that will declare that the function might return an error instead of its usual return value. func void test(int times) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i); } }","title":"Regular functions"},{"location":"functions/#function-arguments","text":"C3 allows use of default arguments as well as named arguments. func int testWithDefault(int foo = 1) { return foo; } func void test() { testWithDefault(); testWithDefault(100); } Named arguments func void testNamed(int times, double data) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(.data = 3.0, .times = 1) testNamed(3, 4.0); } Named arguments with defaults: func void testNamedDefault(int times = 1, double data = 3.0, bool dummy = false) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(.data = 3.0) // Mixing named and defaults: testNamed(3, .dummy = false); // Mixing named and defaults leaving out initial values: testNamed(,,false, .times = 1); }","title":"Function arguments"},{"location":"functions/#varargs","text":"There are two types of varargs: the usual C-style untyped varargs and typed varargs. Untyped varargs will always send arguments as-is, whereas typed arguments will do normal conversions. func void varargsUntyped(string foo, ...) { /* ... */ } func void varargsTyped(string bar, int... ints) { /* ... */ } func void test() { varargsUntyped(\"Hello\", 2, 1.0, cast(1 as byte), \"Test\"); varargsTyped(\"Test\", 2, cast(1 as byte)); // The second parameter will be converted to an int implicitly. }","title":"Varargs"},{"location":"functions/#functions-and-failables","text":"The return parameter may be a failable \u2013 a type suffixed by ! indicating that this function might either return a regular value or an error. The below example might throw errors from both the SomeError error domain as well as the OtherError error domain. func double! testError() throws { double val = random_value();_ if (val >= 0.2) return BadJossError!; if (val > 0.5) return BadLuckError!; return val; } A function that is passed a failable value will only conditionally execute if and only if all failable values evaluate to true, otherwise the first error is returned. func void test() { // The following line is either prints a value less than 0.2 // or does not print at all: printf(\"%d\\n\", testError()); double x = (testError() + testError()) else 100; // This prints either a value less than 0.4 or 100: printf(\"%d\\n\", x); } This allows us to chain functions: func void printInputWithExplicitChecks() { string! line = readLine(); if (line) { // line is a regular \"string\" here. int! val = atoi(line); if (val) { printf(\"You typed the number %d\\n\", val); return; } } printf(\"You didn't type an integer :(\\n\"); } func void printInputWithChaining() { if (int val = atoi(readLine())) { printf(\"You typed the number %d\\n\", val); return; } printf(\"You didn't type an integer :(\\n\"); }","title":"Functions and failables"},{"location":"functions/#methods","text":"Methods look exactly like functions, but are prefixed with the struct, union or enum name and is (usually) invoked using dot syntax: struct Point { int x; int y; } func void Point.add(Point* p, int x) { p.x = x; } func void example() { Point p = { 1, 2 } // with struct-functions p.add(10); // Also callable as: Point.add(&p, 10); } If a method does not take the type as the first parameter, then it may only be invoked qualified with the type name: func Point* Point.new(int x, int y) { Point* p = malloc(@sizeof(Point)); p.x = x; p.y = y; return p; } func void example2() { Point* p = Point.new(1, 2); } Struct and unions will always take pointer, whereas enums take the enum value. enum State { STOPPED, RUNNING } func bool State.mayOpen(State state) { switch (state) { case State.STOPPED: return true; case State.RUNNING: return false; } }","title":"Methods"},{"location":"functions/#restrictions-on-methods","text":"Methods on a struct/union may not have the same name as a member. Methods only works on distinct, struct, union and enum types. When taking a function pointer of a method, use the full name. Using sub types, overlapping function names will be shadowed.","title":"Restrictions on methods"},{"location":"functions/#pre-and-post-conditions","text":"C3's error handling is not intended to use errors to signal invalid data or to check invariants and post conditions. Instead C3's approach is to add annotations to the function, that conditionally will be compiled into asserts. As an example, the following code: /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure return < 10000, return > 0 **/ func int testFoo(int foo) { return foo * 10; } Will in debug builds be compiled into something like this: func int testFoo(int foo) { assert(foo > 0); assert(foo < 1000); int _return = foo * 10; assert(_return < 10000); assert(_return > 0); return _return; } The compiler is allowed to use the pre and post conditions for optimizations. For example this: func int testExample(int bar) { if (testFoo(bar) == 0) return -1; return 1; } May be optimized to: func int testExample(int bar) { return 1; } In this case the compiler can look at the post condition of result > 0 to determine that testFoo(foo) == 0 must always be false. Looking closely at this code, we not that nothing guarantees that bar is not violating the preconditions. In debug builds this will usually be checked in runtime, but a sufficiently smart compiler will warn about the lack of checks on bar . Execution of code violating pre and post conditions has undefined behaviour.","title":"Pre and post conditions"},{"location":"generics/","text":"Generics Generic functionality is mostly provided by macros and generic modules. Bridging the gap is generic functions, that allow a limited for of overloading. Generic functions Generic functions is a specialized type of macros. They allow overloading using a common symbol, just like C11's _Generic : generic abs(x) { case double: return fabs(x); case int: return abs(x); // Redefining abs(!) } Unlike a regular macro, a generic function is not invoked with @. It may also be extended by other packages / files: // File 1 module foo; generic abs(x) { case double: return fabs(x); case int: return abs(x); } // File 2 module bar; generic foo::abs(x) { case long: return absl(x); case int: // Compile time error, already defined return abs(x); } It is possible to dispatch on multiple arguments: module foo; generic add(x, y) { case double, double: return x + y; case int, double: return (double)x + y; } Generics can also be used for overloading operators: generic operator_add(x, y) { case vector3, vector3: return vector_add(x, y); } generic operator_index(x, y) { case DynArray, int: return x.get(y); // Enables foo[12] } generic operator_index_assign(x, y, z) { case DynArray, int: return x.set(y, z); // Enables foo[12] = 2 } Note that generics is actually a macro expansion. Consequently this is possible: generic weird_fun(x) { case int: printf(\"%d\", x); case Foo: while (foo.bar > 0) { foo.bar--; printf(\"Hi\"); } } void func test() { Foo foo; weird_fun(2); // Prints \"2\" foo.bar = 4; wierd_fun(foo); // Prints \"HiHiHiHi\" } Shorthand There is also a shorthand for declaring generics that only match a single type \u2013 it's done by declaring the types directly in the header: generic add(double x, double y) { return x + y; } Generic modules Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: module vector (A, B, C); // A, B, C are generic parameters. The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test (A, B); struct Foo { A a; } func C test(B b, Foo *foo) { return a + b; } Including a generic module works as usual, but to use a type, it must be defined before use. import foo_test; define Foo(float, double) as FooFloat; define foo_test::test(float, double) as testFloat; ... FooFloat f; ... testFloat(1.0, f); Just like for macros, optional constraints may be added to improve compile errors: /** * @require c = a + b */ module vector (A, B, C); /* .. code * ../ import vector(Bar, f32, i32) as gen_test; // This would give the error // --> Illegal arguments for generic module vector, breaks requirement 'Bar' = 'f32' + 'i32'","title":"Generics"},{"location":"generics/#generics","text":"Generic functionality is mostly provided by macros and generic modules. Bridging the gap is generic functions, that allow a limited for of overloading.","title":"Generics"},{"location":"generics/#generic-functions","text":"Generic functions is a specialized type of macros. They allow overloading using a common symbol, just like C11's _Generic : generic abs(x) { case double: return fabs(x); case int: return abs(x); // Redefining abs(!) } Unlike a regular macro, a generic function is not invoked with @. It may also be extended by other packages / files: // File 1 module foo; generic abs(x) { case double: return fabs(x); case int: return abs(x); } // File 2 module bar; generic foo::abs(x) { case long: return absl(x); case int: // Compile time error, already defined return abs(x); } It is possible to dispatch on multiple arguments: module foo; generic add(x, y) { case double, double: return x + y; case int, double: return (double)x + y; } Generics can also be used for overloading operators: generic operator_add(x, y) { case vector3, vector3: return vector_add(x, y); } generic operator_index(x, y) { case DynArray, int: return x.get(y); // Enables foo[12] } generic operator_index_assign(x, y, z) { case DynArray, int: return x.set(y, z); // Enables foo[12] = 2 } Note that generics is actually a macro expansion. Consequently this is possible: generic weird_fun(x) { case int: printf(\"%d\", x); case Foo: while (foo.bar > 0) { foo.bar--; printf(\"Hi\"); } } void func test() { Foo foo; weird_fun(2); // Prints \"2\" foo.bar = 4; wierd_fun(foo); // Prints \"HiHiHiHi\" }","title":"Generic functions"},{"location":"generics/#shorthand","text":"There is also a shorthand for declaring generics that only match a single type \u2013 it's done by declaring the types directly in the header: generic add(double x, double y) { return x + y; }","title":"Shorthand"},{"location":"generics/#generic-modules","text":"Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: module vector (A, B, C); // A, B, C are generic parameters. The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test (A, B); struct Foo { A a; } func C test(B b, Foo *foo) { return a + b; } Including a generic module works as usual, but to use a type, it must be defined before use. import foo_test; define Foo(float, double) as FooFloat; define foo_test::test(float, double) as testFloat; ... FooFloat f; ... testFloat(1.0, f); Just like for macros, optional constraints may be added to improve compile errors: /** * @require c = a + b */ module vector (A, B, C); /* .. code * ../ import vector(Bar, f32, i32) as gen_test; // This would give the error // --> Illegal arguments for generic module vector, breaks requirement 'Bar' = 'f32' + 'i32'","title":"Generic modules"},{"location":"ideas/","text":"Ideas WARNING Unfinished ideas / brain dumps Simpler casts Use the type-call style casts: int i = int(2.0); Foo* f = Foo*(getBar()); Or explore some more exotic casts: int i = 2.0->int; Foo* f = getBar()->Foo*; int i = 2.0 as int; Foo* f = getBar() as Foo*; int i = 2.0::int; Foo* f = getBar()::Foo*; Static initializers Allow initialization of globals before main is invoked. Introduce a general static block. module foo; int x; static { x = rand(); } int y = rand(); func int randomCalculation() { return rand(); } Sematic roughly work like in Java, except that all know globals are initialized before main, as opposed to when the class is invoked. The order of initialization is unspecified. Module versioning Follow Go Modules: Build file contains required library versions: e.g. 2.5.7 First number is major version number and is considered incompatible (basically a different module completely) Dependency resolution per major library version is done by picking the minimal version. E.g. module Foo requires Bar 1.5+ and module Baz requires 1.3+. Our module using Bar and Baz will resolve the minimal version to 1.3. This is the version that will be used. Note that if Foo used 2.5+, then both Bar 2.5 and 1.3 would be required. Polymorphic functions It would theoretically be possible to replace the generics with ad hoc polymorphic functions. module adding(TypeA, TypeB, TypeC) func TypeC add_module(TypeA a, TypeB b) { return a + b; } generic func $c add_poly($a, $b) { return $a + $b; } Usage: // Module: import adding; define add_module(int, float, float) as int_float_add; define add_module(int, double, double) as int_double_add; func void test() { float f = int_float_add(2, 3.0) float f2 = add_poly(2, 3.0); double d = int_double_add(2, 3.0); double d2 = add_poly(2, 3.0); } Allow narrowing conversions for floats Narrowing conversions for double -> float are common and might not be sufficiently important to do explicitly. Tests built in Unit tests built in as an integral part of the language like D. Allow variable alias Possibility to alias a variable name. Attribute to ensure alignment @assertalign works as GCCs warn_if_not_aligned. On non packed structs, this will prevent compilation if padding is inserted in front of the member. On a packed struct, it will prevent compilation if it is not aligned. Binary include The ability to include a binary file during compile time. An additional embed-path gives search dirs. byte[] file = @binary_include(\"foo.dat\"); Limiting embed to x bytes: byte[] file = @binary_include(\"/dev/urandomg\", 16); Compile time run-include The ability to run a piece of code at compile time and include the result in the code. @run_include(\"foo.sh\", $some_param, \"-x\", $another_param); Type functions Since static methods are out, it's natural to allow static values from the type, e.g. struct Foo { ... } ... Foo *foo = malloc(Foo.sizeof) There are a lot of type functions possible: sizeof offsetof name description elements There doesn't seem to be a need for applying this to non base type, but it should probably be allowed, e.g. (Foo*).sizeof Macro text interpolation For certain cases, pure text interpolation might be needed. Within macros, any text within `` can be evaluated and parsed. macro void @foo($x, #f) { `#f $x * $x`; } func void test() { int x = 1; @foo(4, \"x +=\"); // Expands to -> // x += 4 * 4; } Another example, showing the difference between #var and `#var` : macro void @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { int x = 1; @foo2(x); // Expands to -> // printf(\"%s was %d\\n\", \"x\", x); } Compile time string functions In order to facilitate certain types of macros, the following macros are built in: @strToUpper(#f) Convert string to upper case. @strToLower(#f) Convert string to lower case. @strToVarName(#f, #space) Convert string to camel case from a space-based name scheme. @strToTypeName(#f, #space) Convert string to title case from a space-based name scheme. @strFromName(#f, #space) Convert title case or lower camel case to a space based scheme. @strReplace(#str, #pattern, #replacement, #count) Replace a string with another. @subString(#str, #start, #length) Return a substring of a compile time string. @strFind(#str, #stringToFind) Find a substring in a compile time string. @strHash(#str) Return the FNV1a hash of a string. @strLen(#str) Return a compile time length of a string. @stringify(#str) Escapes a string so it becomes a valid string. Implicit \"this\" in method functions struct Foo { int i; } func Foo.next(Foo*) { i++; } Managed pointer variables Managed pointer variables are introduced using @ after the type, rather than * e.g. Foo@ f . A managed variable will automatically call the type's release member function on its value when the variable goes out of scope or is reassigned. If there is no release function, then free is called. Foo@ f = Foo.alloc(); // * -> @ no retain. Foo@ b = f; // => f.retain(); b = f; f = nil; // => f.release(); f = nil; Any managed variable that goes out of the scope will automatically invoke release , as if the pointer was set to nil . { Foo@ b = Foo.alloc(); } // Automatic invocation of b.release(); In order to return a managed pointer that can be used as a temporary, it's often convenient to mark the return value as managed. func Foo@ createFoo() { return Foo.alloc(); } createFoo(); // Implicitly introduces a deferred release. If we assign a managed pointer to a variable, the release/retain is elided // The following becomes f1 = createFoo() - no deferred release or retains. Foo@ f1 = createFoo(); It's possible to manually manage a managed pointer: Foo* f2 = createFoo().retain(); f2.release(); // Required to prevent leaks. A managed pointer may safely assigned to a regular pointer as long as it's not retained outside of the scope. { Foo* f3 = createFoo(); printf(\"%d\", f3.someValue); // Safe, since f3 isn't actually used after the scope. } Foo* unsafeFoo; { unsafeFoo = createFoo(); } // <- access to unsafeFoo at this point will likely break things. Managed variables not pointers Managed variables should not be confused with automatic reference counting and similar. It is not possible to \u2013 for example \u2013 to make a struct member a \"managed\" pointer. It is strictly limited to variables and return values. C interop Steps: Add group header in the builds: [c-libs] Add the search paths: cpath = [\"/xxx/foo/ \", \"/bar/headers/ \"] Add each library: [[lib]] [c-libs] cpath = [\"/xxx/foo/**\", \"/bar/headers/**\"] [[lib]] module = \"windows\" header = \"windows.h\" [[lib]] module = \"stdlib\" header = \"stdlib.h\" Unsorted Halloc Hierarchal memory allocation http://swapped.cc/#!/halloc support it? Tagged any A tagged pointer union type for any possible type. Extended \"case\" Switch as \"if-else\" switch (x) { case x > 200: return 0; case x < 2: small_x_warning(); case 0: .... case x > y && a < 1: ... } Case as a range switch (x) { case 1 .. 10: ... case 11 .. 100: ... } Easy to get properties Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports Associate properties to an enum enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" } Tagged unions tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And another... struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { struct square { int side; } struct rectangle { int length; int height; } struct circle { int radius; } } } And yet another... struct Shape { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; } Removal of the volatile type qualifier The volatile type qualifier is replaced by volatile stores and loads. \\\\ C volatile void test() { volatile int v = 0; for (int i = 0; i < 100; i++) { // Usually these two would be optimized away, // but volatile will ensure it is executed. v = 1; int x = v; } } \\\\ C3 func void test() { int v = 0; for (int i = 0; i < 100; i++) { volatile(v) = 1; int x = volatile(v); } } Interfaces func void Foo.renderPage(Foo* foo, Page* info) { /* ... */ } interface Renderer { void renderPage(virtual Renderer* renderer, Page* info); } func void render(virtual Renderer* renderer, Page* info) { if (!rendered) return; renderer->renderPage(info); } func void test() { Foo* foo = getFoo(); Page* page = getPage(); // Option 1 Renderer.render(foo, page); // Option 2 virtual Renderer* renderer = foo; renderer.render(page); } // C equivalent: // struct RendererVtable { // void (*renderPage)(void*, Page*); // }; // struct RendererRef { // void* ref; RendererVTable *vtable; // }; // void Renderer__render(struct RendererRef renderer, Page *info) { // if (renderer.ref == null) return; // renderer.vtable->renderPage(renderer.ref, info); // } // // void test() { // Foo *foo = getFoo(); // Page *page = getPage(); // // static RenderVTable FooRendererVTable = { &Foo__renderPage }; // Renderer__render(struct RendererRef { foo, &FooRendererVTable }, page); // // struct RendererRef renderer = { foo, &FooRendererVTable }; // Renderer__render(renderer, page); // } Built in maps Same reasoning as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = try map[0]; // Requires a try // Retrive or use default int i = try map[12] else -1; // Extend a map: func bool int[int].remove_if_negative(int[int] *map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int *map, int32_t index); Built in string type Strings are built-in, refcounted(?) null-terminated character arrays. Take a long hard look at memory management (here too) string = \"Hello\"; string += \" World\"; char* data = &string; // Taking a pointer to the string, which may later be invalid. Built in managed pointers Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check. Ideas around macros Just some previous thoughts and ideas I've considered. Many of those actually go against the current design. Compile time variables This is a variant of what already exists in C, but in a syntactically more friendly way. For example this would be ok: macro swap(a, b) { $x = typeof(a); static_assert(typeof(b) == $x); $x temp = a; a = b; b = a; } The example above is a bit contrived as in the above example we could simply have: macro swap(a, b) { static_assert(typeof(b) == typeof(b)); typeof(a) temp = a; a = b; b = a; } But still, it serves as an example on how to use it. Capturing trailing compound statement public macro foreach(thelist, @body(Element *) ) { Element* iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Or a version that is more flexible: public macro foreach(thelist, @body(typeof(thelist.first)) ) { typeof(thelist.first) iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } // Usage: foreach(list, Element *i) // <- Note type declaration! { i.print(); } Since type is going to appear very often, we could make a shortcut for it, like $@ as prefix meaning \"typeof\". We then get public macro foreach(thelist, @body($@thelist.first)) { $@thelist.first iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Possibly one could even write the code like this: public macro foreach(thelist, @body($element_type) ) { $element_type iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } In this case $element_type works like \"auto\", but is also assigned the type, which then can be referred to in the signature. Stepwise from C macros into C3 macros #define ADD_TO(x, y) { x += y; } ADD_TO(x, 1) The { } introduces a multiline macro that does not need explicit linebreaks. Now, add the \"$\" symbol to introduce hygienic temporaries: #define SWAP(x, y) { typeof(x) $tmp = x; x = y; y = $tmp; } Here $tmp will actually be replaced by __<macro>_<variable_name>_<instance> when translating to C, so __SWAP_tmp_1 , __SWAP_tmp_2 etc. We then introduce the syntax macros using: macro swap(&a, &b) { typeof(a) $tmp = a; b = a; a = $tmp; } (Note the different use of $ here as compared to previous macro ideas where $ is a compile time evaluated variable!) The use of &a follows C++ standard: it simply refers to a variable OR EXPRESSION that is imported into its scope. Using the unadorned variable name as evaluated expression allows us to write this code: macro max(a, b) { return (a > b ? a : b) } The above code is equivalent to: macro max(&a, &b) { typeof(a) $tmp_a = a; typeof(b) $tmp_b = b; $tmp_a > $tmp_b ? $tmp_a : $tmp_b } Or in (GNU) C: #define max(a,b) \\ ({ __typeof__ (a) _a = (a); \\ __typeof__ (b) _b = (b); \\ _a > _b ? _a : _b; }) To recap: Add the { } format to #define for multiline defines. Add $<name> format as hygienic variable names. Add the syntax \"macro\" type of definition. The syntax macro makes a difference between \"normal\" parameters (with & as prefix) and \"evaluated\" parameters (unadorned variables) Important is also to scope the macros: #define is always defined local to a scope (unlike in C). This means that #define FOO printf(\"foo\"); { #define BAR printf(\"bar\"); } FOO // adds printf(\"foo\"); BAR; // Error, define not available in scope; This also means that a define can be declared public to be accessed as if defined from the top of the file scope: // file 1 module foo public #define FOO { printf(\"FOO!\\n\"); } // file 2 import foo func void test() { foo.FOO } Only defines in the file scope that exists in the file scope may be public and used in other modules. Yet another macro proposal I found Simple macros macro @foo(&b) { b++; } func test() { int x = 1; @foo(x); } // Same as: func void test() { int x = 1; x++; } Macro with compile time values: macro @foo($x, &b) { b += $x; } func void test() { int x = 1; @foo(10, x); } // Expands to: func void test() { int x = 1; x += 10; } Macro with string capture macro @foo($x, #f) { `#f $x * $x`; } func void test() { i32 x = 1; @foo(4, \"x += \"); } // Expands to func void test() { i32 x = 1; x += 4 * 4; } macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { i32 x = 1; @foo2(\"x\"); } // Expands to funct void test2() { i32 x = 1; printf(\"%s was %d\\n\", \"x\", x); } Macro with conditional compile time values macro @foo($x, &b) { $IF ($x > 3) { b += $x * $x; } $ELSE { b += $x; } } func void test() { i32 x = 1; @foo(10, x); @foo(2, x); } // Expands to func void test() { i32 x = 1; x += 100; x += 2; } Nested macros (don't do this, but an example) macro @foo($a) { printf(\"%d\\n\", $a); $IF($a > 0) { @foo($a - 1); } } func void test() { @foo(2); } // Expands to func void test() { printf(\"%d\\n\", 2); printf(\"%d\\n\", 1); printf(\"%d\\n\", 0); } The above suggests macro sugar of loops: macro @foo($a) { $EACH(0..$a AS $x) { printf(\"%d\\n\", $x); } } macro @foo_enum(&a) { $EACH(a AS $x) { printf(\"%d\\n\", cast($x as int)); } } enum MyEnum { A, B, FOO } func void test() { @foo_enum(MyEnum); } // Expands to func void test() { printf(\"%d\\n\", cast(A as int)); printf(\"%d\\n\", cast(B as int)); printf(\"%d\\n\", cast(FOO as int)); } Each may iterate over: struct members (returned as string), enums (returned as the enum value) Type group helper macro @foo(int& a) // Macro only valid for a is any type of signed integer macro @foo(integer& a) // Valid for unsigned and signed integers macro @foo(number& a) // Valid for any float or integer Macros may force non local return macro @foo() { exit 1; // other keyword? 'escape'? I think exit is good, // but clashes with function name! } func int test() { @foo(); } // expands to func int test() { return 1; } Normal return creates a statement expression macro @foo(&a) { int x = a; x++; if (x > 0) return 1; return 2; } func int test() { b = 10; int y = @foo(b); } // Expands to: func int test() { b = 10; int __macro_ret_1; do { int __macro_x = b; __macro_x++; if (__macro_x > 0) { __macro_ret_1 = 1; break; } else { __macro_ret_1 = 2; break; } } while (0); int y = __macro_ret_1; } Bodies in macros macro @foo(&a, @body) { int z = 0; while (a < 10) { @body(); z++; } } func void test() { int i = 0; @foo(i) { i += 1; } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { i += 1; __macro_z++; } } } Bodies in macros with parameters macro @foo(&a, @body(&x, $y)) { int z = 0; while (a < 10) { @body(z, 2); z++; } } func void test() { int i = 0; @foo(i) { printf(\"%d / %d\\n\", x, y); } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { printf(\"%d / %d\\n\", __macro_z, 2); __macro_z++; } } } Expression is extended to parse: MACRO_IDENT => lookup $x in current macro scope and replace it with literal. Error if not in macro. MACRO_REPLACEMENT => invoke lexer on code inside, after doing a replace of any # inside. $IF requires that the expression can be evaluated to a constant value, similar holds for the range in $EACH . The general rule: 1. An argument prefixed with $ is always something that must be constant. 2. An argument prefixed with & is always a reference to an outer variable. 3. An argument prefixed with # always matches a string. It will be expanded when lexed in `` statements 4. A $ variable can be converted to a # variable. 5. A # can be evaluated to a $ 6. $ and # cannot be assigned to, they are always constant. 7. $ , & and # will never shadow variables from the outer scope.","title":"Crazy ideas"},{"location":"ideas/#ideas","text":"WARNING Unfinished ideas / brain dumps","title":"Ideas"},{"location":"ideas/#simpler-casts","text":"Use the type-call style casts: int i = int(2.0); Foo* f = Foo*(getBar()); Or explore some more exotic casts: int i = 2.0->int; Foo* f = getBar()->Foo*; int i = 2.0 as int; Foo* f = getBar() as Foo*; int i = 2.0::int; Foo* f = getBar()::Foo*;","title":"Simpler casts"},{"location":"ideas/#static-initializers","text":"Allow initialization of globals before main is invoked. Introduce a general static block. module foo; int x; static { x = rand(); } int y = rand(); func int randomCalculation() { return rand(); } Sematic roughly work like in Java, except that all know globals are initialized before main, as opposed to when the class is invoked. The order of initialization is unspecified.","title":"Static initializers"},{"location":"ideas/#module-versioning","text":"Follow Go Modules: Build file contains required library versions: e.g. 2.5.7 First number is major version number and is considered incompatible (basically a different module completely) Dependency resolution per major library version is done by picking the minimal version. E.g. module Foo requires Bar 1.5+ and module Baz requires 1.3+. Our module using Bar and Baz will resolve the minimal version to 1.3. This is the version that will be used. Note that if Foo used 2.5+, then both Bar 2.5 and 1.3 would be required.","title":"Module versioning"},{"location":"ideas/#polymorphic-functions","text":"It would theoretically be possible to replace the generics with ad hoc polymorphic functions. module adding(TypeA, TypeB, TypeC) func TypeC add_module(TypeA a, TypeB b) { return a + b; } generic func $c add_poly($a, $b) { return $a + $b; } Usage: // Module: import adding; define add_module(int, float, float) as int_float_add; define add_module(int, double, double) as int_double_add; func void test() { float f = int_float_add(2, 3.0) float f2 = add_poly(2, 3.0); double d = int_double_add(2, 3.0); double d2 = add_poly(2, 3.0); }","title":"Polymorphic functions"},{"location":"ideas/#allow-narrowing-conversions-for-floats","text":"Narrowing conversions for double -> float are common and might not be sufficiently important to do explicitly.","title":"Allow narrowing conversions for floats"},{"location":"ideas/#tests-built-in","text":"Unit tests built in as an integral part of the language like D.","title":"Tests built in"},{"location":"ideas/#allow-variable-alias","text":"Possibility to alias a variable name.","title":"Allow variable alias"},{"location":"ideas/#attribute-to-ensure-alignment","text":"@assertalign works as GCCs warn_if_not_aligned. On non packed structs, this will prevent compilation if padding is inserted in front of the member. On a packed struct, it will prevent compilation if it is not aligned.","title":"Attribute to ensure alignment"},{"location":"ideas/#binary-include","text":"The ability to include a binary file during compile time. An additional embed-path gives search dirs. byte[] file = @binary_include(\"foo.dat\"); Limiting embed to x bytes: byte[] file = @binary_include(\"/dev/urandomg\", 16);","title":"Binary include"},{"location":"ideas/#compile-time-run-include","text":"The ability to run a piece of code at compile time and include the result in the code. @run_include(\"foo.sh\", $some_param, \"-x\", $another_param);","title":"Compile time run-include"},{"location":"ideas/#type-functions","text":"Since static methods are out, it's natural to allow static values from the type, e.g. struct Foo { ... } ... Foo *foo = malloc(Foo.sizeof) There are a lot of type functions possible: sizeof offsetof name description elements There doesn't seem to be a need for applying this to non base type, but it should probably be allowed, e.g. (Foo*).sizeof","title":"Type functions"},{"location":"ideas/#macro-text-interpolation","text":"For certain cases, pure text interpolation might be needed. Within macros, any text within `` can be evaluated and parsed. macro void @foo($x, #f) { `#f $x * $x`; } func void test() { int x = 1; @foo(4, \"x +=\"); // Expands to -> // x += 4 * 4; } Another example, showing the difference between #var and `#var` : macro void @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { int x = 1; @foo2(x); // Expands to -> // printf(\"%s was %d\\n\", \"x\", x); }","title":"Macro text interpolation"},{"location":"ideas/#compile-time-string-functions","text":"In order to facilitate certain types of macros, the following macros are built in: @strToUpper(#f) Convert string to upper case. @strToLower(#f) Convert string to lower case. @strToVarName(#f, #space) Convert string to camel case from a space-based name scheme. @strToTypeName(#f, #space) Convert string to title case from a space-based name scheme. @strFromName(#f, #space) Convert title case or lower camel case to a space based scheme. @strReplace(#str, #pattern, #replacement, #count) Replace a string with another. @subString(#str, #start, #length) Return a substring of a compile time string. @strFind(#str, #stringToFind) Find a substring in a compile time string. @strHash(#str) Return the FNV1a hash of a string. @strLen(#str) Return a compile time length of a string. @stringify(#str) Escapes a string so it becomes a valid string.","title":"Compile time string functions"},{"location":"ideas/#implicit-this-in-method-functions","text":"struct Foo { int i; } func Foo.next(Foo*) { i++; }","title":"Implicit \"this\" in method functions"},{"location":"ideas/#managed-pointer-variables","text":"Managed pointer variables are introduced using @ after the type, rather than * e.g. Foo@ f . A managed variable will automatically call the type's release member function on its value when the variable goes out of scope or is reassigned. If there is no release function, then free is called. Foo@ f = Foo.alloc(); // * -> @ no retain. Foo@ b = f; // => f.retain(); b = f; f = nil; // => f.release(); f = nil; Any managed variable that goes out of the scope will automatically invoke release , as if the pointer was set to nil . { Foo@ b = Foo.alloc(); } // Automatic invocation of b.release(); In order to return a managed pointer that can be used as a temporary, it's often convenient to mark the return value as managed. func Foo@ createFoo() { return Foo.alloc(); } createFoo(); // Implicitly introduces a deferred release. If we assign a managed pointer to a variable, the release/retain is elided // The following becomes f1 = createFoo() - no deferred release or retains. Foo@ f1 = createFoo(); It's possible to manually manage a managed pointer: Foo* f2 = createFoo().retain(); f2.release(); // Required to prevent leaks. A managed pointer may safely assigned to a regular pointer as long as it's not retained outside of the scope. { Foo* f3 = createFoo(); printf(\"%d\", f3.someValue); // Safe, since f3 isn't actually used after the scope. } Foo* unsafeFoo; { unsafeFoo = createFoo(); } // <- access to unsafeFoo at this point will likely break things.","title":"Managed pointer variables"},{"location":"ideas/#managed-variables-not-pointers","text":"Managed variables should not be confused with automatic reference counting and similar. It is not possible to \u2013 for example \u2013 to make a struct member a \"managed\" pointer. It is strictly limited to variables and return values.","title":"Managed variables not pointers"},{"location":"ideas/#c-interop","text":"Steps: Add group header in the builds: [c-libs] Add the search paths: cpath = [\"/xxx/foo/ \", \"/bar/headers/ \"] Add each library: [[lib]] [c-libs] cpath = [\"/xxx/foo/**\", \"/bar/headers/**\"] [[lib]] module = \"windows\" header = \"windows.h\" [[lib]] module = \"stdlib\" header = \"stdlib.h\"","title":"C interop"},{"location":"ideas/#unsorted","text":"","title":"Unsorted"},{"location":"ideas/#halloc","text":"Hierarchal memory allocation http://swapped.cc/#!/halloc support it?","title":"Halloc"},{"location":"ideas/#tagged-any","text":"A tagged pointer union type for any possible type.","title":"Tagged any"},{"location":"ideas/#extended-case","text":"Switch as \"if-else\" switch (x) { case x > 200: return 0; case x < 2: small_x_warning(); case 0: .... case x > y && a < 1: ... }","title":"Extended \"case\""},{"location":"ideas/#case-as-a-range","text":"switch (x) { case 1 .. 10: ... case 11 .. 100: ... }","title":"Case as a range"},{"location":"ideas/#easy-to-get-properties","text":"Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports","title":"Easy to get properties"},{"location":"ideas/#associate-properties-to-an-enum","text":"enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" }","title":"Associate properties to an enum"},{"location":"ideas/#tagged-unions","text":"tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And another... struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { struct square { int side; } struct rectangle { int length; int height; } struct circle { int radius; } } } And yet another... struct Shape { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; }","title":"Tagged unions"},{"location":"ideas/#removal-of-the-volatile-type-qualifier","text":"The volatile type qualifier is replaced by volatile stores and loads. \\\\ C volatile void test() { volatile int v = 0; for (int i = 0; i < 100; i++) { // Usually these two would be optimized away, // but volatile will ensure it is executed. v = 1; int x = v; } } \\\\ C3 func void test() { int v = 0; for (int i = 0; i < 100; i++) { volatile(v) = 1; int x = volatile(v); } }","title":"Removal of the volatile type qualifier"},{"location":"ideas/#interfaces","text":"func void Foo.renderPage(Foo* foo, Page* info) { /* ... */ } interface Renderer { void renderPage(virtual Renderer* renderer, Page* info); } func void render(virtual Renderer* renderer, Page* info) { if (!rendered) return; renderer->renderPage(info); } func void test() { Foo* foo = getFoo(); Page* page = getPage(); // Option 1 Renderer.render(foo, page); // Option 2 virtual Renderer* renderer = foo; renderer.render(page); } // C equivalent: // struct RendererVtable { // void (*renderPage)(void*, Page*); // }; // struct RendererRef { // void* ref; RendererVTable *vtable; // }; // void Renderer__render(struct RendererRef renderer, Page *info) { // if (renderer.ref == null) return; // renderer.vtable->renderPage(renderer.ref, info); // } // // void test() { // Foo *foo = getFoo(); // Page *page = getPage(); // // static RenderVTable FooRendererVTable = { &Foo__renderPage }; // Renderer__render(struct RendererRef { foo, &FooRendererVTable }, page); // // struct RendererRef renderer = { foo, &FooRendererVTable }; // Renderer__render(renderer, page); // }","title":"Interfaces"},{"location":"ideas/#built-in-maps","text":"Same reasoning as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = try map[0]; // Requires a try // Retrive or use default int i = try map[12] else -1; // Extend a map: func bool int[int].remove_if_negative(int[int] *map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int *map, int32_t index);","title":"Built in maps"},{"location":"ideas/#built-in-string-type","text":"Strings are built-in, refcounted(?) null-terminated character arrays. Take a long hard look at memory management (here too) string = \"Hello\"; string += \" World\"; char* data = &string; // Taking a pointer to the string, which may later be invalid.","title":"Built in string type"},{"location":"ideas/#built-in-managed-pointers","text":"Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check.","title":"Built in managed pointers"},{"location":"ideas/#ideas-around-macros","text":"Just some previous thoughts and ideas I've considered. Many of those actually go against the current design.","title":"Ideas around macros"},{"location":"ideas/#compile-time-variables","text":"This is a variant of what already exists in C, but in a syntactically more friendly way. For example this would be ok: macro swap(a, b) { $x = typeof(a); static_assert(typeof(b) == $x); $x temp = a; a = b; b = a; } The example above is a bit contrived as in the above example we could simply have: macro swap(a, b) { static_assert(typeof(b) == typeof(b)); typeof(a) temp = a; a = b; b = a; } But still, it serves as an example on how to use it.","title":"Compile time variables"},{"location":"ideas/#capturing-trailing-compound-statement","text":"public macro foreach(thelist, @body(Element *) ) { Element* iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Or a version that is more flexible: public macro foreach(thelist, @body(typeof(thelist.first)) ) { typeof(thelist.first) iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } // Usage: foreach(list, Element *i) // <- Note type declaration! { i.print(); } Since type is going to appear very often, we could make a shortcut for it, like $@ as prefix meaning \"typeof\". We then get public macro foreach(thelist, @body($@thelist.first)) { $@thelist.first iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Possibly one could even write the code like this: public macro foreach(thelist, @body($element_type) ) { $element_type iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } In this case $element_type works like \"auto\", but is also assigned the type, which then can be referred to in the signature.","title":"Capturing trailing compound statement"},{"location":"ideas/#stepwise-from-c-macros-into-c3-macros","text":"#define ADD_TO(x, y) { x += y; } ADD_TO(x, 1) The { } introduces a multiline macro that does not need explicit linebreaks. Now, add the \"$\" symbol to introduce hygienic temporaries: #define SWAP(x, y) { typeof(x) $tmp = x; x = y; y = $tmp; } Here $tmp will actually be replaced by __<macro>_<variable_name>_<instance> when translating to C, so __SWAP_tmp_1 , __SWAP_tmp_2 etc. We then introduce the syntax macros using: macro swap(&a, &b) { typeof(a) $tmp = a; b = a; a = $tmp; } (Note the different use of $ here as compared to previous macro ideas where $ is a compile time evaluated variable!) The use of &a follows C++ standard: it simply refers to a variable OR EXPRESSION that is imported into its scope. Using the unadorned variable name as evaluated expression allows us to write this code: macro max(a, b) { return (a > b ? a : b) } The above code is equivalent to: macro max(&a, &b) { typeof(a) $tmp_a = a; typeof(b) $tmp_b = b; $tmp_a > $tmp_b ? $tmp_a : $tmp_b } Or in (GNU) C: #define max(a,b) \\ ({ __typeof__ (a) _a = (a); \\ __typeof__ (b) _b = (b); \\ _a > _b ? _a : _b; }) To recap: Add the { } format to #define for multiline defines. Add $<name> format as hygienic variable names. Add the syntax \"macro\" type of definition. The syntax macro makes a difference between \"normal\" parameters (with & as prefix) and \"evaluated\" parameters (unadorned variables) Important is also to scope the macros: #define is always defined local to a scope (unlike in C). This means that #define FOO printf(\"foo\"); { #define BAR printf(\"bar\"); } FOO // adds printf(\"foo\"); BAR; // Error, define not available in scope; This also means that a define can be declared public to be accessed as if defined from the top of the file scope: // file 1 module foo public #define FOO { printf(\"FOO!\\n\"); } // file 2 import foo func void test() { foo.FOO } Only defines in the file scope that exists in the file scope may be public and used in other modules.","title":"Stepwise from C macros into C3 macros"},{"location":"ideas/#yet-another-macro-proposal-i-found","text":"Simple macros macro @foo(&b) { b++; } func test() { int x = 1; @foo(x); } // Same as: func void test() { int x = 1; x++; } Macro with compile time values: macro @foo($x, &b) { b += $x; } func void test() { int x = 1; @foo(10, x); } // Expands to: func void test() { int x = 1; x += 10; } Macro with string capture macro @foo($x, #f) { `#f $x * $x`; } func void test() { i32 x = 1; @foo(4, \"x += \"); } // Expands to func void test() { i32 x = 1; x += 4 * 4; } macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { i32 x = 1; @foo2(\"x\"); } // Expands to funct void test2() { i32 x = 1; printf(\"%s was %d\\n\", \"x\", x); } Macro with conditional compile time values macro @foo($x, &b) { $IF ($x > 3) { b += $x * $x; } $ELSE { b += $x; } } func void test() { i32 x = 1; @foo(10, x); @foo(2, x); } // Expands to func void test() { i32 x = 1; x += 100; x += 2; } Nested macros (don't do this, but an example) macro @foo($a) { printf(\"%d\\n\", $a); $IF($a > 0) { @foo($a - 1); } } func void test() { @foo(2); } // Expands to func void test() { printf(\"%d\\n\", 2); printf(\"%d\\n\", 1); printf(\"%d\\n\", 0); } The above suggests macro sugar of loops: macro @foo($a) { $EACH(0..$a AS $x) { printf(\"%d\\n\", $x); } } macro @foo_enum(&a) { $EACH(a AS $x) { printf(\"%d\\n\", cast($x as int)); } } enum MyEnum { A, B, FOO } func void test() { @foo_enum(MyEnum); } // Expands to func void test() { printf(\"%d\\n\", cast(A as int)); printf(\"%d\\n\", cast(B as int)); printf(\"%d\\n\", cast(FOO as int)); } Each may iterate over: struct members (returned as string), enums (returned as the enum value) Type group helper macro @foo(int& a) // Macro only valid for a is any type of signed integer macro @foo(integer& a) // Valid for unsigned and signed integers macro @foo(number& a) // Valid for any float or integer Macros may force non local return macro @foo() { exit 1; // other keyword? 'escape'? I think exit is good, // but clashes with function name! } func int test() { @foo(); } // expands to func int test() { return 1; } Normal return creates a statement expression macro @foo(&a) { int x = a; x++; if (x > 0) return 1; return 2; } func int test() { b = 10; int y = @foo(b); } // Expands to: func int test() { b = 10; int __macro_ret_1; do { int __macro_x = b; __macro_x++; if (__macro_x > 0) { __macro_ret_1 = 1; break; } else { __macro_ret_1 = 2; break; } } while (0); int y = __macro_ret_1; } Bodies in macros macro @foo(&a, @body) { int z = 0; while (a < 10) { @body(); z++; } } func void test() { int i = 0; @foo(i) { i += 1; } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { i += 1; __macro_z++; } } } Bodies in macros with parameters macro @foo(&a, @body(&x, $y)) { int z = 0; while (a < 10) { @body(z, 2); z++; } } func void test() { int i = 0; @foo(i) { printf(\"%d / %d\\n\", x, y); } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { printf(\"%d / %d\\n\", __macro_z, 2); __macro_z++; } } } Expression is extended to parse: MACRO_IDENT => lookup $x in current macro scope and replace it with literal. Error if not in macro. MACRO_REPLACEMENT => invoke lexer on code inside, after doing a replace of any # inside. $IF requires that the expression can be evaluated to a constant value, similar holds for the range in $EACH . The general rule: 1. An argument prefixed with $ is always something that must be constant. 2. An argument prefixed with & is always a reference to an outer variable. 3. An argument prefixed with # always matches a string. It will be expanded when lexed in `` statements 4. A $ variable can be converted to a # variable. 5. A # can be evaluated to a $ 6. $ and # cannot be assigned to, they are always constant. 7. $ , & and # will never shadow variables from the outer scope.","title":"Yet another macro proposal I found"},{"location":"library/","text":"Library The standard library design is a sketch, no work has been done on this yet. lang macro scoped(..., @body) Scopes a list of variables: int a = 3; double b = 1.0; @scoped(a, b) { a = 4; b = 1.2; } // Prints a = 3, b = 1.0 printf(\"a = %d, b = %f\\n\", a, b); This can be useful to push another allocator: @scoped(mem::defaultAllocator) { mem::defaultAllocator = myArenaAllocator; // This will now use myArenaAllocator: doSomethingThatAllocates(); } // The default allocator is restored here. Other macros: max(a, b) maximum of two values using > min(a, b) minimum of two values using < swap($a, $b) swap two variables using = and a temporary variable. mem Mem contains memory allocators Globals Alloc* defaultAlloc Alloc* tempAlloc ```` allocators RingAlloc ring buffer allocator ArenaAlloc arena allocator Encodings Ref counting Any struct can enable ref counting by including the RefCount struct: import std::refcount; struct Person { RefCount rc inline; char[] name; } func void test() { Person* person = malloc(sizeof(Person)); person.initRC(&free); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.retain(); printf(\"RC = %d\\n\", person.refCount); // Prints 2 person.release(); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.release(); // Will call free(person) }","title":"Library"},{"location":"library/#library","text":"The standard library design is a sketch, no work has been done on this yet.","title":"Library"},{"location":"library/#lang","text":"","title":"lang"},{"location":"library/#macro-scoped-body","text":"Scopes a list of variables: int a = 3; double b = 1.0; @scoped(a, b) { a = 4; b = 1.2; } // Prints a = 3, b = 1.0 printf(\"a = %d, b = %f\\n\", a, b); This can be useful to push another allocator: @scoped(mem::defaultAllocator) { mem::defaultAllocator = myArenaAllocator; // This will now use myArenaAllocator: doSomethingThatAllocates(); } // The default allocator is restored here.","title":"macro scoped(..., @body)"},{"location":"library/#other-macros","text":"max(a, b) maximum of two values using > min(a, b) minimum of two values using < swap($a, $b) swap two variables using = and a temporary variable.","title":"Other macros:"},{"location":"library/#mem","text":"Mem contains memory allocators","title":"mem"},{"location":"library/#globals","text":"Alloc* defaultAlloc Alloc* tempAlloc ````","title":"Globals"},{"location":"library/#allocators","text":"RingAlloc ring buffer allocator ArenaAlloc arena allocator","title":"allocators"},{"location":"library/#encodings","text":"","title":"Encodings"},{"location":"library/#ref-counting","text":"Any struct can enable ref counting by including the RefCount struct: import std::refcount; struct Person { RefCount rc inline; char[] name; } func void test() { Person* person = malloc(sizeof(Person)); person.initRC(&free); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.retain(); printf(\"RC = %d\\n\", person.refCount); // Prints 2 person.release(); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.release(); // Will call free(person) }","title":"Ref counting"},{"location":"macros/","text":"Macros WILL be subject to later revision! The macro capabilities of C3 reaches across several constructs: macros (prefixed with @ at invocation), generic functions , generic modules , compile time variables (prefixed with $e ), macro compile time execution (using $if , $each , $switch ), attributes and incremental structs, enums and arrays. A quick comparison of C and C3 macros Conditional compilation // C #if defined(x) && y > 3 int z; #endif // C3 $if ($defined(x) && y > 3): int z; $endif; Macros // C #define M(x) ((x) + 2) #define RETURN(x) return x; #define u32 unsigned int // Use: int y = M(foo() + 2); RETURN(bar()); u32 b = y; // C3 macro m(x) { return x + 2; } macro ret!(x) { return x; } typedef uint as u32; // Use: int y = @m(foo() + 2); @ret!(bar()); u32 b = y; Dynamic scoping // C #define Z() ptr->x->y->z int z = Z(); // C3 macro z(implicit ptr) { return ptr->x->y->z; } int z = @z(); Reference arguments // C #define M(x, y) x = 2 * (y); // C3 macro m(int &x, int y) { x = 2 * y; } First class types // C #define SIZE(T) (sizeof(T) + sizeof(int)) // C3 macro size($Type) { return sizeof($Type) + sizeof(int); } First class statements // C #define FOR_EACH(x, list) \\ for (x = (list); x; x = x->next) // Use: Foo *it; FOR_EACH(it, list) { if (!process(it)) return; } // C3 macro for_each(list, macro void(it) @body) { for (typeof(list) x = list; x; x = x->next) @body(x); } // Use: @for_each(list; Foo* x) { if (!process(x)) return; } First class names // C #define offsetof(T, field) (size_t)(&((T*)0)->field) // C3 macro offsetof($Type, $field) { return (size_t)(&((T*)0)->field); } Declaration attributes // C #define NONNULL(args...) __attribute__((nonnull(args))) // C3 ... currently no corresponding functionality ... Declaration macros // C #define DECLARE_LIST(name) List name = { .head = NULL }; // Use: DECLARE_LIST(hello) // C3 ... currently no corresponding functionality ... Stringingification #define DECLARE_STRING(name, s) char *name##_str = #s; // C3 ... currently no corresponding functionality ... Top level evaluation Script languages, and also upcoming languages like Jai , usually have unbounded top level evaluation. The flexibility of this style of meta programming has a trade off in making the code more challenging to understand. In C3, top level compile time evaluation is limited to $if and $switch constructs. This makes the code easier to read by sacrificing flexibility. However, the incremental structs, enums and arrays provided by the compiler offers a way to build compile time structures without the necessity for full meta programming capabilities. Macro declarations A macro is defined using macro <name>(<parameters>) . All user defined macros use the @ symbol. The parameters have different sigils: $ means compile time evaluated (captured variable, symbol or expression). Any parameters without sigils are passed by value , as if it was a normal function parameter. A basic swap: /** * @ensure parse(a = b), parse(b = a) */ macro void swap($a, $b) { typeof(a) temp = a; a = b; b = temp; } This expands on usage like this: func void test() { int a = 10; int b = 20; @swap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __temp = a; a = b; b = __temp; } } Note the necessary $ . Here is an incorrect swap and what it would expand to: macro void badswap(auto a, auto b) { typeof(a) temp = a; a = b; b = temp; } func void test() { int a = 10; int b = 20; @badswap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __a = a; int __b = b; int __temp = __a; __a = __b; __b = __temp; } } Method macros Similar to method functions a macro may also be associated with a particular type: struct Foo { ... } macro Foo.generate(Foo *foo) { ... } Foo f; @f.generate(); Capturing a macro body It is often useful for a macro to take a trailing compound statement as an argument. In C++ the pattern is usually expressed with a lambda, but in C3 this is completely inlined. Any macro that takes a macro in the last position may be expressed as a trailing body instead. When the call puts the parameters for the trailing macro after ; . Here's an example to illustrate it the use: /** * A macro looping through a list of values, executing the body once * every pass. * * @ensure parse(int i = a.len), parse(value2 = a[i]) */ macro foreach(auto a, macro void(value, value) foo) { for (int i = 0; i < a.len; i++) { @body(i, a[i]); } } func void test() { double[] a = { 1.0, 2.0, 3.0 }; @foreach(a; int index, double value) { printf(\"a[%d] = %f\\n\", index, value); } } // Expands to code similar to: func void test() { int[] a = { 1, 2, 3 }; { int[] __a = a; for (int __i = 0; i < __a.len; i++) { printf(\"Value: %d, x2: %d\\n\", __value1, __value2); } } } Macros returning values A macro may return a value, it is then considered an expression rather than a statement: macro auto square(auto x) { return x * x; } int getTheSquare(int x) { return square(x); } double getTheSquare2(double x) { return square(x); } Calling macros It's perfectly fine for a macro to invoke another macro or itself. macro @square(x) { return x * x; } macro @squarePlusOne(x) { return @square(x) + 1; // Expands to \"return x * x + 1;\" } The maximum recursion depth is limited to the macro-recursion-depth build setting. Macro directives Inside of a macro, we can use the compile time statements $if , $each and $switch . Macros may also be recursively invoked. As previously mentioned, $if and $switch may also be invoked on the top level. $if, $else and $elif $if (<const expr>): takes a compile time constant value and evaluates it to true or false. macro @foo($x, $y) { $if ($x > 3): $y += $x * $x; $else: $y += $x; $endif; } const int FOO = 10; func void test() { int a = 5; int b = 4; @foo(1, a); // Allowed, expands to a += 1; // @foo(b, a); // Error: b is not a compile time constant. @foo(FOO, a); // Allowed, expands to a += FOO * FOO; } Loops using $foreach $foreach (<range> as <variable>): ... $endforeach; allows compile time recursion. $each may recurse over enums, struct fields or constant ranges. Everything must be known at compile time. Looping over ranges: macro @foo($a) { $foreach (0..$a as $x): printf(\"%d\\n\", $x); $endforeach; } func void test() { @foo(2); // Expands to -> // printf(\"%d\\n\", 0); // printf(\"%d\\n\", 1); } Looping over enums: macro @foo_enum($some_enum) { $foreach($some_enum as $x): printf(\"%d\\n\", cast($x as int)); $endforeach; } enum MyEnum { A, B, } func void test() { @foo_enum(MyEnum); // Expands to -> // printf(\"%d\\n\", cast(MyEnum.A as int)); // printf(\"%d\\n\", cast(MyEnum.B as int)); } An important thing to note is that the content of the $each body must be a complete statement. It's not possible to compile partial statements. Switching on type with $switch It's possible to switch on type, similar to generic functions, but used internal to the macro: macro void foo(a, b) { $switch(a, b): $case int, int: return a * b; endswitch; return a + b; } Escape macros Usually macro will generate its own scope, so that break, return, continue and next only stays valid inside of the macro's \"scope\". A return from inside a macro does not normally escape the scope into which it's called: macro void @foo() { return; } func void test() { @foo(); // Doesn't do anything. printf(\"Test\\n\"); } However, sometimes macros are needed that does not create its own scope, allowing return, break etc work as if it was part of the included scope. Escape macros does exactly that. An escape macro adds a \"!\" to the macro name. Note that this becomes part of the macro name. macro void @foo!() { return; } func void test() { @foo!(); // The function returns here. printf(\"Test\\n\"); // Never printed! } This is not limited to return: break , continue and next is allowed. macro next!($f) { nextcase $f; } func void test() { int i = 1; switch (i) { case 1: @next!(3); printf(\"Foo\\n\"); case 3: printf(\"Bar!\\n\") } } The above code will print \"Bar!\" Conditional macros at the top level A limitation with the macros is that they are only used within functions. This is deliberate \u2013 macros expanding at the top level are much harder to reason about since they should be able to define new types or change the meaning of the code that follows. Still, the usefulness of top level macros is great, which is why C3 offers four pieces of functionality for the top level: conditional compilation, global compile time varibles, attributes and incremental arrays. Conditional compilation Conditional compilation is done with $if and $else, which works just like inside of functions. $if (@defined($os) && $os == 'WIN32'): func void doSomethingWin32Specific() { /* .... */ } $endif; Global compile time variables Variables on the top level work like compile time variables in macros \u2013 with the exception that they must always be declared constant. They are always evaluated in order, which has to be taken into account when used in conjunction with @defined. Consider this code: macro @foo() { $if ($defined(A)): return A + 1; endif; return 1; } const Z = @foo(); // Z = 1 const A = @foo(); // A = 1 const B = @foo(); // B = 2 Attributes Attributes are tags placed on functions, types and variables. They may take a type as argument, much like a function. It's possible iterate over all the objects that have an attribute of a particular type. attribute func @myvar(int i = 0); attribute struct, union, enum @foo; func void test() @myvar(2) { /** ... */ } struct Test @foo { int i; } What's useful about attributes is that they can be accessed during compile time: macro @fooCheck($a) { $if ($defined($a.@foo)): return \"Was fooed\"; endif; return \"Ok\"; } struct TestA { int i; } struct TestB @Foo { float f; } func void test() { printf(\"Check TestA: \" @fooCheck(TestA) \"\\n\"); printf(\"Check TestB: \" @fooCheck(TestB) \"\\n\"); // Prints: // Check TestA: Ok // Check TestB: Was fooed } It's also possible to get hold of the values: attribute func @myvar(int i = 0); func void test() @myvar(200) { ... } func void test() { printf(\"%d\", test.@myvar.i); // Prints 200 } Incremental arrays Incremental arrays allows compile time arrays to be constructed piecemeal within a single source file. An incremental array uses the [+] ending, but will be considered to be a fixed size array for all other purposes. Append to an incremental array using += which done during compile time. int[+] a = { 1 }; a += 1; /* ... other code .. */ a += 2; // Equivalent to the declaration int[3] a = { 1, 1, 2 }; This can be especially useful in conjuction with $each : enum MyEnum { A, B } macro type @foo_enum($theEnum) { string[+] arr = {}; $foreach ($theEnum as $x): arr += @name($x); $endif; } // allMyEnum will contain { \"A\", \"B\" } const string[] allMyEnum = @foo_enum(MyEnum); Here is a similar example but for attributes: attribute struct @special; struct TestA @special { int i; } struct TestB { float f; } struct TestC @special { float f; } macro void @specialStructs() { string[+] res = {}; $foreach (@special as $x): res += @name($x); endif; // The above expands to: // res += \"TestA\"; // res += \"TestC\"; return res; } // SPECIAL_STRUCTS = { \"TestA\", \"TestB\" } const string[] SPECIAL_STRUCTS = @specialStructs();","title":"Macros"},{"location":"macros/#macros","text":"WILL be subject to later revision! The macro capabilities of C3 reaches across several constructs: macros (prefixed with @ at invocation), generic functions , generic modules , compile time variables (prefixed with $e ), macro compile time execution (using $if , $each , $switch ), attributes and incremental structs, enums and arrays.","title":"Macros"},{"location":"macros/#a-quick-comparison-of-c-and-c3-macros","text":"","title":"A quick comparison of C and C3 macros"},{"location":"macros/#conditional-compilation","text":"// C #if defined(x) && y > 3 int z; #endif // C3 $if ($defined(x) && y > 3): int z; $endif;","title":"Conditional compilation"},{"location":"macros/#macros_1","text":"// C #define M(x) ((x) + 2) #define RETURN(x) return x; #define u32 unsigned int // Use: int y = M(foo() + 2); RETURN(bar()); u32 b = y; // C3 macro m(x) { return x + 2; } macro ret!(x) { return x; } typedef uint as u32; // Use: int y = @m(foo() + 2); @ret!(bar()); u32 b = y;","title":"Macros"},{"location":"macros/#dynamic-scoping","text":"// C #define Z() ptr->x->y->z int z = Z(); // C3 macro z(implicit ptr) { return ptr->x->y->z; } int z = @z();","title":"Dynamic scoping"},{"location":"macros/#reference-arguments","text":"// C #define M(x, y) x = 2 * (y); // C3 macro m(int &x, int y) { x = 2 * y; }","title":"Reference arguments"},{"location":"macros/#first-class-types","text":"// C #define SIZE(T) (sizeof(T) + sizeof(int)) // C3 macro size($Type) { return sizeof($Type) + sizeof(int); }","title":"First class types"},{"location":"macros/#first-class-statements","text":"// C #define FOR_EACH(x, list) \\ for (x = (list); x; x = x->next) // Use: Foo *it; FOR_EACH(it, list) { if (!process(it)) return; } // C3 macro for_each(list, macro void(it) @body) { for (typeof(list) x = list; x; x = x->next) @body(x); } // Use: @for_each(list; Foo* x) { if (!process(x)) return; }","title":"First class statements"},{"location":"macros/#first-class-names","text":"// C #define offsetof(T, field) (size_t)(&((T*)0)->field) // C3 macro offsetof($Type, $field) { return (size_t)(&((T*)0)->field); }","title":"First class names"},{"location":"macros/#declaration-attributes","text":"// C #define NONNULL(args...) __attribute__((nonnull(args))) // C3 ... currently no corresponding functionality ...","title":"Declaration attributes"},{"location":"macros/#declaration-macros","text":"// C #define DECLARE_LIST(name) List name = { .head = NULL }; // Use: DECLARE_LIST(hello) // C3 ... currently no corresponding functionality ...","title":"Declaration macros"},{"location":"macros/#stringingification","text":"#define DECLARE_STRING(name, s) char *name##_str = #s; // C3 ... currently no corresponding functionality ...","title":"Stringingification"},{"location":"macros/#top-level-evaluation","text":"Script languages, and also upcoming languages like Jai , usually have unbounded top level evaluation. The flexibility of this style of meta programming has a trade off in making the code more challenging to understand. In C3, top level compile time evaluation is limited to $if and $switch constructs. This makes the code easier to read by sacrificing flexibility. However, the incremental structs, enums and arrays provided by the compiler offers a way to build compile time structures without the necessity for full meta programming capabilities.","title":"Top level evaluation"},{"location":"macros/#macro-declarations","text":"A macro is defined using macro <name>(<parameters>) . All user defined macros use the @ symbol. The parameters have different sigils: $ means compile time evaluated (captured variable, symbol or expression). Any parameters without sigils are passed by value , as if it was a normal function parameter. A basic swap: /** * @ensure parse(a = b), parse(b = a) */ macro void swap($a, $b) { typeof(a) temp = a; a = b; b = temp; } This expands on usage like this: func void test() { int a = 10; int b = 20; @swap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __temp = a; a = b; b = __temp; } } Note the necessary $ . Here is an incorrect swap and what it would expand to: macro void badswap(auto a, auto b) { typeof(a) temp = a; a = b; b = temp; } func void test() { int a = 10; int b = 20; @badswap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __a = a; int __b = b; int __temp = __a; __a = __b; __b = __temp; } }","title":"Macro declarations"},{"location":"macros/#method-macros","text":"Similar to method functions a macro may also be associated with a particular type: struct Foo { ... } macro Foo.generate(Foo *foo) { ... } Foo f; @f.generate();","title":"Method macros"},{"location":"macros/#capturing-a-macro-body","text":"It is often useful for a macro to take a trailing compound statement as an argument. In C++ the pattern is usually expressed with a lambda, but in C3 this is completely inlined. Any macro that takes a macro in the last position may be expressed as a trailing body instead. When the call puts the parameters for the trailing macro after ; . Here's an example to illustrate it the use: /** * A macro looping through a list of values, executing the body once * every pass. * * @ensure parse(int i = a.len), parse(value2 = a[i]) */ macro foreach(auto a, macro void(value, value) foo) { for (int i = 0; i < a.len; i++) { @body(i, a[i]); } } func void test() { double[] a = { 1.0, 2.0, 3.0 }; @foreach(a; int index, double value) { printf(\"a[%d] = %f\\n\", index, value); } } // Expands to code similar to: func void test() { int[] a = { 1, 2, 3 }; { int[] __a = a; for (int __i = 0; i < __a.len; i++) { printf(\"Value: %d, x2: %d\\n\", __value1, __value2); } } }","title":"Capturing a macro body"},{"location":"macros/#macros-returning-values","text":"A macro may return a value, it is then considered an expression rather than a statement: macro auto square(auto x) { return x * x; } int getTheSquare(int x) { return square(x); } double getTheSquare2(double x) { return square(x); }","title":"Macros returning values"},{"location":"macros/#calling-macros","text":"It's perfectly fine for a macro to invoke another macro or itself. macro @square(x) { return x * x; } macro @squarePlusOne(x) { return @square(x) + 1; // Expands to \"return x * x + 1;\" } The maximum recursion depth is limited to the macro-recursion-depth build setting.","title":"Calling macros"},{"location":"macros/#macro-directives","text":"Inside of a macro, we can use the compile time statements $if , $each and $switch . Macros may also be recursively invoked. As previously mentioned, $if and $switch may also be invoked on the top level.","title":"Macro directives"},{"location":"macros/#if-else-and-elif","text":"$if (<const expr>): takes a compile time constant value and evaluates it to true or false. macro @foo($x, $y) { $if ($x > 3): $y += $x * $x; $else: $y += $x; $endif; } const int FOO = 10; func void test() { int a = 5; int b = 4; @foo(1, a); // Allowed, expands to a += 1; // @foo(b, a); // Error: b is not a compile time constant. @foo(FOO, a); // Allowed, expands to a += FOO * FOO; }","title":"$if, $else and $elif"},{"location":"macros/#loops-using-foreach","text":"$foreach (<range> as <variable>): ... $endforeach; allows compile time recursion. $each may recurse over enums, struct fields or constant ranges. Everything must be known at compile time. Looping over ranges: macro @foo($a) { $foreach (0..$a as $x): printf(\"%d\\n\", $x); $endforeach; } func void test() { @foo(2); // Expands to -> // printf(\"%d\\n\", 0); // printf(\"%d\\n\", 1); } Looping over enums: macro @foo_enum($some_enum) { $foreach($some_enum as $x): printf(\"%d\\n\", cast($x as int)); $endforeach; } enum MyEnum { A, B, } func void test() { @foo_enum(MyEnum); // Expands to -> // printf(\"%d\\n\", cast(MyEnum.A as int)); // printf(\"%d\\n\", cast(MyEnum.B as int)); } An important thing to note is that the content of the $each body must be a complete statement. It's not possible to compile partial statements.","title":"Loops using $foreach"},{"location":"macros/#switching-on-type-with-switch","text":"It's possible to switch on type, similar to generic functions, but used internal to the macro: macro void foo(a, b) { $switch(a, b): $case int, int: return a * b; endswitch; return a + b; }","title":"Switching on type with $switch"},{"location":"macros/#escape-macros","text":"Usually macro will generate its own scope, so that break, return, continue and next only stays valid inside of the macro's \"scope\". A return from inside a macro does not normally escape the scope into which it's called: macro void @foo() { return; } func void test() { @foo(); // Doesn't do anything. printf(\"Test\\n\"); } However, sometimes macros are needed that does not create its own scope, allowing return, break etc work as if it was part of the included scope. Escape macros does exactly that. An escape macro adds a \"!\" to the macro name. Note that this becomes part of the macro name. macro void @foo!() { return; } func void test() { @foo!(); // The function returns here. printf(\"Test\\n\"); // Never printed! } This is not limited to return: break , continue and next is allowed. macro next!($f) { nextcase $f; } func void test() { int i = 1; switch (i) { case 1: @next!(3); printf(\"Foo\\n\"); case 3: printf(\"Bar!\\n\") } } The above code will print \"Bar!\"","title":"Escape macros"},{"location":"macros/#conditional-macros-at-the-top-level","text":"A limitation with the macros is that they are only used within functions. This is deliberate \u2013 macros expanding at the top level are much harder to reason about since they should be able to define new types or change the meaning of the code that follows. Still, the usefulness of top level macros is great, which is why C3 offers four pieces of functionality for the top level: conditional compilation, global compile time varibles, attributes and incremental arrays.","title":"Conditional macros at the top level"},{"location":"macros/#conditional-compilation_1","text":"Conditional compilation is done with $if and $else, which works just like inside of functions. $if (@defined($os) && $os == 'WIN32'): func void doSomethingWin32Specific() { /* .... */ } $endif;","title":"Conditional compilation"},{"location":"macros/#global-compile-time-variables","text":"Variables on the top level work like compile time variables in macros \u2013 with the exception that they must always be declared constant. They are always evaluated in order, which has to be taken into account when used in conjunction with @defined. Consider this code: macro @foo() { $if ($defined(A)): return A + 1; endif; return 1; } const Z = @foo(); // Z = 1 const A = @foo(); // A = 1 const B = @foo(); // B = 2","title":"Global compile time variables"},{"location":"macros/#attributes","text":"Attributes are tags placed on functions, types and variables. They may take a type as argument, much like a function. It's possible iterate over all the objects that have an attribute of a particular type. attribute func @myvar(int i = 0); attribute struct, union, enum @foo; func void test() @myvar(2) { /** ... */ } struct Test @foo { int i; } What's useful about attributes is that they can be accessed during compile time: macro @fooCheck($a) { $if ($defined($a.@foo)): return \"Was fooed\"; endif; return \"Ok\"; } struct TestA { int i; } struct TestB @Foo { float f; } func void test() { printf(\"Check TestA: \" @fooCheck(TestA) \"\\n\"); printf(\"Check TestB: \" @fooCheck(TestB) \"\\n\"); // Prints: // Check TestA: Ok // Check TestB: Was fooed } It's also possible to get hold of the values: attribute func @myvar(int i = 0); func void test() @myvar(200) { ... } func void test() { printf(\"%d\", test.@myvar.i); // Prints 200 }","title":"Attributes"},{"location":"macros/#incremental-arrays","text":"Incremental arrays allows compile time arrays to be constructed piecemeal within a single source file. An incremental array uses the [+] ending, but will be considered to be a fixed size array for all other purposes. Append to an incremental array using += which done during compile time. int[+] a = { 1 }; a += 1; /* ... other code .. */ a += 2; // Equivalent to the declaration int[3] a = { 1, 1, 2 }; This can be especially useful in conjuction with $each : enum MyEnum { A, B } macro type @foo_enum($theEnum) { string[+] arr = {}; $foreach ($theEnum as $x): arr += @name($x); $endif; } // allMyEnum will contain { \"A\", \"B\" } const string[] allMyEnum = @foo_enum(MyEnum); Here is a similar example but for attributes: attribute struct @special; struct TestA @special { int i; } struct TestB { float f; } struct TestC @special { float f; } macro void @specialStructs() { string[+] res = {}; $foreach (@special as $x): res += @name($x); endif; // The above expands to: // res += \"TestA\"; // res += \"TestC\"; return res; } // SPECIAL_STRUCTS = { \"TestA\", \"TestB\" } const string[] SPECIAL_STRUCTS = @specialStructs();","title":"Incremental arrays"},{"location":"modules/","text":"Modules C3 groups functions, types, variables and macros into namespaces called modules. When doing builds, any C3 file must start with the module keyword, specifying the module. When compiling single files, the module is not needed and the module name is assumed to be the file name, converted to lower case, with any invalid characters replaced by underscore ( _ ). A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module bar; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar . Details Some details about the C3 module system: Modules can be arbitrarily nested, e.g. module foo::bar::baz; to create the sub module baz in the sub module bar of the module foo . Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters. Importing modules Importing a module uses the import keyword. Imports have file scope, so consequently if file_a.c3 imports the module networking , then file_b.c3 cannot use those symbols unless it also imports networking . file_a.c3 module foo; //import bar and stdio import bar; import stdio; /* ... */ file_b.c3 module foo; //import bar and networking imported, but not storage import bar; import networking; /* ... */ Visibility All files in the same module share the same global declaration namespace. However, by default a function is not visible outside the module. To make the symbol visible outside the module, use the keyword public . module foo; public func void init() { .. } func void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it isn't specified as public. Overriding symbol visibility rules By using as module after an import, it's possible to access another module\u00b4s private symbols. Many other module systems have hierarchal visibility rules, but the as module feature allows visibility to be manipulated in a more ad-hoc manner without imposing hard rules. For example, you may provide a library with two modules: \"mylib::net\" and \"mylib::file\" - which both use functions and types from a common \"mylib::internals\" module. The two libraries use import mylib::internals as module to access this module's private functions and type. To an external user of the library, the \"mylib::internals\" does not seem to exist, but inside of your library you use it as a shared dependency. A simple example: // File a.c3 module a; func void aFunction() { ... } // File b.c3 module b; func void bFunction() { ... } // File c.c3 module c; import a; import b as module; func void test() { a::aFunction(); // <-- error, aFunction not public b::bFunction(); // Allowed since import was \"as module\" } Using functions and types from other modules As a rule, functions, macros, constants, variables and types in the same module do not need any namespace prefix. For imported modules the following rules hold: Functions, macros, constants and variables require at least the (sub-) module name. Types do not require the module name unless the name is ambiguous. In case of ambiguity, only so many levels of module names are needed as to make the symbol unambiguous. // File a.c3 module a; public struct Foo { ... } public struct Bar { ... } public struct TheAStruct { ... } public func void anAFunction() { ... } // File b.c3 module b; public struct Foo { ... } public struct Bar { ... } public struct TheBStruct { ... } public func void aBFunction() { ... } // File c.c3 module c; import a; import b; struct TheCStruct { ... } struct Bar { ... } func void aCFunction() { ... } func void test() { TheAStruct stA; TheBStruct stB; TheCStruct stC; // Name required to avoid ambiguity; b::Foo stBFoo; // Will always pick the current module's // name. Bar bar; // Namespace required: a::aAFunction(); b::aBFunction(); // A local symbol does not require it: aCFunction(); } This means that the rule for the common case can be summarized as Types are used without prefix; functions, variables, macros and constants are prefixed with the sub module name. Textual includes It's sometimes useful to include an entire file, doing so employs the $include function. File Foo.c3 module foo; $include(\"Foo.x\"); func void test() { printf(\"%d\", testX(2)); } File Foo.x public func testX(int i) { return i + 1; } The result is as if Foo.c3 contained the following: module foo; public func testX(int i) { return i + 1; } func void test() { printf(\"%d\", testX(2)); } The include may use an absolute or relative path, the relative path is always relative to the source file in which the include appears.","title":"Modules"},{"location":"modules/#modules","text":"C3 groups functions, types, variables and macros into namespaces called modules. When doing builds, any C3 file must start with the module keyword, specifying the module. When compiling single files, the module is not needed and the module name is assumed to be the file name, converted to lower case, with any invalid characters replaced by underscore ( _ ). A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module bar; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar .","title":"Modules"},{"location":"modules/#details","text":"Some details about the C3 module system: Modules can be arbitrarily nested, e.g. module foo::bar::baz; to create the sub module baz in the sub module bar of the module foo . Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters.","title":"Details"},{"location":"modules/#importing-modules","text":"Importing a module uses the import keyword. Imports have file scope, so consequently if file_a.c3 imports the module networking , then file_b.c3 cannot use those symbols unless it also imports networking . file_a.c3 module foo; //import bar and stdio import bar; import stdio; /* ... */ file_b.c3 module foo; //import bar and networking imported, but not storage import bar; import networking; /* ... */","title":"Importing modules"},{"location":"modules/#visibility","text":"All files in the same module share the same global declaration namespace. However, by default a function is not visible outside the module. To make the symbol visible outside the module, use the keyword public . module foo; public func void init() { .. } func void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it isn't specified as public.","title":"Visibility"},{"location":"modules/#overriding-symbol-visibility-rules","text":"By using as module after an import, it's possible to access another module\u00b4s private symbols. Many other module systems have hierarchal visibility rules, but the as module feature allows visibility to be manipulated in a more ad-hoc manner without imposing hard rules. For example, you may provide a library with two modules: \"mylib::net\" and \"mylib::file\" - which both use functions and types from a common \"mylib::internals\" module. The two libraries use import mylib::internals as module to access this module's private functions and type. To an external user of the library, the \"mylib::internals\" does not seem to exist, but inside of your library you use it as a shared dependency. A simple example: // File a.c3 module a; func void aFunction() { ... } // File b.c3 module b; func void bFunction() { ... } // File c.c3 module c; import a; import b as module; func void test() { a::aFunction(); // <-- error, aFunction not public b::bFunction(); // Allowed since import was \"as module\" }","title":"Overriding symbol visibility rules"},{"location":"modules/#using-functions-and-types-from-other-modules","text":"As a rule, functions, macros, constants, variables and types in the same module do not need any namespace prefix. For imported modules the following rules hold: Functions, macros, constants and variables require at least the (sub-) module name. Types do not require the module name unless the name is ambiguous. In case of ambiguity, only so many levels of module names are needed as to make the symbol unambiguous. // File a.c3 module a; public struct Foo { ... } public struct Bar { ... } public struct TheAStruct { ... } public func void anAFunction() { ... } // File b.c3 module b; public struct Foo { ... } public struct Bar { ... } public struct TheBStruct { ... } public func void aBFunction() { ... } // File c.c3 module c; import a; import b; struct TheCStruct { ... } struct Bar { ... } func void aCFunction() { ... } func void test() { TheAStruct stA; TheBStruct stB; TheCStruct stC; // Name required to avoid ambiguity; b::Foo stBFoo; // Will always pick the current module's // name. Bar bar; // Namespace required: a::aAFunction(); b::aBFunction(); // A local symbol does not require it: aCFunction(); } This means that the rule for the common case can be summarized as Types are used without prefix; functions, variables, macros and constants are prefixed with the sub module name.","title":"Using functions and types from other modules"},{"location":"modules/#textual-includes","text":"It's sometimes useful to include an entire file, doing so employs the $include function. File Foo.c3 module foo; $include(\"Foo.x\"); func void test() { printf(\"%d\", testX(2)); } File Foo.x public func testX(int i) { return i + 1; } The result is as if Foo.c3 contained the following: module foo; public func testX(int i) { return i + 1; } func void test() { printf(\"%d\", testX(2)); } The include may use an absolute or relative path, the relative path is always relative to the source file in which the include appears.","title":"Textual includes"},{"location":"moreexamples/","text":"More Examples Hello World import std::io; func void main() { io::printf(\"Hello world!\\n\"); } Fibonacci recursive func long fib(long n) { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); } HTTP Server import net::http_server; import net; func void! httpHandler(HttpContext* context) { context.response.contentType = \"text/plain\"; context.response.printf(\"Hello world!\\n\"); } func void main() { HttpServer server; server.init(); InetAddress! addr = server.bindPort(8080); catch (addr) { printf(\"Failed to open server.\\n\"); exit(-1); } printf(\"Begin listening to on http://%s\\n\", addr.description()); server.listen(&httpHandler); }","title":"More Examples"},{"location":"moreexamples/#more-examples","text":"","title":"More Examples"},{"location":"moreexamples/#hello-world","text":"import std::io; func void main() { io::printf(\"Hello world!\\n\"); }","title":"Hello World"},{"location":"moreexamples/#fibonacci-recursive","text":"func long fib(long n) { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); }","title":"Fibonacci recursive"},{"location":"moreexamples/#http-server","text":"import net::http_server; import net; func void! httpHandler(HttpContext* context) { context.response.contentType = \"text/plain\"; context.response.printf(\"Hello world!\\n\"); } func void main() { HttpServer server; server.init(); InetAddress! addr = server.bindPort(8080); catch (addr) { printf(\"Failed to open server.\\n\"); exit(-1); } printf(\"Begin listening to on http://%s\\n\", addr.description()); server.listen(&httpHandler); }","title":"HTTP Server"},{"location":"naming/","text":"Naming rules C3 introduces fairly strict naming rules to reduce ambiguity. As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character. Structs, unions, enums and errors All user defined types must start with A-Z after any optional initial _ and include at least 1 lower case letter. Bar , _T_i12 and TTi are all valid names. _1 , bAR and BAR are not. For C-compatibility it's possible to alias the type to a C name using the attribute \"cname\". struct Foo @cname(\"foo\") { int x; Bar bar; } union Bar { int i; double d; } enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS } Variables and parameters All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not. int theGlobal = 1; func void foo(int x) { Foo foo = getFoo(x); theGlobal++; } Global constants Global constants must start with A-Z after any optional initial _ . _FOO2 , BAR_FOO , X are all valid global constants, _ , _bar , x are not. const int A_VALUE = 12; Enum / error values Enum and error values follow the same naming standard as global constants. enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS } Struct / union members Struct and union members follow the same naming rules as variables. Modules Module names may contain a-z, 0-9 and _ , no upper case characters are allowed. module foo; Functions and macros Functions and macros must start with a-z after any optional initial _ . func void theMostAmazingFunction() { return; } macro justDoIt(x) { justDo(x); }","title":"Naming rules"},{"location":"naming/#naming-rules","text":"C3 introduces fairly strict naming rules to reduce ambiguity. As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character.","title":"Naming rules"},{"location":"naming/#structs-unions-enums-and-errors","text":"All user defined types must start with A-Z after any optional initial _ and include at least 1 lower case letter. Bar , _T_i12 and TTi are all valid names. _1 , bAR and BAR are not. For C-compatibility it's possible to alias the type to a C name using the attribute \"cname\". struct Foo @cname(\"foo\") { int x; Bar bar; } union Bar { int i; double d; } enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS }","title":"Structs, unions, enums and errors"},{"location":"naming/#variables-and-parameters","text":"All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not. int theGlobal = 1; func void foo(int x) { Foo foo = getFoo(x); theGlobal++; }","title":"Variables and parameters"},{"location":"naming/#global-constants","text":"Global constants must start with A-Z after any optional initial _ . _FOO2 , BAR_FOO , X are all valid global constants, _ , _bar , x are not. const int A_VALUE = 12;","title":"Global constants"},{"location":"naming/#enum-error-values","text":"Enum and error values follow the same naming standard as global constants. enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS }","title":"Enum / error values"},{"location":"naming/#struct-union-members","text":"Struct and union members follow the same naming rules as variables.","title":"Struct / union members"},{"location":"naming/#modules","text":"Module names may contain a-z, 0-9 and _ , no upper case characters are allowed. module foo;","title":"Modules"},{"location":"naming/#functions-and-macros","text":"Functions and macros must start with a-z after any optional initial _ . func void theMostAmazingFunction() { return; } macro justDoIt(x) { justDo(x); }","title":"Functions and macros"},{"location":"precedence/","text":"Precedence rules Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- @ , prefix - , prefix -% , ~ , prefix * , & , prefix ++ and -- infix * , / , % , *% << , >> ^ , | , infix & + , +% , infix - , infix -% == , != , >= , <= , > , < && , || ternary ?: try = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a || b && c a || (b && c) // C (&& binds tighter than ||) (a || b) && c // C3 (Same precedence, left-to-right evaluation) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 (Same precedence, left-to-right evaluation) a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 (Same precedence, left-to-right evaluation) The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of || and &&, relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence"},{"location":"precedence/#precedence-rules","text":"Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- @ , prefix - , prefix -% , ~ , prefix * , & , prefix ++ and -- infix * , / , % , *% << , >> ^ , | , infix & + , +% , infix - , infix -% == , != , >= , <= , > , < && , || ternary ?: try = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a || b && c a || (b && c) // C (&& binds tighter than ||) (a || b) && c // C3 (Same precedence, left-to-right evaluation) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 (Same precedence, left-to-right evaluation) a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 (Same precedence, left-to-right evaluation) The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of || and &&, relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence rules"},{"location":"preconditions/","text":"Pre and post conditions Pre and post conditions are optional checks that the compiler may use for optimization and runtime checks. Note that compilers are not obliged to process pre and post conditions at all . However, violating either pre or post conditions is considered undefined behaviour, so a compiler may optimize as if they always hold \u2013 even if a potential bug may cause them to be violated. Pre conditions Pre conditions are usually used to validate incoming arguments. Each condition must be an expression that can be evaluated to a boolean. A pre condition use the @require annotation. /** * @require foo > 0, foo < 1000 **/ func int testFoo(int foo) { return foo * 10; } Post conditions Post conditions are evaluated to make checks on the resulting state after passing through the function. There are two special post conditions: const and pure . The post condition uses the @ensure annotation. Where return is used to mark the return value from the function. For const and pure , they can either be given as separate annotations: @pure and @const <parameter>, ... , or inside an @ensure using the format const(<parameter>) and pure(<function name>) . A parameter marked const guarentees that the memory pointed to is not altered within the scope of a function. pure guarantees that the function does not read or write to any global variables. /** * @ensure foo != nil, const(foo), return > foo.x; * @pure **/ func uint checkFoo(Foo* foo) { uint y = abs(foo.x) + 1; // If we had row: foo.x = 0, then this would be a compile time error. return y * abs(foo.x); } Const in detail The const annotation allows a program to make assumtions in regards of how the function treats the parameter. This can then be used by a compiler make optimizations for any caller of the function. However, it should be noted that the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: func void badFunc(int* i) { *i = 2; } /** * @ensure const(i) */ func void lyingFunc(int* i) { badFunc(i); // The compiler might not check this! } func void test() { int a = 1; lyingFunc(&a); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: /** * @ensure const(i) */ func void badFunc(int* i) { *i = 2; // <- Compiler error: violating post condition const(i) } Pure in detail The pure annotation allows a program to make assumtions in regards of how the function treats global variables. Unlike for const , a pure function is not allowed to call a function which is known to be impure. However, just like for const the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: int i = 0; type SecretFunc func void(); func void badFunc() { i = 2; } SecretFunc foo = nil; /** * @pure */ func void lyingFunc() { SecretFunc(); // The compiler cannot reason about this! } func void test() { foo = &badFunc; i = 1; lyingFunc(); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: int i = 0; func void badFunc() { i = 2; } /** * @pure */ func void lyingFunc() { badFunc(); // Error! Calling an impure function } Consequently circumventing \"pure\" annotations is undefined behaviour. Pre conditions for macros Macros have an additional class of pre conditions, that are used to confirm that the values actually will work inside the macro body. This improves the error messages, since otherwise it would be hard to know if the error is in the implementation of the macro, or in the parameters. These are placed under the @reqparse annotation, or together with the @require annotations, surrounded by parse() . /** * @reqparse resource.open() * @require resource != nil, parse(void *x = resource.open()) **/ macro openResource(resource) { return resource.open(); }","title":"Pre and post conditions"},{"location":"preconditions/#pre-and-post-conditions","text":"Pre and post conditions are optional checks that the compiler may use for optimization and runtime checks. Note that compilers are not obliged to process pre and post conditions at all . However, violating either pre or post conditions is considered undefined behaviour, so a compiler may optimize as if they always hold \u2013 even if a potential bug may cause them to be violated.","title":"Pre and post conditions"},{"location":"preconditions/#pre-conditions","text":"Pre conditions are usually used to validate incoming arguments. Each condition must be an expression that can be evaluated to a boolean. A pre condition use the @require annotation. /** * @require foo > 0, foo < 1000 **/ func int testFoo(int foo) { return foo * 10; }","title":"Pre conditions"},{"location":"preconditions/#post-conditions","text":"Post conditions are evaluated to make checks on the resulting state after passing through the function. There are two special post conditions: const and pure . The post condition uses the @ensure annotation. Where return is used to mark the return value from the function. For const and pure , they can either be given as separate annotations: @pure and @const <parameter>, ... , or inside an @ensure using the format const(<parameter>) and pure(<function name>) . A parameter marked const guarentees that the memory pointed to is not altered within the scope of a function. pure guarantees that the function does not read or write to any global variables. /** * @ensure foo != nil, const(foo), return > foo.x; * @pure **/ func uint checkFoo(Foo* foo) { uint y = abs(foo.x) + 1; // If we had row: foo.x = 0, then this would be a compile time error. return y * abs(foo.x); }","title":"Post conditions"},{"location":"preconditions/#const-in-detail","text":"The const annotation allows a program to make assumtions in regards of how the function treats the parameter. This can then be used by a compiler make optimizations for any caller of the function. However, it should be noted that the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: func void badFunc(int* i) { *i = 2; } /** * @ensure const(i) */ func void lyingFunc(int* i) { badFunc(i); // The compiler might not check this! } func void test() { int a = 1; lyingFunc(&a); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: /** * @ensure const(i) */ func void badFunc(int* i) { *i = 2; // <- Compiler error: violating post condition const(i) }","title":"Const in detail"},{"location":"preconditions/#pure-in-detail","text":"The pure annotation allows a program to make assumtions in regards of how the function treats global variables. Unlike for const , a pure function is not allowed to call a function which is known to be impure. However, just like for const the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: int i = 0; type SecretFunc func void(); func void badFunc() { i = 2; } SecretFunc foo = nil; /** * @pure */ func void lyingFunc() { SecretFunc(); // The compiler cannot reason about this! } func void test() { foo = &badFunc; i = 1; lyingFunc(); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: int i = 0; func void badFunc() { i = 2; } /** * @pure */ func void lyingFunc() { badFunc(); // Error! Calling an impure function } Consequently circumventing \"pure\" annotations is undefined behaviour.","title":"Pure in detail"},{"location":"preconditions/#pre-conditions-for-macros","text":"Macros have an additional class of pre conditions, that are used to confirm that the values actually will work inside the macro body. This improves the error messages, since otherwise it would be hard to know if the error is in the implementation of the macro, or in the parameters. These are placed under the @reqparse annotation, or together with the @require annotations, surrounded by parse() . /** * @reqparse resource.open() * @require resource != nil, parse(void *x = resource.open()) **/ macro openResource(resource) { return resource.open(); }","title":"Pre conditions for macros"},{"location":"project/","text":"Customizing A Project A new project is provided with a barebone structure: [[executable]] # name of the target name = \"hello_world\" # version using semantic versioning version = \"0.1.0\" # authors, optionally with email authors = [\"John Doe <john.doe@example.com>\"] # language version of C3 langrev = \"1\" # warnings used warnings = [\"no-unused\"] # sources compiled sources = [\"src/**\"] # libraries to use libs = [\"lib/**\"] Libraries look a little different: [[static-lib]] name = \"graphics\" version = \"0.1.0\" authors = [\"John Doe <john.doe@example.com>\"] langrev = \"1\" warnings = [\"no-unused\"] sources = [\"src/**\"] # exported modules export = [\"api\"] Target options config Under the config you define external constants (\"key = value\") that will be included in compilation as if they were global macro constants. export Define the list of modules to be exported by a library. Not valid for executables. generate C3 defaults to generating C code that is then compiled and remove. Simply compile to C without further compilation by setting generate = \"C\" warnings List of warnings to enable during compilation. lib List of libraries to use when compiling the target. macro-recursion-depth Set the depth for recursion of macros. Typically set to a value around 10,000. Using environment variables In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Project Structure"},{"location":"project/#customizing-a-project","text":"A new project is provided with a barebone structure: [[executable]] # name of the target name = \"hello_world\" # version using semantic versioning version = \"0.1.0\" # authors, optionally with email authors = [\"John Doe <john.doe@example.com>\"] # language version of C3 langrev = \"1\" # warnings used warnings = [\"no-unused\"] # sources compiled sources = [\"src/**\"] # libraries to use libs = [\"lib/**\"] Libraries look a little different: [[static-lib]] name = \"graphics\" version = \"0.1.0\" authors = [\"John Doe <john.doe@example.com>\"] langrev = \"1\" warnings = [\"no-unused\"] sources = [\"src/**\"] # exported modules export = [\"api\"]","title":"Customizing A Project"},{"location":"project/#target-options","text":"","title":"Target options"},{"location":"project/#config","text":"Under the config you define external constants (\"key = value\") that will be included in compilation as if they were global macro constants.","title":"config"},{"location":"project/#export","text":"Define the list of modules to be exported by a library. Not valid for executables.","title":"export"},{"location":"project/#generate","text":"C3 defaults to generating C code that is then compiled and remove. Simply compile to C without further compilation by setting generate = \"C\"","title":"generate"},{"location":"project/#warnings","text":"List of warnings to enable during compilation.","title":"warnings"},{"location":"project/#lib","text":"List of libraries to use when compiling the target.","title":"lib"},{"location":"project/#macro-recursion-depth","text":"Set the depth for recursion of macros. Typically set to a value around 10,000.","title":"macro-recursion-depth"},{"location":"project/#using-environment-variables","text":"In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Using environment variables"},{"location":"reflection/","text":"Reflection C3 allows both compile time and runtime reflection. During compile time the type information may be directly used as compile time constants, the same data is then available dynamically. Compile time reflection During compile time there are a number of compile time fields that may be accessed directly. Compile time variables typeid Returns the typeid for the given type. Typedefs will return the typeid of the underlying type. typeid x = Foo.typeid; nameof The basic name of the type without module prefixes. struct Foo { ... } typedef Foo as Bar; string a = int[4].nameof; // => \"int[4]\" string b = Foo.nameof; // => \"Foo\" string c = Bar.nameof; // => \"Foo\" qnameof Same as the name, but includes the full module path: e.g. \"baz::bar::Foo\". module bar; struct Foo { ... } string a = int[4].qnameof; // => \"int[4]\" string b = Foo.qnameof; // => \"bar::Foo\" string c = Foo[4].qnameof; // => \"bar::Foo[4]\" sizeof Returns the size in bytes needed to store the type. struct Foo { long a; long b; } usize x = Foo.sizeof; // 16 usize y = int.sizeof; // 4 alignof Returns the alignment in bytes needed for the type. struct Foo { long a; int b; } usize x = Foo.alignof; // 8 usize y = int.alignof; // 4 kindof Returns the TypeKind of the variable. struct Foo { ... } union Bar { ... } TypeKind a = Foo.kindof; // STRUCT TypeKind b = Bar.kindof; // BAR TypeKind c = int.kindof; // INTEGER elementType Only available for array, vararray and subarray types. Returns the element (underlying) type of an array, vararray or subarray. struct Foo { ... } string x = Foo[].elementType.name; // \"Foo\" string y = Foo[4].elementType.name; // \"Foo\" string z = Foo[*].elementType.name; // \"Foo\" baseType Only available for pointer types and failables. Returns the type the pointer points to. E.g. for int* the base type is int . struct Foo { ... } string x = (Foo*).baseType.name; // \"Foo\" elements Only available for enum types. Returns an array containing the enum values in an enum. enum Foo { BAR, BAZ } string x = Foo.elements[0].name; // \"BAR\" errors Only available for error types. Returns an array containing the error values in an enum. error FooErr { BAD_BAR, NO_BAZ } string x = Foo.errors[0].name; // \"BAD_BAR\" fields Only available for struct types. Returns an array containing the fields in a struct. struct Foo { int x; Foo* z; } string x = Foo.fields[1].name; // \"z\" variants Only available for union types. Returns an array of types representing the possible variants of the union. union Foo { int x; Foo* z; double d; } string x = Foo.variants[2].name; // \"d\" signed Only available for integer types. Returns true for a signed number. bool s1 = int.signed; // => true bool s2 = uint.signed; // => false length Only available for array types. Returns the length of the array. usize len = int[4].length associatedValues Only available for enums. Returns an array containing the types of associated values if any. enum Foo : int(double d, string s) { BAR(1.0, \"normal\"), BAZ(2.0, \"exceptional\") } string s = Foo.associatedValues[0].name; // \"double\" returnType Only available for function types. Returns the type of the return type. typedef func int(int, double) as TestFunc; string s = TestFunc.returnType.name; // \"int\" params Only available for function types. Returns a list of all parameters. typedef func int(int, double) as TestFunc; string s = TestFunc.params[1].name; // \"double\" errors Only available for functions. Returns a list containing all errors returned, or nil otherwise. An empty list is returned on not returning. error SomeError { ... } error SomeOtherError { ... } func void! foo() { if (someReason()) return SomeError!; try bar(); } func void! bar() { return SomeOtherError!; } string s = foo.errors[1].name; // \"SomeOtherError\" int errors = bar.errors.size == 1; Runtime reflection During runtime it's also possible to retrieve information by way of a typeid. Using typeid may implicitly cast into a TypeInfo * . This is a struct that contains data for the underlying type: struct TypeData { typeid typeId; TypeKind kind; int size; int alignment; char* name; char* fullName; } This structure is the base type, and the actual struct will can be TypeError , TypeArray , TypeInteger and so on. The definition of these are found in the module system::builtin . The builtin module further offers several ways to search for different types, returning the TypeData * directly: functionByName structByName unionByName enumByName typeByName errorByName opaqueByName moduleByName The TypeData substructs further offers functions for retrieving fields by name and other conveniences. TypeKind The TypeKind enum contains the basic kinds of types: VOID INTEGER REAL BOOL POINTER UNION ENUM ERROR ARRAY VARARRAY SUBARRAY FUNC TYPEID STRING OPAQUE FAILABLE","title":"Reflection"},{"location":"reflection/#reflection","text":"C3 allows both compile time and runtime reflection. During compile time the type information may be directly used as compile time constants, the same data is then available dynamically.","title":"Reflection"},{"location":"reflection/#compile-time-reflection","text":"During compile time there are a number of compile time fields that may be accessed directly.","title":"Compile time reflection"},{"location":"reflection/#compile-time-variables","text":"","title":"Compile time variables"},{"location":"reflection/#typeid","text":"Returns the typeid for the given type. Typedefs will return the typeid of the underlying type. typeid x = Foo.typeid;","title":"typeid"},{"location":"reflection/#nameof","text":"The basic name of the type without module prefixes. struct Foo { ... } typedef Foo as Bar; string a = int[4].nameof; // => \"int[4]\" string b = Foo.nameof; // => \"Foo\" string c = Bar.nameof; // => \"Foo\"","title":"nameof"},{"location":"reflection/#qnameof","text":"Same as the name, but includes the full module path: e.g. \"baz::bar::Foo\". module bar; struct Foo { ... } string a = int[4].qnameof; // => \"int[4]\" string b = Foo.qnameof; // => \"bar::Foo\" string c = Foo[4].qnameof; // => \"bar::Foo[4]\"","title":"qnameof"},{"location":"reflection/#sizeof","text":"Returns the size in bytes needed to store the type. struct Foo { long a; long b; } usize x = Foo.sizeof; // 16 usize y = int.sizeof; // 4","title":"sizeof"},{"location":"reflection/#alignof","text":"Returns the alignment in bytes needed for the type. struct Foo { long a; int b; } usize x = Foo.alignof; // 8 usize y = int.alignof; // 4","title":"alignof"},{"location":"reflection/#kindof","text":"Returns the TypeKind of the variable. struct Foo { ... } union Bar { ... } TypeKind a = Foo.kindof; // STRUCT TypeKind b = Bar.kindof; // BAR TypeKind c = int.kindof; // INTEGER","title":"kindof"},{"location":"reflection/#elementtype","text":"Only available for array, vararray and subarray types. Returns the element (underlying) type of an array, vararray or subarray. struct Foo { ... } string x = Foo[].elementType.name; // \"Foo\" string y = Foo[4].elementType.name; // \"Foo\" string z = Foo[*].elementType.name; // \"Foo\"","title":"elementType"},{"location":"reflection/#basetype","text":"Only available for pointer types and failables. Returns the type the pointer points to. E.g. for int* the base type is int . struct Foo { ... } string x = (Foo*).baseType.name; // \"Foo\"","title":"baseType"},{"location":"reflection/#elements","text":"Only available for enum types. Returns an array containing the enum values in an enum. enum Foo { BAR, BAZ } string x = Foo.elements[0].name; // \"BAR\"","title":"elements"},{"location":"reflection/#errors","text":"Only available for error types. Returns an array containing the error values in an enum. error FooErr { BAD_BAR, NO_BAZ } string x = Foo.errors[0].name; // \"BAD_BAR\"","title":"errors"},{"location":"reflection/#fields","text":"Only available for struct types. Returns an array containing the fields in a struct. struct Foo { int x; Foo* z; } string x = Foo.fields[1].name; // \"z\"","title":"fields"},{"location":"reflection/#variants","text":"Only available for union types. Returns an array of types representing the possible variants of the union. union Foo { int x; Foo* z; double d; } string x = Foo.variants[2].name; // \"d\"","title":"variants"},{"location":"reflection/#signed","text":"Only available for integer types. Returns true for a signed number. bool s1 = int.signed; // => true bool s2 = uint.signed; // => false","title":"signed"},{"location":"reflection/#length","text":"Only available for array types. Returns the length of the array. usize len = int[4].length","title":"length"},{"location":"reflection/#associatedvalues","text":"Only available for enums. Returns an array containing the types of associated values if any. enum Foo : int(double d, string s) { BAR(1.0, \"normal\"), BAZ(2.0, \"exceptional\") } string s = Foo.associatedValues[0].name; // \"double\"","title":"associatedValues"},{"location":"reflection/#returntype","text":"Only available for function types. Returns the type of the return type. typedef func int(int, double) as TestFunc; string s = TestFunc.returnType.name; // \"int\"","title":"returnType"},{"location":"reflection/#params","text":"Only available for function types. Returns a list of all parameters. typedef func int(int, double) as TestFunc; string s = TestFunc.params[1].name; // \"double\"","title":"params"},{"location":"reflection/#errors_1","text":"Only available for functions. Returns a list containing all errors returned, or nil otherwise. An empty list is returned on not returning. error SomeError { ... } error SomeOtherError { ... } func void! foo() { if (someReason()) return SomeError!; try bar(); } func void! bar() { return SomeOtherError!; } string s = foo.errors[1].name; // \"SomeOtherError\" int errors = bar.errors.size == 1;","title":"errors"},{"location":"reflection/#runtime-reflection","text":"During runtime it's also possible to retrieve information by way of a typeid. Using typeid may implicitly cast into a TypeInfo * . This is a struct that contains data for the underlying type: struct TypeData { typeid typeId; TypeKind kind; int size; int alignment; char* name; char* fullName; } This structure is the base type, and the actual struct will can be TypeError , TypeArray , TypeInteger and so on. The definition of these are found in the module system::builtin . The builtin module further offers several ways to search for different types, returning the TypeData * directly: functionByName structByName unionByName enumByName typeByName errorByName opaqueByName moduleByName The TypeData substructs further offers functions for retrieving fields by name and other conveniences.","title":"Runtime reflection"},{"location":"reflection/#typekind","text":"The TypeKind enum contains the basic kinds of types: VOID INTEGER REAL BOOL POINTER UNION ENUM ERROR ARRAY VARARRAY SUBARRAY FUNC TYPEID STRING OPAQUE FAILABLE","title":"TypeKind"},{"location":"rejectedideas/","text":"Rejected ideas These are ideas that will not be implemented in C3 with rationale given. Constructors and destructors A fundamental concept in C3 is that data is not \"active\". This is to say there is no code associated with the data implicitly unlike constructors and destructors in an object oriented language. Not having constructors / destructors prevents RAII-style resource handling, but also allows the code to assume the memory can be freely allocated and initialized as it sees fit, without causing any corruption or undefined behaviour. There is a fundamental difference between active objects and inert data, each has its advantages and disadvantages. C3 follows the C model, which is that data is passive and does not enforce any behaviour. This has very deep implications on the semantics of the language and adding constructors and destructors would change the language greatly, requiring modification of many parts of the language altering. For that reason constructors and destructors will not be considered for C3. Unicode identifiers The main argument for unicode identifiers is that \"it allows people to code in their own language\". However, there is no proof that this actually is used in practice. Furthermore there are practical issues, such as bidirectional text, characters with different code points that are rendered in an identical way etc. Given the complexity and the lack of actual proven benefit, unicode identifiers will not happen for C3.","title":"Rejected ideas"},{"location":"rejectedideas/#rejected-ideas","text":"These are ideas that will not be implemented in C3 with rationale given.","title":"Rejected ideas"},{"location":"rejectedideas/#constructors-and-destructors","text":"A fundamental concept in C3 is that data is not \"active\". This is to say there is no code associated with the data implicitly unlike constructors and destructors in an object oriented language. Not having constructors / destructors prevents RAII-style resource handling, but also allows the code to assume the memory can be freely allocated and initialized as it sees fit, without causing any corruption or undefined behaviour. There is a fundamental difference between active objects and inert data, each has its advantages and disadvantages. C3 follows the C model, which is that data is passive and does not enforce any behaviour. This has very deep implications on the semantics of the language and adding constructors and destructors would change the language greatly, requiring modification of many parts of the language altering. For that reason constructors and destructors will not be considered for C3.","title":"Constructors and destructors"},{"location":"rejectedideas/#unicode-identifiers","text":"The main argument for unicode identifiers is that \"it allows people to code in their own language\". However, there is no proof that this actually is used in practice. Furthermore there are practical issues, such as bidirectional text, characters with different code points that are rendered in an identical way etc. Given the complexity and the lack of actual proven benefit, unicode identifiers will not happen for C3.","title":"Unicode identifiers"},{"location":"sample/","text":"Sample Here is a bit of code manually converted to C3 from C. struct Node { uint hole; uint size; Node* next; Node* prev; } struct Footer { Node *header; } struct Bin { Node* head; } struct Heap { size start; size end; Bin* bins[BIN_COUNT]; } const uint OFFSET = 8; /** * @require heap != nil, start > 0 */ void Heap.init(Heap* heap, usize start) { Node* init_region = cast(start as Node*); init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - @sizeof(Node) - @sizeof(Footer); init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = cast(start as void*); heap.end = cast(start + HEAP_INIT_SIZE as void*); } void* Heap.alloc(Heap* heap, usize size) { uint index = get_bin_index(size); Bin* temp = cast(heap.bins[index] as Bin*); Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node* split = cast(cast(found as char*) + sizeof(Node) + sizeof(Footer) as Node*) + size); split.size = found.size - size - sizeof(Node) - sizeof(Footer); split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node* wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ func void Heap.free(Heap* heap, void *p) { Bin* list; Footer& new_foot, old_foot; Node* head = cast(cast(p as char*) - OFFSET as Node); if (head == cast(cast(heap.start as usize) as Node*) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node* next = cast(cast(head.getFoot() as char*) + sizeof(Footer) as Node*); Footer* f = cast(cast(head as char*) - sizeof(Footer) as Footer*); Node* prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } func uint Heap.expand(Heap* heap, usize sz) { return 0; } func void Heap.contract(Heap* heap, usize sz) { return; } func uint get_bin_index(usize sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } func void Node.createFoot(Node* head) { Footer* foot = head.getFoot(); foot.header = head; } func Footer* Node.getFoot(Node* node) { return cast(cast(node as char*) + sizeof(Node) + node.size as Footer*); } func Node* getWilderness(Heap* heap) { Footer* wild_foot = cast(cast(heap.end as char*) - sizeof(Footer) as Footer*); return wild_foot.header; }","title":"More code examples"},{"location":"sample/#sample","text":"Here is a bit of code manually converted to C3 from C. struct Node { uint hole; uint size; Node* next; Node* prev; } struct Footer { Node *header; } struct Bin { Node* head; } struct Heap { size start; size end; Bin* bins[BIN_COUNT]; } const uint OFFSET = 8; /** * @require heap != nil, start > 0 */ void Heap.init(Heap* heap, usize start) { Node* init_region = cast(start as Node*); init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - @sizeof(Node) - @sizeof(Footer); init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = cast(start as void*); heap.end = cast(start + HEAP_INIT_SIZE as void*); } void* Heap.alloc(Heap* heap, usize size) { uint index = get_bin_index(size); Bin* temp = cast(heap.bins[index] as Bin*); Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node* split = cast(cast(found as char*) + sizeof(Node) + sizeof(Footer) as Node*) + size); split.size = found.size - size - sizeof(Node) - sizeof(Footer); split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node* wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ func void Heap.free(Heap* heap, void *p) { Bin* list; Footer& new_foot, old_foot; Node* head = cast(cast(p as char*) - OFFSET as Node); if (head == cast(cast(heap.start as usize) as Node*) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node* next = cast(cast(head.getFoot() as char*) + sizeof(Footer) as Node*); Footer* f = cast(cast(head as char*) - sizeof(Footer) as Footer*); Node* prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } func uint Heap.expand(Heap* heap, usize sz) { return 0; } func void Heap.contract(Heap* heap, usize sz) { return; } func uint get_bin_index(usize sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } func void Node.createFoot(Node* head) { Footer* foot = head.getFoot(); foot.header = head; } func Footer* Node.getFoot(Node* node) { return cast(cast(node as char*) + sizeof(Node) + node.size as Footer*); } func Node* getWilderness(Heap* heap) { Footer* wild_foot = cast(cast(heap.end as char*) - sizeof(Footer) as Footer*); return wild_foot.header; }","title":"Sample"},{"location":"setup/","text":"Setup C3 is not ready for end users yet, but should be possible to get it up and running on any platform that LLVM can compile on. You will need CMake installed. 1. Install LLVM See LLVM the LLVM documentation on how to set up LLVM 10 for development. On OS X, installing through Homebrew works fine. Using apt-get on Linux should work fine as well. 2. Clone the C3 compiler source code from Github This should be as simple as doing: git clone https://github.com/c3lang/c3c.git ... from the command line. 3. Build the compiler Create the build directory: MyMachine:c3c$ mkdir build MyMachine:c3c$ cd build/ Use CMake to set up: MyMachine:c3c/build$ cmake ../ Build the compiler: MyMachine:c3c/build$ make 4. Test it out MyMachine:c3c/build$ ./c3c compile ../resources/testfragments/helloworld.c3","title":"Setup"},{"location":"setup/#setup","text":"C3 is not ready for end users yet, but should be possible to get it up and running on any platform that LLVM can compile on. You will need CMake installed.","title":"Setup"},{"location":"setup/#1-install-llvm","text":"See LLVM the LLVM documentation on how to set up LLVM 10 for development. On OS X, installing through Homebrew works fine. Using apt-get on Linux should work fine as well.","title":"1. Install LLVM"},{"location":"setup/#2-clone-the-c3-compiler-source-code-from-github","text":"This should be as simple as doing: git clone https://github.com/c3lang/c3c.git ... from the command line.","title":"2. Clone the C3 compiler source code from Github"},{"location":"setup/#3-build-the-compiler","text":"Create the build directory: MyMachine:c3c$ mkdir build MyMachine:c3c$ cd build/ Use CMake to set up: MyMachine:c3c/build$ cmake ../ Build the compiler: MyMachine:c3c/build$ make","title":"3. Build the compiler"},{"location":"setup/#4-test-it-out","text":"MyMachine:c3c/build$ ./c3c compile ../resources/testfragments/helloworld.c3","title":"4. Test it out"},{"location":"specialfunctions/","text":"Built in functions C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc abs Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long) byteswap Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long) bitreverse Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long) ceil Return the closest integral number, rounded up. float ceilf(float) double ceil(double) clz Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong) cos Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad) ctz Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"Built in functions"},{"location":"specialfunctions/#built-in-functions","text":"C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc","title":"Built in functions"},{"location":"specialfunctions/#abs","text":"Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long)","title":"abs"},{"location":"specialfunctions/#byteswap","text":"Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long)","title":"byteswap"},{"location":"specialfunctions/#bitreverse","text":"Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long)","title":"bitreverse"},{"location":"specialfunctions/#ceil","text":"Return the closest integral number, rounded up. float ceilf(float) double ceil(double)","title":"ceil"},{"location":"specialfunctions/#clz","text":"Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong)","title":"clz"},{"location":"specialfunctions/#cos","text":"Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad)","title":"cos"},{"location":"specialfunctions/#ctz","text":"Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"ctz"},{"location":"specification/","text":"Specification THIS SPECIFICATION IS UNDER DEVELOPMENT Notation The syntax is specified using Extended Backus-Naur Form (EBNF): production ::= PRODUCTION_NAME '::=' expression? expression ::= alternative (\"|\" alternative)* alternative ::= term term* term ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition set ::= '[' (range | CHAR) (rang | CHAR)* ']' range ::= CHAR '-' CHAR group ::= '(' expression ')' option ::= expression '?' repetition ::= expression '*' Productions are expressions constructed from terms and the following operators, in increasing precedence: | alternation () grouping ? option (0 or 1 times) * repetition (0 to n times) Uppercase production names are used to identify lexical tokens. Non-terminals are in lower case. Lexical tokens are enclosed in single quotes ''. The form a..b represents the set of characters from a through b as alternatives. Source code representation A program consists of one or more translation units stored in files written in the Unicode character set, stored as a sequence of bytes using the UTF-8 encoding. Except for comments and the contents of character and string literals, all input elements are formed only from the ASCII subset (U+0000 to U+007F) of Unicode. A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar. Lexical Translations A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar. The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would. Example: a--b is translated as a , -- , b , which does not form a grammatically correct expression, even >though the tokenization a , - , - , b could form a grammatically correct expression. Line Terminators The C3 compiler divides the sequence of input bytes into lines by recognizing line terminators Lines are terminated by the ASCII LF character (U+000A), also known as \"newline\". A line termination specifies the termination of the // form of a comment. Input Elements and Tokens An input element may be: White space Comment Doc Comment Token A token may be: Identifier Keyword Literal Separator Operator A Doc Comment consists of: A stream of descriptive text A list of directive Tokens Those input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the syntactic grammar. Whitespace and comments can serve to separate tokens that might be tokenized in another manner. For example the characters + and = may form the operator token += only if there is no intervening white space or comment. White Space White space is defined as the ASCII CR (U+000D), the ASCII horizontal tab character (U+0009) and the space character (U+0020) and the line terminator character. WHITESPACE ::= [ \\t\\v\\n\\f] Letters and digits UC_LETTER ::= [A-Z] LC_LETTER ::= [a-z] LETTER ::= UC_LETTER | LC_LETTER DIGIT ::= [0-9] HEX_DIGIT ::= [0-9a-fA-F] BINARY_DIGIT ::= [01] OCTAL_DIGIT ::= [0-7] UC_LETTER_US ::= UC_LETTER | \"_\" ALPHANUM ::= LETTER | DIGIT ALPHANUM_US ::= ALPHANUM | \"_\" UC_ALPHANUM_US ::= UC_LETTER_US | DIGIT Comments Thre are three types of regular comments: /* text */ block comments. The text between /* and */ is ignored. // text a line comment. The text between // and line end is ignored. /+ text +/ nesting comments. The text between /+ and +/ is ignored. Unlike /* text */ it has nesting behaviour, so for every /+ discovered between the first /+ and the last +/ a corresponding +/ must be found. Doc comments /** text **/ doc block comment. The text between /** and **/ is optionally parsed using the doc comment syntatic grammar. A compiler may choose to read /** text **/ as a regular comment. /// text doc line comment. The text between /// and line end is optionally parsed using the doc comment syntactic grammar. A compiler may choose to read /// as a regular comment. Identifiers Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter or underscore. C3 has three types of identifiers: const identifiers - containing only underscore and upper-case letters, type identifiers - starting with an upper case letter followed by at least one underscore letter and regular identifiers, starting with a lower case letter. IDENTIFIER ::= \"_\"* LC_LETTER ALPHANUM_US* CONST_IDENT ::= \"_\"* UC_LETTER UC_ALPHANUM_US* TYPE_IDENT ::= \"_\"* UC_LETTER \"_\"* LC_LETTER ALPHANUM_US* CT_IDENT ::= \"$\" IDENTIFIER CT_CONST_IDENT ::= \"$\" CONST_IDENT CT_TYPE_IDENT ::= \"$\" TYPE_IDENT Keywords The following keywords are reserved and may not be used as identifiers: alias as asm assert attribute break case cast catch const continue default defer define do else enum extern error false func generic if import in local macro module nextcase nil public return struct switch true try typeid typeof typedef var volatile void while bool quad double float long ulong int uint byte short ushort char isize usize half $assert $case $default $if $for $else $elif $if $switch $foreach $endswitch $endif $endforeach $unreachable Operators and punctuation The following character sequences represent operators and punctuation. & @ ~ | ^ : , / $ . ; ) > < # { } - ( ) * [ ] % >= <= + += -= ! ? ?: && -> &= |= ^= /= .. == ({ }) -% +% *% ++ -- %= != || :: << >> !! ... *%= +%= -%= <<= >>= Integer literals An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. INTEGER ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT DECIMAL_LIT ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)? BINARY_LIT ::= '0' [bB] '_'* BINARY_DIGITS OCTAL_LIT ::= '0' [oO] '_'* OCTAL_DIGITS HEX_LIT ::= '0' [xX] '_'* HEX_DIGITS BINARY_DIGIT ::= [01] HEX_DIGIT ::= [0-9a-fA-F] DECIMAL_DIGITS ::= DIGIT ('_'* DIGIT)* BINARY_DIGITS ::= BINARY_DIGIT ('_'* BINARY_DIGIT)* OCTAL_DIGITS ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)* HEX_DIGITS ::= HEX_DIGIT ('_'* HEX_DIGIT)* 42 4_2 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 0600 // Invalid, non zero decimal number may not start with 0 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 0_xBadFace // invalid: _ must separate successive digits Floating point literals A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by powers of 10. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. An exponent value exp scales the mantissa (integer and fractional part) by powers of 2. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. FLOAT_LIT ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT DEC_FLOAT_LIT ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? | DECIMAL_DIGITS DEC_EXPONENT | '.' DECIMAL_DIGITS DEC_EXPONENT? DEC_EXPONENT ::= [eE] [+-]? DECIMAL_DIGITS HEX_FLOAT_LIT ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT HEX_MANTISSA ::= HEX_DIGITS '.' HEX_DIGITS? | HEX_DIGITS | '.' HEX_DIGITS HEX_EXPONENT ::= [pP] [+-] DECIMAL_DIGITS Character literals A character literal represents a constant value of 1, 2, 4 or 8 bytes, and may only be printable ASCII characters (U+0020 - U+007F). Each character is intepreted as part of an 1, 2, 4 or 8 byte integer constant. Escape sequences can be used to represent byte values 0-31 and 128-255. A 2 byte literal is referred to as a 2cc literal, a 4 byte literal 4cc and an eight byte literal is called 8cc. We will commonly refer to a single byte character literal as just \"character literal\". The following backslash escapes are available to escape: \\0 0x00 zero value \\a 0x07 alert/bell \\b 0x08 backspace \\e 0x1B escape \\f 0x0C form feed \\n 0x0A newline \\r 0x0D carriage return \\t 0x09 horizontal tab \\v 0x0B vertical tab \\\\ 0x5C backslash \\' 0x27 single quote ' \\\" 0x22 double quote \" \\x Escapes a single byte hex value \\u Escapes a two byte hex value \\U Escapes a four byte hex value CHAR_ELEMENT ::= [\\x20-\\x26] | [\\x28-\\x5B] | [\\x5D-\\x7F] CHAR_LIT_BYTE ::= CHAR_ELEMENT | \\x5C CHAR_ESCAPE CHAR_ESCAPE ::= [abefnrtv\\'\\\"\\\\] | 'x' HEX_DIGIT HEX_DIGIT | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT CHARACTER_LIT ::= \"'\" CHAR_LIT_BYTE \"'\" TWOCC_LIT ::= \"'\" CHAR_LIT_BYTE CHAR_LIT_BYTE \"'\" FOURCC_LIT ::= \"'\" CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE \"'\" EIGHTCC_LIT ::= \"'\" CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE \"'\" String literals A string literal represents a string constant obtained from concatenating a sequence of characters. String literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals, with the same restrictions. The two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. STRING_LIT ::= \\x22 CHAR_LIT_BYTE* \\x22 Types Boolean types Integer types Floating point types Vector types Complex types A complex type is defined as a struct with two elements of the same floating point type. The first member holds the real part of a complex number, and the second member holds the imaginary part. struct Complex { float real; float imaginary; } String types Array types An array has the alignment of its element. Zero sized arrays are allowed and have the size 0. Vararray types Subarray types The subarray consist of a pointer, followed by a usize length, having the alignment of pointers. Pointer types Struct types A struct without any members or with only arrays of size 0 have the size 0. The alignment of a struct without any members is 1. Union types The alignment of a union without any members is 1. Error types Th Enum types Function types Virtual types Declarations and scope Expressions Casts Pointer casts Integer to pointer cast Any integer of pointer size or larger may be explicitly cast to a pointer. An integer to pointer cast is considered non-constant, except in the special case where the integer == 0. In that case, the result is constant null . Example: byte a = 1; int* b = cast(a as int*); // Invalid, pointer type is > 8 bits. int* c = cast(1 as int*); // Valid, but runtime value. int* d = cast(0 as int*); // Valid and constant value. Pointer to integer cast A pointer may be cast to any integer, truncating the pointer value if the size of the pointer is larger than the pointer size. A pointer to integer cast is considered non-constant, except in the special case of a null pointer, where it is equal to the integer value 0. Example: func void test() { ... } typedef func void test() as VoidFunc; VoidFunc a = &test; int b = cast(null as int); int c = cast(a as int); // Invalid, not constant int d = cast(cast(1 as int*) as int); // Invalid, not constant Subscript operator The subscript operator may take as its left side a pointer, array, subarray or vararray. The index may be of any integer type. TODO NOTE The subscript operator is not symmetrical as in C. For example in C3 array[n] = 33 is allowed, but not n[array] = 33 . This is a change from C. Operands Compound Literals Compound literals have the format compound_literal ::= TYPE_IDENTIFIER '(' initializer_list ')' initializer_list ::= '{' (initializer_param (',' initializer_param)* ','?)? '}' initializer_param ::= expression | designator '=' expression designator ::= array_designator | range_designator | field_designator array_designator ::= '[' expression ']' range_designator ::= '[' range_expression ']' field_designator ::= IDENTIFIER range_expression ::= (range_index)? '..' (range_index)? range_index ::= expression | '^' expression Taking the address of a compound literal will yield a pointer to stack allocated temporary. Function calls Varargs For varargs, a bool or any integer smaller than what the C ABI specifies for the c int type is cast to int . Any float smaller than a double is cast to double . Compile time floats will be cast to double. Compile time integers will be cast to c int type. Statements If statement Switch stat Modules","title":"Specification"},{"location":"specification/#specification","text":"THIS SPECIFICATION IS UNDER DEVELOPMENT","title":"Specification"},{"location":"specification/#notation","text":"The syntax is specified using Extended Backus-Naur Form (EBNF): production ::= PRODUCTION_NAME '::=' expression? expression ::= alternative (\"|\" alternative)* alternative ::= term term* term ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition set ::= '[' (range | CHAR) (rang | CHAR)* ']' range ::= CHAR '-' CHAR group ::= '(' expression ')' option ::= expression '?' repetition ::= expression '*' Productions are expressions constructed from terms and the following operators, in increasing precedence: | alternation () grouping ? option (0 or 1 times) * repetition (0 to n times) Uppercase production names are used to identify lexical tokens. Non-terminals are in lower case. Lexical tokens are enclosed in single quotes ''. The form a..b represents the set of characters from a through b as alternatives.","title":"Notation"},{"location":"specification/#source-code-representation","text":"A program consists of one or more translation units stored in files written in the Unicode character set, stored as a sequence of bytes using the UTF-8 encoding. Except for comments and the contents of character and string literals, all input elements are formed only from the ASCII subset (U+0000 to U+007F) of Unicode. A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar.","title":"Source code representation"},{"location":"specification/#lexical-translations","text":"A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar. The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would. Example: a--b is translated as a , -- , b , which does not form a grammatically correct expression, even >though the tokenization a , - , - , b could form a grammatically correct expression.","title":"Lexical Translations"},{"location":"specification/#line-terminators","text":"The C3 compiler divides the sequence of input bytes into lines by recognizing line terminators Lines are terminated by the ASCII LF character (U+000A), also known as \"newline\". A line termination specifies the termination of the // form of a comment.","title":"Line Terminators"},{"location":"specification/#input-elements-and-tokens","text":"An input element may be: White space Comment Doc Comment Token A token may be: Identifier Keyword Literal Separator Operator A Doc Comment consists of: A stream of descriptive text A list of directive Tokens Those input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the syntactic grammar. Whitespace and comments can serve to separate tokens that might be tokenized in another manner. For example the characters + and = may form the operator token += only if there is no intervening white space or comment.","title":"Input Elements and Tokens"},{"location":"specification/#white-space","text":"White space is defined as the ASCII CR (U+000D), the ASCII horizontal tab character (U+0009) and the space character (U+0020) and the line terminator character. WHITESPACE ::= [ \\t\\v\\n\\f]","title":"White Space"},{"location":"specification/#letters-and-digits","text":"UC_LETTER ::= [A-Z] LC_LETTER ::= [a-z] LETTER ::= UC_LETTER | LC_LETTER DIGIT ::= [0-9] HEX_DIGIT ::= [0-9a-fA-F] BINARY_DIGIT ::= [01] OCTAL_DIGIT ::= [0-7] UC_LETTER_US ::= UC_LETTER | \"_\" ALPHANUM ::= LETTER | DIGIT ALPHANUM_US ::= ALPHANUM | \"_\" UC_ALPHANUM_US ::= UC_LETTER_US | DIGIT","title":"Letters and digits"},{"location":"specification/#comments","text":"Thre are three types of regular comments: /* text */ block comments. The text between /* and */ is ignored. // text a line comment. The text between // and line end is ignored. /+ text +/ nesting comments. The text between /+ and +/ is ignored. Unlike /* text */ it has nesting behaviour, so for every /+ discovered between the first /+ and the last +/ a corresponding +/ must be found.","title":"Comments"},{"location":"specification/#doc-comments","text":"/** text **/ doc block comment. The text between /** and **/ is optionally parsed using the doc comment syntatic grammar. A compiler may choose to read /** text **/ as a regular comment. /// text doc line comment. The text between /// and line end is optionally parsed using the doc comment syntactic grammar. A compiler may choose to read /// as a regular comment.","title":"Doc comments"},{"location":"specification/#identifiers","text":"Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter or underscore. C3 has three types of identifiers: const identifiers - containing only underscore and upper-case letters, type identifiers - starting with an upper case letter followed by at least one underscore letter and regular identifiers, starting with a lower case letter. IDENTIFIER ::= \"_\"* LC_LETTER ALPHANUM_US* CONST_IDENT ::= \"_\"* UC_LETTER UC_ALPHANUM_US* TYPE_IDENT ::= \"_\"* UC_LETTER \"_\"* LC_LETTER ALPHANUM_US* CT_IDENT ::= \"$\" IDENTIFIER CT_CONST_IDENT ::= \"$\" CONST_IDENT CT_TYPE_IDENT ::= \"$\" TYPE_IDENT","title":"Identifiers"},{"location":"specification/#keywords","text":"The following keywords are reserved and may not be used as identifiers: alias as asm assert attribute break case cast catch const continue default defer define do else enum extern error false func generic if import in local macro module nextcase nil public return struct switch true try typeid typeof typedef var volatile void while bool quad double float long ulong int uint byte short ushort char isize usize half $assert $case $default $if $for $else $elif $if $switch $foreach $endswitch $endif $endforeach $unreachable","title":"Keywords"},{"location":"specification/#operators-and-punctuation","text":"The following character sequences represent operators and punctuation. & @ ~ | ^ : , / $ . ; ) > < # { } - ( ) * [ ] % >= <= + += -= ! ? ?: && -> &= |= ^= /= .. == ({ }) -% +% *% ++ -- %= != || :: << >> !! ... *%= +%= -%= <<= >>=","title":"Operators and punctuation"},{"location":"specification/#integer-literals","text":"An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. INTEGER ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT DECIMAL_LIT ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)? BINARY_LIT ::= '0' [bB] '_'* BINARY_DIGITS OCTAL_LIT ::= '0' [oO] '_'* OCTAL_DIGITS HEX_LIT ::= '0' [xX] '_'* HEX_DIGITS BINARY_DIGIT ::= [01] HEX_DIGIT ::= [0-9a-fA-F] DECIMAL_DIGITS ::= DIGIT ('_'* DIGIT)* BINARY_DIGITS ::= BINARY_DIGIT ('_'* BINARY_DIGIT)* OCTAL_DIGITS ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)* HEX_DIGITS ::= HEX_DIGIT ('_'* HEX_DIGIT)* 42 4_2 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 0600 // Invalid, non zero decimal number may not start with 0 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 0_xBadFace // invalid: _ must separate successive digits","title":"Integer literals"},{"location":"specification/#floating-point-literals","text":"A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by powers of 10. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. An exponent value exp scales the mantissa (integer and fractional part) by powers of 2. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. FLOAT_LIT ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT DEC_FLOAT_LIT ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? | DECIMAL_DIGITS DEC_EXPONENT | '.' DECIMAL_DIGITS DEC_EXPONENT? DEC_EXPONENT ::= [eE] [+-]? DECIMAL_DIGITS HEX_FLOAT_LIT ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT HEX_MANTISSA ::= HEX_DIGITS '.' HEX_DIGITS? | HEX_DIGITS | '.' HEX_DIGITS HEX_EXPONENT ::= [pP] [+-] DECIMAL_DIGITS","title":"Floating point literals"},{"location":"specification/#character-literals","text":"A character literal represents a constant value of 1, 2, 4 or 8 bytes, and may only be printable ASCII characters (U+0020 - U+007F). Each character is intepreted as part of an 1, 2, 4 or 8 byte integer constant. Escape sequences can be used to represent byte values 0-31 and 128-255. A 2 byte literal is referred to as a 2cc literal, a 4 byte literal 4cc and an eight byte literal is called 8cc. We will commonly refer to a single byte character literal as just \"character literal\". The following backslash escapes are available to escape: \\0 0x00 zero value \\a 0x07 alert/bell \\b 0x08 backspace \\e 0x1B escape \\f 0x0C form feed \\n 0x0A newline \\r 0x0D carriage return \\t 0x09 horizontal tab \\v 0x0B vertical tab \\\\ 0x5C backslash \\' 0x27 single quote ' \\\" 0x22 double quote \" \\x Escapes a single byte hex value \\u Escapes a two byte hex value \\U Escapes a four byte hex value CHAR_ELEMENT ::= [\\x20-\\x26] | [\\x28-\\x5B] | [\\x5D-\\x7F] CHAR_LIT_BYTE ::= CHAR_ELEMENT | \\x5C CHAR_ESCAPE CHAR_ESCAPE ::= [abefnrtv\\'\\\"\\\\] | 'x' HEX_DIGIT HEX_DIGIT | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT CHARACTER_LIT ::= \"'\" CHAR_LIT_BYTE \"'\" TWOCC_LIT ::= \"'\" CHAR_LIT_BYTE CHAR_LIT_BYTE \"'\" FOURCC_LIT ::= \"'\" CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE \"'\" EIGHTCC_LIT ::= \"'\" CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE CHAR_LIT_BYTE \"'\"","title":"Character literals"},{"location":"specification/#string-literals","text":"A string literal represents a string constant obtained from concatenating a sequence of characters. String literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals, with the same restrictions. The two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. STRING_LIT ::= \\x22 CHAR_LIT_BYTE* \\x22","title":"String literals"},{"location":"specification/#types","text":"","title":"Types"},{"location":"specification/#boolean-types","text":"","title":"Boolean types"},{"location":"specification/#integer-types","text":"","title":"Integer types"},{"location":"specification/#floating-point-types","text":"","title":"Floating point types"},{"location":"specification/#vector-types","text":"","title":"Vector types"},{"location":"specification/#complex-types","text":"A complex type is defined as a struct with two elements of the same floating point type. The first member holds the real part of a complex number, and the second member holds the imaginary part. struct Complex { float real; float imaginary; }","title":"Complex types"},{"location":"specification/#string-types","text":"","title":"String types"},{"location":"specification/#array-types","text":"An array has the alignment of its element. Zero sized arrays are allowed and have the size 0.","title":"Array types"},{"location":"specification/#vararray-types","text":"","title":"Vararray types"},{"location":"specification/#subarray-types","text":"The subarray consist of a pointer, followed by a usize length, having the alignment of pointers.","title":"Subarray types"},{"location":"specification/#pointer-types","text":"","title":"Pointer types"},{"location":"specification/#struct-types","text":"A struct without any members or with only arrays of size 0 have the size 0. The alignment of a struct without any members is 1.","title":"Struct types"},{"location":"specification/#union-types","text":"The alignment of a union without any members is 1.","title":"Union types"},{"location":"specification/#error-types","text":"Th","title":"Error types"},{"location":"specification/#enum-types","text":"","title":"Enum types"},{"location":"specification/#function-types","text":"","title":"Function types"},{"location":"specification/#virtual-types","text":"","title":"Virtual types"},{"location":"specification/#declarations-and-scope","text":"","title":"Declarations and scope"},{"location":"specification/#expressions","text":"","title":"Expressions"},{"location":"specification/#casts","text":"","title":"Casts"},{"location":"specification/#pointer-casts","text":"","title":"Pointer casts"},{"location":"specification/#integer-to-pointer-cast","text":"Any integer of pointer size or larger may be explicitly cast to a pointer. An integer to pointer cast is considered non-constant, except in the special case where the integer == 0. In that case, the result is constant null . Example: byte a = 1; int* b = cast(a as int*); // Invalid, pointer type is > 8 bits. int* c = cast(1 as int*); // Valid, but runtime value. int* d = cast(0 as int*); // Valid and constant value.","title":"Integer to pointer cast"},{"location":"specification/#pointer-to-integer-cast","text":"A pointer may be cast to any integer, truncating the pointer value if the size of the pointer is larger than the pointer size. A pointer to integer cast is considered non-constant, except in the special case of a null pointer, where it is equal to the integer value 0. Example: func void test() { ... } typedef func void test() as VoidFunc; VoidFunc a = &test; int b = cast(null as int); int c = cast(a as int); // Invalid, not constant int d = cast(cast(1 as int*) as int); // Invalid, not constant","title":"Pointer to integer cast"},{"location":"specification/#subscript-operator","text":"The subscript operator may take as its left side a pointer, array, subarray or vararray. The index may be of any integer type. TODO NOTE The subscript operator is not symmetrical as in C. For example in C3 array[n] = 33 is allowed, but not n[array] = 33 . This is a change from C.","title":"Subscript operator"},{"location":"specification/#operands","text":"","title":"Operands"},{"location":"specification/#compound-literals","text":"Compound literals have the format compound_literal ::= TYPE_IDENTIFIER '(' initializer_list ')' initializer_list ::= '{' (initializer_param (',' initializer_param)* ','?)? '}' initializer_param ::= expression | designator '=' expression designator ::= array_designator | range_designator | field_designator array_designator ::= '[' expression ']' range_designator ::= '[' range_expression ']' field_designator ::= IDENTIFIER range_expression ::= (range_index)? '..' (range_index)? range_index ::= expression | '^' expression Taking the address of a compound literal will yield a pointer to stack allocated temporary.","title":"Compound Literals"},{"location":"specification/#function-calls","text":"","title":"Function calls"},{"location":"specification/#varargs","text":"For varargs, a bool or any integer smaller than what the C ABI specifies for the c int type is cast to int . Any float smaller than a double is cast to double . Compile time floats will be cast to double. Compile time integers will be cast to c int type.","title":"Varargs"},{"location":"specification/#statements","text":"","title":"Statements"},{"location":"specification/#if-statement","text":"","title":"If statement"},{"location":"specification/#switch-stat","text":"","title":"Switch stat"},{"location":"specification/#modules","text":"","title":"Modules"},{"location":"statements/","text":"Statements Statements largely work like in C, but with some additions. Expression blocks NOTE: This syntax may be subject to change Expression blocks (delimited using {| |} ) are compound statements that opens its own function scope. Jumps cannot be done into or out of a function block, and return exits the block, rather than the function as a whole. The function below prints World! func void test() { int a = 0; {| if (a != 0) return; printf(\"Hello \"); return; |}; printf(\"World!\\n\"); } Expression blocks may also return values: func void test(int x) { int a = {| if (x > 0) return x * 2; if (x == 0) return 100; return -x; |}; printf(\"The result was %d\\n\", a); } Labelled break and continue Labelled break and continue lets you break out of an outer scope. Labels can be put on if , switch , catch , while and do statements. func void test(int i) { if FOO: (i > 0) { while (1) { printf(\"%d\\n\", i); // Break out of the top if statement. if (i++ > 10) break FOO; } } } Do-without-while Do-while statements can skip the ending while . In that case it acts as if the while was while(0) : do { printf(\"FOO\\n\"); } while (0); // Equivalent to the above. do { printf(\"FOO\\n\"); } Nextcase and labelled nextcase The nextcase statement is used in switch and catch to jump to the next statement: switch (i) { case 1: doSomething(); nextcase; // Jumps to case 2 case 2: doSomethingElse(); } It's also possible to use nextcase with an expression, to jump to an arbitrary case: switch (i) { case 1: doSomething(); nextcase 3; // Jump to case 3 case 2: doSomethingElse(); case 3: nextcase rand(); // Jump to random case default: printf(\"Ended\\n\"); } Which can be used as structured goto when creating state machines.","title":"Statements"},{"location":"statements/#statements","text":"Statements largely work like in C, but with some additions.","title":"Statements"},{"location":"statements/#expression-blocks","text":"NOTE: This syntax may be subject to change Expression blocks (delimited using {| |} ) are compound statements that opens its own function scope. Jumps cannot be done into or out of a function block, and return exits the block, rather than the function as a whole. The function below prints World! func void test() { int a = 0; {| if (a != 0) return; printf(\"Hello \"); return; |}; printf(\"World!\\n\"); } Expression blocks may also return values: func void test(int x) { int a = {| if (x > 0) return x * 2; if (x == 0) return 100; return -x; |}; printf(\"The result was %d\\n\", a); }","title":"Expression blocks"},{"location":"statements/#labelled-break-and-continue","text":"Labelled break and continue lets you break out of an outer scope. Labels can be put on if , switch , catch , while and do statements. func void test(int i) { if FOO: (i > 0) { while (1) { printf(\"%d\\n\", i); // Break out of the top if statement. if (i++ > 10) break FOO; } } }","title":"Labelled break and continue"},{"location":"statements/#do-without-while","text":"Do-while statements can skip the ending while . In that case it acts as if the while was while(0) : do { printf(\"FOO\\n\"); } while (0); // Equivalent to the above. do { printf(\"FOO\\n\"); }","title":"Do-without-while"},{"location":"statements/#nextcase-and-labelled-nextcase","text":"The nextcase statement is used in switch and catch to jump to the next statement: switch (i) { case 1: doSomething(); nextcase; // Jumps to case 2 case 2: doSomethingElse(); } It's also possible to use nextcase with an expression, to jump to an arbitrary case: switch (i) { case 1: doSomething(); nextcase 3; // Jump to case 3 case 2: doSomethingElse(); case 3: nextcase rand(); // Jump to random case default: printf(\"Ended\\n\"); } Which can be used as structured goto when creating state machines.","title":"Nextcase and labelled nextcase"},{"location":"syntax/","text":"Syntax Keywords The following are 73 reserved keywords used by C3: as, auto, asm, attribute, break, case, cast, catch, const, continue, default, defer, do, else, enum, error, false, for, func, generic, if, import, local, macro, module, nextcase, nil, public, return, struct, switch, throw, throws, true, try, type, typedef, union, until, var, void, volatile, while, f32, f64, float, double, u1, i8, i16, i32, i64, u8, u16, u32, u64, char, bool, byte, short, ushort, int, uint, long, ulong, isize, usize, In addition to those, the following 12 are reserved but currently not used: f16, f128, f256, half, quad, i128, i256, u128, u256, alias For macros the the following 9 @ identifiers are reserved as keywords: @param, @throws, @return, @ensure, @require, @pure, @const, @reqparse, @deprecated Yacc grammar %{ #include <stdio.h> #define YYERROR_VERBOSE extern char yytext[]; extern int column; int yylex(void); void yyerror(char *s); %} %token IDENT CT_IDENT CONSTANT CONST_IDENT TYPE_IDENT STRING_LITERAL SIZEOF %token INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP %token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN %token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN %token XOR_ASSIGN OR_ASSIGN VAR NIL ELVIS HASH_IDENT NEXT %token AT %token TYPEDEF MODULE IMPORT %token CHAR SHORT INT LONG FLOAT DOUBLE CONST VOLATILE VOID %token BYTE USHORT UINT ULONG BOOL %token STRUCT UNION ENUM ELLIPSIS AS LOCAL %token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN %token TYPE FUNC ERROR MACRO GENERIC CTIF CTELIF CTENDIF CTELSE CTSWITCH CTCASE CTDEFAULT CTFOR %token THROWS THROW TRY CATCH SCOPE PUBLIC DEFER ATTRIBUTE IN %token FN_BLOCK_START FN_BLOCK_END %token MULTW ADDW SUBW %token AUTO %start translation_unit %% path : IDENT SCOPE | path IDENT SCOPE ; import_path : IDENT | import_path SCOPE IDENT ; ident_expression : CONST_IDENT | IDENT | CT_IDENT ; primary_expression : STRING_LITERAL | CONSTANT | NIL | path ident_expression | ident_expression | base_type initializer_list | base_type '.' IDENT | TYPE '(' type_expression ')' | '(' expression ')' | FN_BLOCK_START statement_list FN_BLOCK_END ; postfix_expression : primary_expression | postfix_expression '[' expression ']' | postfix_expression '(' ')' | postfix_expression '(' argument_expression_list ')' | postfix_expression '.' IDENT | postfix_expression INC_OP | postfix_expression DEC_OP ; argument_expression_list : expression | argument_expression_list ',' expression ; unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator unary_expression | SIZEOF '(' type_expression ')' ; unary_operator : '&' | '*' | '+' | '-' | SUBW | '~' | '!' | '@' ; multiplicative_expression : unary_expression | multiplicative_expression '*' unary_expression | multiplicative_expression MULTW unary_expression | multiplicative_expression '/' unary_expression | multiplicative_expression '%' unary_expression ; shift_expression : multiplicative_expression | shift_expression LEFT_OP multiplicative_expression | shift_expression RIGHT_OP multiplicative_expression ; bit_expression : shift_expression | bit_expression '&' shift_expression | bit_expression '^' shift_expression | bit_expression '|' shift_expression ; additive_expression : bit_expression | additive_expression '+' bit_expression | additive_expression ADDW bit_expression | additive_expression '-' bit_expression | additive_expression SUBW bit_expression ; relational_expression : additive_expression | relational_expression '<' additive_expression | relational_expression '>' additive_expression | relational_expression LE_OP additive_expression | relational_expression GE_OP additive_expression | relational_expression EQ_OP additive_expression | relational_expression NE_OP additive_expression ; logical_expression : relational_expression | logical_expression AND_OP relational_expression | logical_expression OR_OP relational_expression ; conditional_expression : logical_expression | logical_expression '?' expression ':' conditional_expression | logical_expression ELVIS conditional_expression ; assignment_expression : conditional_expression | unary_expression assignment_operator assignment_expression | unary_expression '=' initializer_list ; expression : assignment_expression | TRY assignment_expression | TRY assignment_expression ELSE assignment_expression ; assignment_operator : '=' | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | LEFT_ASSIGN | RIGHT_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN ; constant_expression : conditional_expression ; enumerators : enumerator | enumerators ',' enumerator ; enumerator_list : enumerators | enumerators ',' ; enumerator : CONST_IDENT | CONST_IDENT '=' constant_expression ; identifier_list : IDENT | identifier_list ',' IDENT ; macro_argument : CT_IDENT | IDENT | type_expression IDENT | type_expression CT_IDENT ; macro_argument_list : macro_argument | macro_argument_list ',' macro_argument ; declaration : type_expression IDENT '=' initializer | type_expression IDENT ; param_declaration : type_expression | type_expression IDENT | type_expression IDENT '=' initializer ; parameter_type_list : parameter_list | parameter_list ',' ELLIPSIS | parameter_list ',' type_expression ELLIPSIS ; opt_parameter_type_list : '(' ')' | '(' parameter_type_list ')' ; parameter_list : param_declaration | parameter_list ',' param_declaration ; base_type : VOID | AUTO | BOOL | CHAR | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | FLOAT | DOUBLE | TYPE_IDENT | path TYPE_IDENT | TYPE '(' constant_expression ')' ; type_expression : base_type | type_expression '*' | type_expression '[' constant_expression ']' | type_expression '[' ']' | type_expression '[' '+' ']' ; initializer : expression | initializer_list ; initializer_values : initializer | initializer_values ',' initializer ; initializer_list : '{' initializer_values '}' | '{' initializer_values ',' '}' ; ct_case_statement : CTCASE type_list ':' statement | CTDEFAULT ':' statement ; ct_elif_body : ct_elif compound_statement | ct_elif_body ct_elif compound_statement ; ct_else_body : ct_elif_body | CTELSE compound_statement | ct_elif_body CTELSE compound_statement ; ct_switch_body : ct_case_statement | ct_switch_body ct_case_statement ; ct_for_stmt : CTFOR '(' CT_IDENT IN expression ')' statement | CTFOR '(' CT_IDENT ',' CT_IDENT IN expression ')' statement ; ct_statement : ct_if compound_statement | ct_if compound_statement ct_else_body | ct_switch '{' ct_switch_body '}' | ct_for_stmt ; throw_statement : THROW expression ';' statement : compound_statement | labeled_statement | expression_statement | selection_statement | iteration_statement | jump_statement | declaration_statement | volatile_statement | catch_statement | try_statement | defer_statement | ct_statement | throw_statement ; defer_catch_body : compound_statement | expression_statement | jump_statement | iteration_statement | selection_statement ; defer_statement : DEFER defer_catch_body | DEFER catch_statement ; catch_statement : CATCH '(' type_expression IDENT ')' defer_catch_body | CATCH '(' ERROR IDENT ')' defer_catch_body ; try_statement : TRY selection_statement | TRY iteration_statement | TRY jump_statement ; volatile_statement : VOLATILE compound_statement ; label_statement : IDENT ':' statement labeled_statement : label_statement | CASE constant_expression ':' | DEFAULT ':' ; compound_statement : '{' '}' | '{' statement_list '}' ; statement_list : statement | statement_list statement ; declaration_statement : declaration ';' ; expression_statement : ';' | expression ';' ; control_expression : decl_expr_list | decl_expr_list ';' decl_expr_list ; selection_statement : IF '(' control_expression ')' statement | IF '(' control_expression ')' compound_statement ELSE statement | SWITCH '(' control_expression ')' compound_statement ; expression_list : expression | expression_list ',' expression ; decl_expr_list : expression | declaration | decl_expr_list ',' expression | decl_expr_list ',' declaration ; for_statement : FOR '(' decl_expr_list ';' expression_statement ')' statement | FOR '(' decl_expr_list ';' expression_statement expression_list ')' statement ; iteration_statement : WHILE '(' control_expression ')' statement | DO statement WHILE '(' expression ')' ';' | for_statement ; jump_statement : GOTO CONSTANT ';' | CONTINUE ';' | BREAK ';' | RETURN ';' | RETURN expression ';' ; path_ident : IDENT | path IDENT ; attribute : AT path_ident | AT path_ident '(' constant_expression ')' ; attribute_list : attribute | attribute_list attribute ; opt_attributes : attribute_list | ; error_type : path TYPE_IDENT | TYPE_IDENT | ERROR '(' expression ')' ; error_list : error_type | error_list error_type ; throw_declaration : THROWS | THROWS error_list ; opt_throw_declaration : throw_declaration | ; func_name : path TYPE_IDENT '.' IDENT | TYPE_IDENT '.' IDENT | IDENT ; func_declaration : FUNC type_expression func_name opt_parameter_type_list opt_attributes opt_throw_declaration ; func_definition : func_declaration compound_statement | func_declaration ';' ; macro_declaration : MACRO type_expression IDENT '(' macro_argument_list ')' compound_statement : MACRO IDENT '(' macro_argument_list ')' compound_statement ; struct_or_union : STRUCT | UNION ; struct_declaration : struct_or_union TYPE_IDENT opt_attributes struct_body ; struct_body : '{' struct_declaration_list '}' ; struct_declaration_list : struct_member_declaration | struct_declaration_list struct_member_declaration ; struct_member_declaration : type_expression identifier_list opt_attributes ';' | struct_or_union IDENT opt_attributes struct_body | struct_or_union opt_attributes struct_body ; enum_declaration : ENUM TYPE_IDENT ':' type_expression opt_attributes '{' enumerator_list '}' | ENUM TYPE_IDENT opt_attributes '{' enumerator_list '}' ; errors : CONST_IDENT | errors ',' CONST_IDENT ; error_list : errors | errors ',' ; error_declaration : ERROR TYPE_IDENT '{' error_list '}' ; type_list : type_expression | type_list ',' type_expression ; generics_case : CASE type_list ':' statement generics_body : generics_case | generics_body generics_case ; generics_declaration : GENERIC IDENT '(' macro_argument_list ')' '{' generics_body '}' | GENERIC type_expression IDENT '(' macro_argument_list ')' '{' generics_body '}' ; const_declaration : CONST CT_IDENT '=' initializer ';' | CONST type_expression IDENT '=' initializer ';' ; func_typedef : FUNC type_expression opt_parameter_type_list opt_throw_declaration ; typedef_declaration : TYPEDEF type_expression AS TYPE_IDENT ';' | TYPEDEF func_typedef AS TYPE_IDENT ';' ; attribute_domain : FUNC | VAR | ENUM | STRUCT | UNION | TYPEDEF | CONST | ERROR ; attribute_domains : attribute_domain | attribute_domains ',' attribute_domain ; attribute_declaration : ATTRIBUTE attribute_domains IDENT ';' | ATTRIBUTE attribute_domains IDENT '(' parameter_type_list ')' ';' ; global_declaration : type_expression IDENT ';' | type_expression IDENT '=' initializer ';' ; ct_if : CTIF '(' expression ')' ; ct_elif : CTELIF '(' expression ')' ; ct_switch : CTSWITCH '(' expression ')' ; top_level_block : '{' top_level_statements '}' ; tl_ct_elif_body : ct_elif top_level_block | tl_ct_elif_body ct_elif top_level_block ; tl_ct_else_body : tl_ct_elif_body | tl_ct_else_body CTELSE top_level_block ; tl_ct_case : CTCASE type_list ':' top_level_statements | CTDEFAULT ':' top_level_statements ; tl_ct_switch_body : tl_ct_case | tl_ct_switch_body tl_ct_case ; conditional_compilation : ct_if top_level_block | ct_if top_level_block tl_ct_else_body | ct_switch '{' tl_ct_switch_body '}' ; module_param : CT_IDENT | HASH_IDENT | TYPE_IDENT | IDENT ; module_params : module_param | module_params ',' module_param ; module : MODULE import_path ';' | MODULE import_path '(' module_params ')' ';' ; specified_import : IDENT AS IDENT | IDENT | TYPE | CONST | MACRO | TYPE AS TYPE | CONST AS CONST | MACRO AS MACRO ; specified_import_list : specified_import | specified_import_list ',' specified_import ; import_decl : IMPORT import_path ';' | IMPORT import_path ':' specified_import_list ';' ; imports : import_decl | imports import_decl ; translation_unit : module imports top_level_statements ; top_level_statements : visibility top_level | top_level_statements visibility top_level ; visibility : LOCAL | PUBLIC | LOCAL PUBLIC | PUBLIC LOCAL | ; top_level : func_definition | conditional_compilation | struct_declaration | attribute_declaration | enum_declaration | error_declaration | const_declaration | global_declaration | macro_declaration | generics_declaration | typedef_declaration ; %% void yyerror(char *s) { fflush(stdout); printf(\"\\n%*s\\n%*s\\n\", column, \"^\", column, s); } int main(int argc, char *argv[]) { yyparse(); return(0); }","title":"Grammar"},{"location":"syntax/#syntax","text":"","title":"Syntax"},{"location":"syntax/#keywords","text":"The following are 73 reserved keywords used by C3: as, auto, asm, attribute, break, case, cast, catch, const, continue, default, defer, do, else, enum, error, false, for, func, generic, if, import, local, macro, module, nextcase, nil, public, return, struct, switch, throw, throws, true, try, type, typedef, union, until, var, void, volatile, while, f32, f64, float, double, u1, i8, i16, i32, i64, u8, u16, u32, u64, char, bool, byte, short, ushort, int, uint, long, ulong, isize, usize, In addition to those, the following 12 are reserved but currently not used: f16, f128, f256, half, quad, i128, i256, u128, u256, alias For macros the the following 9 @ identifiers are reserved as keywords: @param, @throws, @return, @ensure, @require, @pure, @const, @reqparse, @deprecated","title":"Keywords"},{"location":"syntax/#yacc-grammar","text":"%{ #include <stdio.h> #define YYERROR_VERBOSE extern char yytext[]; extern int column; int yylex(void); void yyerror(char *s); %} %token IDENT CT_IDENT CONSTANT CONST_IDENT TYPE_IDENT STRING_LITERAL SIZEOF %token INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP %token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN %token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN %token XOR_ASSIGN OR_ASSIGN VAR NIL ELVIS HASH_IDENT NEXT %token AT %token TYPEDEF MODULE IMPORT %token CHAR SHORT INT LONG FLOAT DOUBLE CONST VOLATILE VOID %token BYTE USHORT UINT ULONG BOOL %token STRUCT UNION ENUM ELLIPSIS AS LOCAL %token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN %token TYPE FUNC ERROR MACRO GENERIC CTIF CTELIF CTENDIF CTELSE CTSWITCH CTCASE CTDEFAULT CTFOR %token THROWS THROW TRY CATCH SCOPE PUBLIC DEFER ATTRIBUTE IN %token FN_BLOCK_START FN_BLOCK_END %token MULTW ADDW SUBW %token AUTO %start translation_unit %% path : IDENT SCOPE | path IDENT SCOPE ; import_path : IDENT | import_path SCOPE IDENT ; ident_expression : CONST_IDENT | IDENT | CT_IDENT ; primary_expression : STRING_LITERAL | CONSTANT | NIL | path ident_expression | ident_expression | base_type initializer_list | base_type '.' IDENT | TYPE '(' type_expression ')' | '(' expression ')' | FN_BLOCK_START statement_list FN_BLOCK_END ; postfix_expression : primary_expression | postfix_expression '[' expression ']' | postfix_expression '(' ')' | postfix_expression '(' argument_expression_list ')' | postfix_expression '.' IDENT | postfix_expression INC_OP | postfix_expression DEC_OP ; argument_expression_list : expression | argument_expression_list ',' expression ; unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator unary_expression | SIZEOF '(' type_expression ')' ; unary_operator : '&' | '*' | '+' | '-' | SUBW | '~' | '!' | '@' ; multiplicative_expression : unary_expression | multiplicative_expression '*' unary_expression | multiplicative_expression MULTW unary_expression | multiplicative_expression '/' unary_expression | multiplicative_expression '%' unary_expression ; shift_expression : multiplicative_expression | shift_expression LEFT_OP multiplicative_expression | shift_expression RIGHT_OP multiplicative_expression ; bit_expression : shift_expression | bit_expression '&' shift_expression | bit_expression '^' shift_expression | bit_expression '|' shift_expression ; additive_expression : bit_expression | additive_expression '+' bit_expression | additive_expression ADDW bit_expression | additive_expression '-' bit_expression | additive_expression SUBW bit_expression ; relational_expression : additive_expression | relational_expression '<' additive_expression | relational_expression '>' additive_expression | relational_expression LE_OP additive_expression | relational_expression GE_OP additive_expression | relational_expression EQ_OP additive_expression | relational_expression NE_OP additive_expression ; logical_expression : relational_expression | logical_expression AND_OP relational_expression | logical_expression OR_OP relational_expression ; conditional_expression : logical_expression | logical_expression '?' expression ':' conditional_expression | logical_expression ELVIS conditional_expression ; assignment_expression : conditional_expression | unary_expression assignment_operator assignment_expression | unary_expression '=' initializer_list ; expression : assignment_expression | TRY assignment_expression | TRY assignment_expression ELSE assignment_expression ; assignment_operator : '=' | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | LEFT_ASSIGN | RIGHT_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN ; constant_expression : conditional_expression ; enumerators : enumerator | enumerators ',' enumerator ; enumerator_list : enumerators | enumerators ',' ; enumerator : CONST_IDENT | CONST_IDENT '=' constant_expression ; identifier_list : IDENT | identifier_list ',' IDENT ; macro_argument : CT_IDENT | IDENT | type_expression IDENT | type_expression CT_IDENT ; macro_argument_list : macro_argument | macro_argument_list ',' macro_argument ; declaration : type_expression IDENT '=' initializer | type_expression IDENT ; param_declaration : type_expression | type_expression IDENT | type_expression IDENT '=' initializer ; parameter_type_list : parameter_list | parameter_list ',' ELLIPSIS | parameter_list ',' type_expression ELLIPSIS ; opt_parameter_type_list : '(' ')' | '(' parameter_type_list ')' ; parameter_list : param_declaration | parameter_list ',' param_declaration ; base_type : VOID | AUTO | BOOL | CHAR | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | FLOAT | DOUBLE | TYPE_IDENT | path TYPE_IDENT | TYPE '(' constant_expression ')' ; type_expression : base_type | type_expression '*' | type_expression '[' constant_expression ']' | type_expression '[' ']' | type_expression '[' '+' ']' ; initializer : expression | initializer_list ; initializer_values : initializer | initializer_values ',' initializer ; initializer_list : '{' initializer_values '}' | '{' initializer_values ',' '}' ; ct_case_statement : CTCASE type_list ':' statement | CTDEFAULT ':' statement ; ct_elif_body : ct_elif compound_statement | ct_elif_body ct_elif compound_statement ; ct_else_body : ct_elif_body | CTELSE compound_statement | ct_elif_body CTELSE compound_statement ; ct_switch_body : ct_case_statement | ct_switch_body ct_case_statement ; ct_for_stmt : CTFOR '(' CT_IDENT IN expression ')' statement | CTFOR '(' CT_IDENT ',' CT_IDENT IN expression ')' statement ; ct_statement : ct_if compound_statement | ct_if compound_statement ct_else_body | ct_switch '{' ct_switch_body '}' | ct_for_stmt ; throw_statement : THROW expression ';' statement : compound_statement | labeled_statement | expression_statement | selection_statement | iteration_statement | jump_statement | declaration_statement | volatile_statement | catch_statement | try_statement | defer_statement | ct_statement | throw_statement ; defer_catch_body : compound_statement | expression_statement | jump_statement | iteration_statement | selection_statement ; defer_statement : DEFER defer_catch_body | DEFER catch_statement ; catch_statement : CATCH '(' type_expression IDENT ')' defer_catch_body | CATCH '(' ERROR IDENT ')' defer_catch_body ; try_statement : TRY selection_statement | TRY iteration_statement | TRY jump_statement ; volatile_statement : VOLATILE compound_statement ; label_statement : IDENT ':' statement labeled_statement : label_statement | CASE constant_expression ':' | DEFAULT ':' ; compound_statement : '{' '}' | '{' statement_list '}' ; statement_list : statement | statement_list statement ; declaration_statement : declaration ';' ; expression_statement : ';' | expression ';' ; control_expression : decl_expr_list | decl_expr_list ';' decl_expr_list ; selection_statement : IF '(' control_expression ')' statement | IF '(' control_expression ')' compound_statement ELSE statement | SWITCH '(' control_expression ')' compound_statement ; expression_list : expression | expression_list ',' expression ; decl_expr_list : expression | declaration | decl_expr_list ',' expression | decl_expr_list ',' declaration ; for_statement : FOR '(' decl_expr_list ';' expression_statement ')' statement | FOR '(' decl_expr_list ';' expression_statement expression_list ')' statement ; iteration_statement : WHILE '(' control_expression ')' statement | DO statement WHILE '(' expression ')' ';' | for_statement ; jump_statement : GOTO CONSTANT ';' | CONTINUE ';' | BREAK ';' | RETURN ';' | RETURN expression ';' ; path_ident : IDENT | path IDENT ; attribute : AT path_ident | AT path_ident '(' constant_expression ')' ; attribute_list : attribute | attribute_list attribute ; opt_attributes : attribute_list | ; error_type : path TYPE_IDENT | TYPE_IDENT | ERROR '(' expression ')' ; error_list : error_type | error_list error_type ; throw_declaration : THROWS | THROWS error_list ; opt_throw_declaration : throw_declaration | ; func_name : path TYPE_IDENT '.' IDENT | TYPE_IDENT '.' IDENT | IDENT ; func_declaration : FUNC type_expression func_name opt_parameter_type_list opt_attributes opt_throw_declaration ; func_definition : func_declaration compound_statement | func_declaration ';' ; macro_declaration : MACRO type_expression IDENT '(' macro_argument_list ')' compound_statement : MACRO IDENT '(' macro_argument_list ')' compound_statement ; struct_or_union : STRUCT | UNION ; struct_declaration : struct_or_union TYPE_IDENT opt_attributes struct_body ; struct_body : '{' struct_declaration_list '}' ; struct_declaration_list : struct_member_declaration | struct_declaration_list struct_member_declaration ; struct_member_declaration : type_expression identifier_list opt_attributes ';' | struct_or_union IDENT opt_attributes struct_body | struct_or_union opt_attributes struct_body ; enum_declaration : ENUM TYPE_IDENT ':' type_expression opt_attributes '{' enumerator_list '}' | ENUM TYPE_IDENT opt_attributes '{' enumerator_list '}' ; errors : CONST_IDENT | errors ',' CONST_IDENT ; error_list : errors | errors ',' ; error_declaration : ERROR TYPE_IDENT '{' error_list '}' ; type_list : type_expression | type_list ',' type_expression ; generics_case : CASE type_list ':' statement generics_body : generics_case | generics_body generics_case ; generics_declaration : GENERIC IDENT '(' macro_argument_list ')' '{' generics_body '}' | GENERIC type_expression IDENT '(' macro_argument_list ')' '{' generics_body '}' ; const_declaration : CONST CT_IDENT '=' initializer ';' | CONST type_expression IDENT '=' initializer ';' ; func_typedef : FUNC type_expression opt_parameter_type_list opt_throw_declaration ; typedef_declaration : TYPEDEF type_expression AS TYPE_IDENT ';' | TYPEDEF func_typedef AS TYPE_IDENT ';' ; attribute_domain : FUNC | VAR | ENUM | STRUCT | UNION | TYPEDEF | CONST | ERROR ; attribute_domains : attribute_domain | attribute_domains ',' attribute_domain ; attribute_declaration : ATTRIBUTE attribute_domains IDENT ';' | ATTRIBUTE attribute_domains IDENT '(' parameter_type_list ')' ';' ; global_declaration : type_expression IDENT ';' | type_expression IDENT '=' initializer ';' ; ct_if : CTIF '(' expression ')' ; ct_elif : CTELIF '(' expression ')' ; ct_switch : CTSWITCH '(' expression ')' ; top_level_block : '{' top_level_statements '}' ; tl_ct_elif_body : ct_elif top_level_block | tl_ct_elif_body ct_elif top_level_block ; tl_ct_else_body : tl_ct_elif_body | tl_ct_else_body CTELSE top_level_block ; tl_ct_case : CTCASE type_list ':' top_level_statements | CTDEFAULT ':' top_level_statements ; tl_ct_switch_body : tl_ct_case | tl_ct_switch_body tl_ct_case ; conditional_compilation : ct_if top_level_block | ct_if top_level_block tl_ct_else_body | ct_switch '{' tl_ct_switch_body '}' ; module_param : CT_IDENT | HASH_IDENT | TYPE_IDENT | IDENT ; module_params : module_param | module_params ',' module_param ; module : MODULE import_path ';' | MODULE import_path '(' module_params ')' ';' ; specified_import : IDENT AS IDENT | IDENT | TYPE | CONST | MACRO | TYPE AS TYPE | CONST AS CONST | MACRO AS MACRO ; specified_import_list : specified_import | specified_import_list ',' specified_import ; import_decl : IMPORT import_path ';' | IMPORT import_path ':' specified_import_list ';' ; imports : import_decl | imports import_decl ; translation_unit : module imports top_level_statements ; top_level_statements : visibility top_level | top_level_statements visibility top_level ; visibility : LOCAL | PUBLIC | LOCAL PUBLIC | PUBLIC LOCAL | ; top_level : func_definition | conditional_compilation | struct_declaration | attribute_declaration | enum_declaration | error_declaration | const_declaration | global_declaration | macro_declaration | generics_declaration | typedef_declaration ; %% void yyerror(char *s) { fflush(stdout); printf(\"\\n%*s\\n%*s\\n\", column, \"^\", column, s); } int main(int argc, char *argv[]) { yyparse(); return(0); }","title":"Yacc grammar"},{"location":"types/","text":"Types As usual, types are divided into basic types and user defined types (enum, union, struct, error, aliases). All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module. Naming All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. Since this runs into probles with C compatibility, it is possible to use attributes to change the c name of a type, as well as control whether a C typedef should be emitted for the type. struct Stat @cname(\"stat\") @notypedef { // ... } func CInt stat(const char* pathname, Stat* buf); Differences from C Unlike C, C3 does not use type qualifiers. const exists, but is a storage class modifier, not a type qualifier. Instead of volatile , volatile blocks are used. In order to signal restrictions on variable usage, like const-ness preconditions are used. Basic types Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned. Integer types Name alias bit size signed bool* u1 1 no char i8 8 yes byte u8 8 no short i16 16 yes ushort u16 16 no int i32 32 yes uint u32 32 no long i64 64 yes ulong u64 64 no iptr** - varies yes uptr** - varies no iptrdiff** - varies yes uptrdiff** - varies no isize** - varies yes usize** - varies no * bool will be stored as a byte. ** size, pointer and pointer sized types depend on platform. Integer arithmetics All signed integer arithmetics uses 2's complement. Integer constants Integer constants are 1293832 or -918212. Unlike C the \"type\" of an integer constant is a special compile time int. All constant operations, for example 9283 << 2 will be resolved at compile time. An compile time error will result if the constant is too large to fit whatever variable it is assigned or compared to. Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100 TwoCC, FourCC and EightCC FourCC codes are often used to identify binary format types. C3 adds direct support for 4 character codes, but also 2 and 8 characters: 2 character strings, e.g. 'C3' , would convert to an ushort or short. 4 character strings, e.g. 'TEST' , converts to an uint or int. 8 character strings, e.g. 'FOOBAR11' converts to an ulong or long. Conversion is always done so that the character string has the correct ordering in memory. This means that the same characters may have different integer values on different architectures due to endianess. Base64 and hex data literals Base64 encoded values work like TwoCC/FourCC/EightCC, in that is it laid out in byte order in memory. It uses the format '<base64>'b64 . Hex encoded values work as base64 but with the format '<hex>'x . In data literals any whitespace is ignored, so '00 00 11'x encodes to the same value as '000011'x . In our case we could encode 'Rk9PQkFSMTE='b64 as 'FOOBAR11' . Base64 and hex data literals also has a form to allow initializing byte and char arrays, instead of enclosing the data in '' , enclose the data in \"\" byte[] hello_world_base64 = \"SGVsbG8gV29ybGQh\"b64; char[] hello_world_hex = \"4865 6c6c 6f20 776f 726c 6421\"x; Floating point types Name alias bit size half* f16 16 float f32 32 double f64 64 quad* f128 128 *support depends on platform Floating point constants Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediagely before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10 C compatibility For C compatibility the following types are also defined when including std.cinterop Name c type CChar char CShort short int CUShort unsigned short int CInt int CUInt unsigned int CLong long int CULong unsigned long int CLongLong long long CULongLong unsigned long long CFloat float CDouble double CLongDouble long double Pointer types Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo. Array types Arrays are indicated by [] after the type, optionally with the size given, e.g. int[4] . Unlike C, the \"empty\" array (without size), is a variable array that may be queried about its size. There is also array slices with using the [:] suffix. See the chapter on arrays . Enum Enum (enumerated) types use the following syntax: enum State : int { PENDING = 0, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING . Enum type inference When an enum is used in where the type can be inferred, like in case-clauses or in variable assignment, it is allowed to drop the enum name: State foo = PENDING; // State.PENDING is inferred. switch (foo) { case RUNNING: // State.RUNNING is inferred ... default: ... } func void test(State s) { ... } ... test(RUNNING); // State.RUNNING is inferred In the case that it collides with a global in the same scope, it needs the qualifier: module test; func void testState(State s) { ... } State RUNNING = State.TERMINATED; // Don't do this! ... test(RUNNING); // Ambiguous test(test::RUNNING); // Uses global. test(State.RUNNING); // Uses enum constant. Error Error types are similar to enums, and are used for error returns. error IOError; error ParseError { int line; int col; } An error is similar to a struct and is initialized the same way. One exception is that simple errors without a body does not need to be created using a () : return IOError!; return IOError()!; // Same as above return ParseError(line, col)!; Failable A failable is created by taking a type and appending ! . A failable is a tagged union containing either the given type or an error. int! i; i = 5; // Assigning a real value to i. i = IOError!; // Assigning an error to i. Only variables and return variables may be of the failable type. Function and macro parameters may not be failable types. func Foo*! getFoo() { ... } // Ok! func void processFoo(Foo*! f) { ... } // Error! int! x = 0; // Ok! Read more about the errors on the page about error handling . Alias and function types Alias types are used to give an alias to a different type, like: typedef char* as CharPtr; typedef int[10] as Numbers; Function pointers must be aliased in C3. The syntax is simpler than that of C: public typedef func void(int a, bool b) as Callback; This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback; cb(10, false); Distinct types typedef may also be used to create distinct new types. They do not implicitly convert to any other type, but may be used as the underlying type. typedef int as distinct Foo; Foo f = 0; f = f + 1; int i = 1; // f = f + i Error! f = f + cast(i as Foo); // Valid Struct types Structs are always named: struct Person { char age; char* name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; io.printf(\"%s is %d years old.\", p.age, p.name); Person* pPtr = &p; pPtr.age = 20; // Ok! io.printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person** and use dot access. \u2013 It's not, only one level of deref is done) Struct subtyping C3 allows creating struct subtypes: struct ImportantPerson { inline Person person; char* title; } func printPerson(Person p) { io.printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied. Union types Union types are defined just like structs. union Integral { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. io.printf(\"%d\", i.as_byte); Note that unions only take up as much space as their largest member, so sizeof(Integral) is equivalent to sizeof(long) . Anonymous sub-structs / unions Just like in later versions of C, anonymous sub-structs / unions are allowed. struct Person { char age; char* name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } } Tagged unions In C, using structs with an enum value to indicate type is common practice. C3 also offers tagged unions, which is formalizing this within the language: TBD: Exact syntax (see the ideas page) Casting Casting does not use the C-style (NewType) var instead uses cast(<expression> as <Type>) float f = 2.0; int i = cast(f as int); Conversion to symbol to type and back with type Macros and compile time constants may occasionally contain type symbols . To convert back and forth, the type operator is used. macro @test($i) { $if ($i < 2) return type(int); return type(double); } $foo = type(int*); type($foo) i = nil; type(@test(4)) = 100; Anonymous structs It's possible to use anonymous structs (structs without name) as arguments. These will only be checked for structural equivalence. func void set_coordinates(struct { int i; int j; } coord) { ... } struct Vec2 { int x; int y; } struct Vector { int px; int py; } struct Vec3 { int x; int y; int z; } func void test() { Vec2 v2 = { 1, 2 }; Vector v = { 1, 4 }; Vec3 v3 = { 1, 2, 3 }; set_coordinates(v2); // valid set_coordinates(v); // valid set_coordinates(v3); // ERROR, no structural equivalence. struct { int i; int j; } xy = v2; v = cast(v2 as struct { int, int }); }","title":"Types"},{"location":"types/#types","text":"As usual, types are divided into basic types and user defined types (enum, union, struct, error, aliases). All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module.","title":"Types"},{"location":"types/#naming","text":"All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. Since this runs into probles with C compatibility, it is possible to use attributes to change the c name of a type, as well as control whether a C typedef should be emitted for the type. struct Stat @cname(\"stat\") @notypedef { // ... } func CInt stat(const char* pathname, Stat* buf);","title":"Naming"},{"location":"types/#differences-from-c","text":"Unlike C, C3 does not use type qualifiers. const exists, but is a storage class modifier, not a type qualifier. Instead of volatile , volatile blocks are used. In order to signal restrictions on variable usage, like const-ness preconditions are used.","title":"Differences from C"},{"location":"types/#basic-types","text":"Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned.","title":"Basic types"},{"location":"types/#integer-types","text":"Name alias bit size signed bool* u1 1 no char i8 8 yes byte u8 8 no short i16 16 yes ushort u16 16 no int i32 32 yes uint u32 32 no long i64 64 yes ulong u64 64 no iptr** - varies yes uptr** - varies no iptrdiff** - varies yes uptrdiff** - varies no isize** - varies yes usize** - varies no * bool will be stored as a byte. ** size, pointer and pointer sized types depend on platform.","title":"Integer types"},{"location":"types/#integer-arithmetics","text":"All signed integer arithmetics uses 2's complement.","title":"Integer arithmetics"},{"location":"types/#integer-constants","text":"Integer constants are 1293832 or -918212. Unlike C the \"type\" of an integer constant is a special compile time int. All constant operations, for example 9283 << 2 will be resolved at compile time. An compile time error will result if the constant is too large to fit whatever variable it is assigned or compared to. Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100","title":"Integer constants"},{"location":"types/#twocc-fourcc-and-eightcc","text":"FourCC codes are often used to identify binary format types. C3 adds direct support for 4 character codes, but also 2 and 8 characters: 2 character strings, e.g. 'C3' , would convert to an ushort or short. 4 character strings, e.g. 'TEST' , converts to an uint or int. 8 character strings, e.g. 'FOOBAR11' converts to an ulong or long. Conversion is always done so that the character string has the correct ordering in memory. This means that the same characters may have different integer values on different architectures due to endianess.","title":"TwoCC, FourCC and EightCC"},{"location":"types/#base64-and-hex-data-literals","text":"Base64 encoded values work like TwoCC/FourCC/EightCC, in that is it laid out in byte order in memory. It uses the format '<base64>'b64 . Hex encoded values work as base64 but with the format '<hex>'x . In data literals any whitespace is ignored, so '00 00 11'x encodes to the same value as '000011'x . In our case we could encode 'Rk9PQkFSMTE='b64 as 'FOOBAR11' . Base64 and hex data literals also has a form to allow initializing byte and char arrays, instead of enclosing the data in '' , enclose the data in \"\" byte[] hello_world_base64 = \"SGVsbG8gV29ybGQh\"b64; char[] hello_world_hex = \"4865 6c6c 6f20 776f 726c 6421\"x;","title":"Base64 and hex data literals"},{"location":"types/#floating-point-types","text":"Name alias bit size half* f16 16 float f32 32 double f64 64 quad* f128 128 *support depends on platform","title":"Floating point types"},{"location":"types/#floating-point-constants","text":"Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediagely before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10","title":"Floating point constants"},{"location":"types/#c-compatibility","text":"For C compatibility the following types are also defined when including std.cinterop Name c type CChar char CShort short int CUShort unsigned short int CInt int CUInt unsigned int CLong long int CULong unsigned long int CLongLong long long CULongLong unsigned long long CFloat float CDouble double CLongDouble long double","title":"C compatibility"},{"location":"types/#pointer-types","text":"Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo.","title":"Pointer types"},{"location":"types/#array-types","text":"Arrays are indicated by [] after the type, optionally with the size given, e.g. int[4] . Unlike C, the \"empty\" array (without size), is a variable array that may be queried about its size. There is also array slices with using the [:] suffix. See the chapter on arrays .","title":"Array types"},{"location":"types/#enum","text":"Enum (enumerated) types use the following syntax: enum State : int { PENDING = 0, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING .","title":"Enum"},{"location":"types/#enum-type-inference","text":"When an enum is used in where the type can be inferred, like in case-clauses or in variable assignment, it is allowed to drop the enum name: State foo = PENDING; // State.PENDING is inferred. switch (foo) { case RUNNING: // State.RUNNING is inferred ... default: ... } func void test(State s) { ... } ... test(RUNNING); // State.RUNNING is inferred In the case that it collides with a global in the same scope, it needs the qualifier: module test; func void testState(State s) { ... } State RUNNING = State.TERMINATED; // Don't do this! ... test(RUNNING); // Ambiguous test(test::RUNNING); // Uses global. test(State.RUNNING); // Uses enum constant.","title":"Enum type inference"},{"location":"types/#error","text":"Error types are similar to enums, and are used for error returns. error IOError; error ParseError { int line; int col; } An error is similar to a struct and is initialized the same way. One exception is that simple errors without a body does not need to be created using a () : return IOError!; return IOError()!; // Same as above return ParseError(line, col)!;","title":"Error"},{"location":"types/#failable","text":"A failable is created by taking a type and appending ! . A failable is a tagged union containing either the given type or an error. int! i; i = 5; // Assigning a real value to i. i = IOError!; // Assigning an error to i. Only variables and return variables may be of the failable type. Function and macro parameters may not be failable types. func Foo*! getFoo() { ... } // Ok! func void processFoo(Foo*! f) { ... } // Error! int! x = 0; // Ok! Read more about the errors on the page about error handling .","title":"Failable"},{"location":"types/#alias-and-function-types","text":"Alias types are used to give an alias to a different type, like: typedef char* as CharPtr; typedef int[10] as Numbers; Function pointers must be aliased in C3. The syntax is simpler than that of C: public typedef func void(int a, bool b) as Callback; This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback; cb(10, false);","title":"Alias and function types"},{"location":"types/#distinct-types","text":"typedef may also be used to create distinct new types. They do not implicitly convert to any other type, but may be used as the underlying type. typedef int as distinct Foo; Foo f = 0; f = f + 1; int i = 1; // f = f + i Error! f = f + cast(i as Foo); // Valid","title":"Distinct types"},{"location":"types/#struct-types","text":"Structs are always named: struct Person { char age; char* name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; io.printf(\"%s is %d years old.\", p.age, p.name); Person* pPtr = &p; pPtr.age = 20; // Ok! io.printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person** and use dot access. \u2013 It's not, only one level of deref is done)","title":"Struct types"},{"location":"types/#struct-subtyping","text":"C3 allows creating struct subtypes: struct ImportantPerson { inline Person person; char* title; } func printPerson(Person p) { io.printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied.","title":"Struct subtyping"},{"location":"types/#union-types","text":"Union types are defined just like structs. union Integral { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. io.printf(\"%d\", i.as_byte); Note that unions only take up as much space as their largest member, so sizeof(Integral) is equivalent to sizeof(long) .","title":"Union types"},{"location":"types/#anonymous-sub-structs-unions","text":"Just like in later versions of C, anonymous sub-structs / unions are allowed. struct Person { char age; char* name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } }","title":"Anonymous sub-structs / unions"},{"location":"types/#tagged-unions","text":"In C, using structs with an enum value to indicate type is common practice. C3 also offers tagged unions, which is formalizing this within the language: TBD: Exact syntax (see the ideas page)","title":"Tagged unions"},{"location":"types/#casting","text":"Casting does not use the C-style (NewType) var instead uses cast(<expression> as <Type>) float f = 2.0; int i = cast(f as int);","title":"Casting"},{"location":"types/#conversion-to-symbol-to-type-and-back-with-type","text":"Macros and compile time constants may occasionally contain type symbols . To convert back and forth, the type operator is used. macro @test($i) { $if ($i < 2) return type(int); return type(double); } $foo = type(int*); type($foo) i = nil; type(@test(4)) = 100;","title":"Conversion to symbol to type and back with type"},{"location":"types/#anonymous-structs","text":"It's possible to use anonymous structs (structs without name) as arguments. These will only be checked for structural equivalence. func void set_coordinates(struct { int i; int j; } coord) { ... } struct Vec2 { int x; int y; } struct Vector { int px; int py; } struct Vec3 { int x; int y; int z; } func void test() { Vec2 v2 = { 1, 2 }; Vector v = { 1, 4 }; Vec3 v3 = { 1, 2, 3 }; set_coordinates(v2); // valid set_coordinates(v); // valid set_coordinates(v3); // ERROR, no structural equivalence. struct { int i; int j; } xy = v2; v = cast(v2 as struct { int, int }); }","title":"Anonymous structs"},{"location":"undefinedbehaviour/","text":"Undefined behaviour Like C, C3 uses undefined behaviour. In contrast, C3 will trap - that is, print an error trace and abort \u2013 on undefined behaviour in debug builds. This is similar to using C with a UB sanitizer. It is only during release builds that actual undefined behaviour occurs. In C3, undefined behaviour means that the compiler is free to interpret undefined behaviour as if behaviour cannot occur . In the example below: uint x = foo(); uint z = 255 / x; if (x == 0 || z > 10) return bar(); return 1; The case of x == 0 would invoke undefined behaviour for 255/x . For that reason, the compiler may assume that x != 0 and compile it into the following code: foo(); return 1; As a contrast, the safe build will compile code equivalent to the following. uint x = foo(); if (x == 0) trap(\"Division by zero\") return 1; List of undefined behaviours The following operations cause undefined behaviour in release builds of C3: operation will trap in safe builds int / 0 Yes int % 0 Yes using explicitly uninitialized memory Possible* array index out of bounds Yes dereference null Yes dereferencing memory not allocated Possible* dereferencing memory outside of its lifetime Possible* casting pointer to the incorrect array or vararray Possible* violating pre or post conditions Yes violating asserts Yes reaching $unreachable code Yes * \"Possible\" indicates trapping is implementation dependent. List of implementation dependent behaviours Some behaviour is allowed to differ between implementations and platforms. operation will trap in safe builds possible behaviour comparing pointers of different provenance Optional Any result subtracting pointers of different provenance Optional Any result shifting by more or equal to the bit width Yes Any result conversion floating point <-> integer type is out of range Optional Any result conversion between pointer types produces one with incorrect alignment Optional Any result / Error calling a function through a function pointer that does not match the function Optional Any result / Error attempt to modify a string literal Optional Partial modification / Error modifying a const variable Optional Partial modification / Error List of undefined behaviour in C, which is defined in C3 Signed Integer Overflow Signed integer is always wrapped using 2s complement. Modifying the intermediate results of an expression Behaves as if the intermediate result was stored in a variable on the stack.","title":"Undefined behaviour"},{"location":"undefinedbehaviour/#undefined-behaviour","text":"Like C, C3 uses undefined behaviour. In contrast, C3 will trap - that is, print an error trace and abort \u2013 on undefined behaviour in debug builds. This is similar to using C with a UB sanitizer. It is only during release builds that actual undefined behaviour occurs. In C3, undefined behaviour means that the compiler is free to interpret undefined behaviour as if behaviour cannot occur . In the example below: uint x = foo(); uint z = 255 / x; if (x == 0 || z > 10) return bar(); return 1; The case of x == 0 would invoke undefined behaviour for 255/x . For that reason, the compiler may assume that x != 0 and compile it into the following code: foo(); return 1; As a contrast, the safe build will compile code equivalent to the following. uint x = foo(); if (x == 0) trap(\"Division by zero\") return 1;","title":"Undefined behaviour"},{"location":"undefinedbehaviour/#list-of-undefined-behaviours","text":"The following operations cause undefined behaviour in release builds of C3: operation will trap in safe builds int / 0 Yes int % 0 Yes using explicitly uninitialized memory Possible* array index out of bounds Yes dereference null Yes dereferencing memory not allocated Possible* dereferencing memory outside of its lifetime Possible* casting pointer to the incorrect array or vararray Possible* violating pre or post conditions Yes violating asserts Yes reaching $unreachable code Yes * \"Possible\" indicates trapping is implementation dependent.","title":"List of undefined behaviours"},{"location":"undefinedbehaviour/#list-of-implementation-dependent-behaviours","text":"Some behaviour is allowed to differ between implementations and platforms. operation will trap in safe builds possible behaviour comparing pointers of different provenance Optional Any result subtracting pointers of different provenance Optional Any result shifting by more or equal to the bit width Yes Any result conversion floating point <-> integer type is out of range Optional Any result conversion between pointer types produces one with incorrect alignment Optional Any result / Error calling a function through a function pointer that does not match the function Optional Any result / Error attempt to modify a string literal Optional Partial modification / Error modifying a const variable Optional Partial modification / Error","title":"List of implementation dependent behaviours"},{"location":"undefinedbehaviour/#list-of-undefined-behaviour-in-c-which-is-defined-in-c3","text":"","title":"List of undefined behaviour in C, which is defined in C3"},{"location":"undefinedbehaviour/#signed-integer-overflow","text":"Signed integer is always wrapped using 2s complement.","title":"Signed Integer Overflow"},{"location":"undefinedbehaviour/#modifying-the-intermediate-results-of-an-expression","text":"Behaves as if the intermediate result was stored in a variable on the stack.","title":"Modifying the intermediate results of an expression"},{"location":"variables/","text":"Variables Zero init by default Unlike C, C3 local variables are zero-initialized by default. To avoid zero-init, you need to explicitly opt-out. int x; // x = 0 int y = void; // y is explicitly undefined and must be assigned before use. AStruct foo; // foo is implicitly zeroed AStruct bar = {}; // boo is explicitly zeroed AStruct baz = void; // baz is explicitly undefined Using a variable that is explicitly undefined before will trap in debug builds and is undefined behaviour in release builds.","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"},{"location":"variables/#zero-init-by-default","text":"Unlike C, C3 local variables are zero-initialized by default. To avoid zero-init, you need to explicitly opt-out. int x; // x = 0 int y = void; // y is explicitly undefined and must be assigned before use. AStruct foo; // foo is implicitly zeroed AStruct bar = {}; // boo is explicitly zeroed AStruct baz = void; // baz is explicitly undefined Using a variable that is explicitly undefined before will trap in debug builds and is undefined behaviour in release builds.","title":"Zero init by default"}]}
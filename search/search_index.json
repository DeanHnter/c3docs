{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is C3? C3 a systems language based on C. It intends tries to be a short step up from C rather than to replace it with a new paradigm or completely new syntax. Note that C3 borrows heavily from the C2 lang project by Bas van den Berg , but differs in its more far reaching changes to macros, generics, strings and containers. Planned features Transpile to C Transpile-compile using Clang, GCC or TCC Compile directly using LLVM C to C3 compilation (for a subset of C) Module system Generic modules Zero overhead errors Struct subtyping Built-in safe arrays High level containers and string handling","title":"About C3"},{"location":"#what-is-c3","text":"C3 a systems language based on C. It intends tries to be a short step up from C rather than to replace it with a new paradigm or completely new syntax. Note that C3 borrows heavily from the C2 lang project by Bas van den Berg , but differs in its more far reaching changes to macros, generics, strings and containers.","title":"What is C3?"},{"location":"#planned-features","text":"Transpile to C Transpile-compile using Clang, GCC or TCC Compile directly using LLVM C to C3 compilation (for a subset of C) Module system Generic modules Zero overhead errors Struct subtyping Built-in safe arrays High level containers and string handling","title":"Planned features"},{"location":"buildcommands/","text":"Build Commands Compiling files directly The default for c3c is compiling stand-alone files to output a binary. c3c <file1> <file2> <file3> Common additional parameters Additional parameters: - -lib <path> add a library to search. - -output <path> override the output directory. - -path <path> execute as if standing at new c3c -new <project_name> [optional path] . Create a new project structure in the current directory. Additional parameters: - -template <path> indicate an alternative template to use. c3c -new hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world build build [target] Build the project in the current path. It doesn't matter where in the project structure you are. clean clean run run [target] Build the target (if needed) and run the executable. run-clean run-clean [target] Clean, build and run the target. dist dist [target] Clean, build and package the target. docs docs [target] Rebuilds the documentation. bench bench [target] Runs benchmarks on a target.","title":"Commands"},{"location":"buildcommands/#build-commands","text":"","title":"Build Commands"},{"location":"buildcommands/#compiling-files-directly","text":"The default for c3c is compiling stand-alone files to output a binary. c3c <file1> <file2> <file3>","title":"Compiling files directly"},{"location":"buildcommands/#common-additional-parameters","text":"Additional parameters: - -lib <path> add a library to search. - -output <path> override the output directory. - -path <path> execute as if standing at","title":"Common additional parameters"},{"location":"buildcommands/#new","text":"c3c -new <project_name> [optional path] . Create a new project structure in the current directory. Additional parameters: - -template <path> indicate an alternative template to use. c3c -new hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world","title":"new"},{"location":"buildcommands/#build","text":"build [target] Build the project in the current path. It doesn't matter where in the project structure you are.","title":"build"},{"location":"buildcommands/#clean","text":"clean","title":"clean"},{"location":"buildcommands/#run","text":"run [target] Build the target (if needed) and run the executable.","title":"run"},{"location":"buildcommands/#run-clean","text":"run-clean [target] Clean, build and run the target.","title":"run-clean"},{"location":"buildcommands/#dist","text":"dist [target] Clean, build and package the target.","title":"dist"},{"location":"buildcommands/#docs","text":"docs [target] Rebuilds the documentation.","title":"docs"},{"location":"buildcommands/#bench","text":"bench [target] Runs benchmarks on a target.","title":"bench"},{"location":"buildintro/","text":"Build System PLEASE NOTE this is just a spec of how the build system might work.","title":"Introduction"},{"location":"buildintro/#build-system","text":"PLEASE NOTE this is just a spec of how the build system might work.","title":"Build System"},{"location":"builtinmacros/","text":"Built-in macros There are several built-in macros to inspect the code during compile and runtime. @bitcast @cast @describe @elements @name @sizeof @typeof @bitcast Bitcast reinterprets the contents of a variable without any conversion. Bitsize must be the same for both types. float f = 12.3; int i = @bitcast(int, f); printf(\"%x\", i); // Prints 4144cccd @cast Cast one type to the other using the default conversion rules. Bit extension or truncation may occur. float f = 12.3; int i = @cast(int, f); printf(\"%d\", i); // Prints 12 @describe Creates a runtime description of a value. type FooEnum enum { A, B } func char[] test() { FooEnum x = FooEnum.A; return @describe(x); // Returns \"FooEnum.A\" } type Foo struct { int x; char[] y; } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @describe(x); // Returns \"Foo { x: 2, y: \"bar\" }\" } @elements Returns an array of an error set or enum set. FooEnum[] values = @elements(FooEnum); // Same as FooEnum[] values = { FooEnum.A, FooEnum.B }; @name Creates a runtime name of a value. func char[] test() { FooEnum x = FooEnum.B; return @name(x); // Returns \"A\" } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @name(x); // Returns \"Foo\" } @offset Returns the byte offset in a structure, like offsetof in C @offset(Foo, y); // => returns 4 or 8 @sizeof Returns the size of a type or an expression func usize size_test() { return @sizeof(Foo); // Might compile to 16 } func usize size_test2() { return @sizeof(size_test()); // Usually returns 8 (the size of usize) } @typeof Returns the type of an expression @typeof(size_test()) x = size_test(); @typeof(x) y = x + 1;","title":"Built-in Macros"},{"location":"builtinmacros/#built-in-macros","text":"There are several built-in macros to inspect the code during compile and runtime. @bitcast @cast @describe @elements @name @sizeof @typeof","title":"Built-in macros"},{"location":"builtinmacros/#bitcast","text":"Bitcast reinterprets the contents of a variable without any conversion. Bitsize must be the same for both types. float f = 12.3; int i = @bitcast(int, f); printf(\"%x\", i); // Prints 4144cccd","title":"@bitcast"},{"location":"builtinmacros/#cast","text":"Cast one type to the other using the default conversion rules. Bit extension or truncation may occur. float f = 12.3; int i = @cast(int, f); printf(\"%d\", i); // Prints 12","title":"@cast"},{"location":"builtinmacros/#describe","text":"Creates a runtime description of a value. type FooEnum enum { A, B } func char[] test() { FooEnum x = FooEnum.A; return @describe(x); // Returns \"FooEnum.A\" } type Foo struct { int x; char[] y; } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @describe(x); // Returns \"Foo { x: 2, y: \"bar\" }\" }","title":"@describe"},{"location":"builtinmacros/#elements","text":"Returns an array of an error set or enum set. FooEnum[] values = @elements(FooEnum); // Same as FooEnum[] values = { FooEnum.A, FooEnum.B };","title":"@elements"},{"location":"builtinmacros/#name","text":"Creates a runtime name of a value. func char[] test() { FooEnum x = FooEnum.B; return @name(x); // Returns \"A\" } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @name(x); // Returns \"Foo\" }","title":"@name"},{"location":"builtinmacros/#offset","text":"Returns the byte offset in a structure, like offsetof in C @offset(Foo, y); // => returns 4 or 8","title":"@offset"},{"location":"builtinmacros/#sizeof","text":"Returns the size of a type or an expression func usize size_test() { return @sizeof(Foo); // Might compile to 16 } func usize size_test2() { return @sizeof(size_test()); // Usually returns 8 (the size of usize) }","title":"@sizeof"},{"location":"builtinmacros/#typeof","text":"Returns the type of an expression @typeof(size_test()) x = size_test(); @typeof(x) y = x + 1;","title":"@typeof"},{"location":"contribute/","text":"Currently C3 is being designed it means that there is no compiler yet. If you'd like to contribute: Discuss the language on the r/ProgrammingLanguages Discord https://discord.gg/RczBvt Suggest improvements (send them to christoffer@aegik.com) Offer to work on the compiler","title":"Contribute"},{"location":"conversion/","text":"Number conversions and promotions C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast float to boolean conversions do not require a cast. int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 double to float conversion is allowed, but may be set to warn narrowing integer conversions require a cast widening conversions do not require a cast signed/unsigned int conversions work differently from C as detailed below float to bool do not require a cast, any non zero float value considered true C3 uses two's complement arithmetic for all integer math. Signed/unsigned int conversions In C, the can be simply described as \"convert to the type with the largest positive value\" (aside from the promotion up to int). Consequently a signed int + unsigned int converts to unsigned int. In C3, the sign is considered more important. Consequently the conversion with mixed signed / unsigned will always be converted to a signed value. The rule is as follows: Find the largest bit size of the two operands. If either is signed: convert to a signed integer of the largest bit size. If both are unsigned: convert to an unsigned integer of the largest bit size. bool byte ushort uint ulong char short int long byte bool byte ushort uint ulong char short int long byte byte byte ushort uint ulong char short int long ushort ushort ushort ushort uint ulong short short int long uint uint uint uint uint ulong int int int long ulong ulong ulong ulong ulong ulong long long long long char char char short int long char short int long short short short short int long short short int long int int int int int long int int int long long long long long long long long long long long","title":"Number conversions and promotions"},{"location":"conversion/#number-conversions-and-promotions","text":"C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast float to boolean conversions do not require a cast. int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 double to float conversion is allowed, but may be set to warn narrowing integer conversions require a cast widening conversions do not require a cast signed/unsigned int conversions work differently from C as detailed below float to bool do not require a cast, any non zero float value considered true C3 uses two's complement arithmetic for all integer math.","title":"Number conversions and promotions"},{"location":"conversion/#signedunsigned-int-conversions","text":"In C, the can be simply described as \"convert to the type with the largest positive value\" (aside from the promotion up to int). Consequently a signed int + unsigned int converts to unsigned int. In C3, the sign is considered more important. Consequently the conversion with mixed signed / unsigned will always be converted to a signed value. The rule is as follows: Find the largest bit size of the two operands. If either is signed: convert to a signed integer of the largest bit size. If both are unsigned: convert to an unsigned integer of the largest bit size. bool byte ushort uint ulong char short int long byte bool byte ushort uint ulong char short int long byte byte byte ushort uint ulong char short int long ushort ushort ushort ushort uint ulong short short int long uint uint uint uint uint ulong int int int long ulong ulong ulong ulong ulong ulong long long long long char char char short int long char short int long short short short short int long short short int long int int int int int long int int int long long long long long long long long long long long","title":"Signed/unsigned int conversions"},{"location":"documentation/","text":"","title":"Documentation"},{"location":"errorhandling/","text":"Error Handling Unlike usual exception handling, errors in C3 build on normal returns. A function declaring errors using the throws keyword essentially returns a union containing either the return value or an 64 bit integer. A register or a flag is used to determine if the result is an error or a normal result. Because there is no stack unwinding, error handling is completely deterministic and has no additional runtime cost. The call of a function which returns an error must be preceeded by the keyword try . Error returns From C, a function throwing an error value appears simply as a union: C3 code: func int getValue() throws Corresponding C code: struct Result { char error; union { int res; uint64_t err_code; }; }; struct Result getValue(); It is possible to extract the error code and also store it, to retrieve it later: try openFile(\"foo.txt\"); catch (error err) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @name(err)); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @describe(err)); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", @cast(ulong, err)); } Some simple examples. Defining an error set type FileError error { FILE_NOT_FOUND, FILE_CANNOT_OPEN, PATH_DOES_NOT_EXIST, } Throwing an error func void findFile() throws { if (File.doesFileExist(\"foo.txt\")) throw FileError.FILE_NOT_FOUND; /* ... */ } Declaring a function as throwing a specific set of errors func void findFile() throws FileError { /* ... */ } Declaring a function to throw a union of errors func void findAndParseFile() throws FileError, ParseError { /* ... */ } Calling a function that throws func void findFileAndTest() throws { try findFile(); } Catching errors func void findFileAndNoExcept() { try findFile(); catch (error err) { printf(\"An error occurred!\\n\"); return; } } Catching error subsets func void findFileAndParse2() throws ParseError { try findFileAndParse(); catch (FileError err) { printf(\"Error loading the file!\\n\"); return; } // No catch for the ParseError, so it escapes. } Scoped error catching func void testErrorScopes() { { try findFileAndParse(); catch (FileError err) { try sendAlarm(\"Error loading the file\"); catch (error err) { printf(\"Failed to send the alarm\"); } return; } } try someOtherCall(); catch (error err) { printf(\"Some other error\\n\"); } } Default values func int testDefault() { return try getIntNumberOrFail() else -1; }","title":"Errors"},{"location":"errorhandling/#error-handling","text":"Unlike usual exception handling, errors in C3 build on normal returns. A function declaring errors using the throws keyword essentially returns a union containing either the return value or an 64 bit integer. A register or a flag is used to determine if the result is an error or a normal result. Because there is no stack unwinding, error handling is completely deterministic and has no additional runtime cost. The call of a function which returns an error must be preceeded by the keyword try .","title":"Error Handling"},{"location":"errorhandling/#error-returns","text":"From C, a function throwing an error value appears simply as a union: C3 code: func int getValue() throws Corresponding C code: struct Result { char error; union { int res; uint64_t err_code; }; }; struct Result getValue(); It is possible to extract the error code and also store it, to retrieve it later: try openFile(\"foo.txt\"); catch (error err) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @name(err)); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @describe(err)); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", @cast(ulong, err)); }","title":"Error returns"},{"location":"errorhandling/#some-simple-examples","text":"","title":"Some simple examples."},{"location":"errorhandling/#defining-an-error-set","text":"type FileError error { FILE_NOT_FOUND, FILE_CANNOT_OPEN, PATH_DOES_NOT_EXIST, }","title":"Defining an error set"},{"location":"errorhandling/#throwing-an-error","text":"func void findFile() throws { if (File.doesFileExist(\"foo.txt\")) throw FileError.FILE_NOT_FOUND; /* ... */ }","title":"Throwing an error"},{"location":"errorhandling/#declaring-a-function-as-throwing-a-specific-set-of-errors","text":"func void findFile() throws FileError { /* ... */ }","title":"Declaring a function as throwing a specific set of errors"},{"location":"errorhandling/#declaring-a-function-to-throw-a-union-of-errors","text":"func void findAndParseFile() throws FileError, ParseError { /* ... */ }","title":"Declaring a function to throw a union of errors"},{"location":"errorhandling/#calling-a-function-that-throws","text":"func void findFileAndTest() throws { try findFile(); }","title":"Calling a function that throws"},{"location":"errorhandling/#catching-errors","text":"func void findFileAndNoExcept() { try findFile(); catch (error err) { printf(\"An error occurred!\\n\"); return; } }","title":"Catching errors"},{"location":"errorhandling/#catching-error-subsets","text":"func void findFileAndParse2() throws ParseError { try findFileAndParse(); catch (FileError err) { printf(\"Error loading the file!\\n\"); return; } // No catch for the ParseError, so it escapes. }","title":"Catching error subsets"},{"location":"errorhandling/#scoped-error-catching","text":"func void testErrorScopes() { { try findFileAndParse(); catch (FileError err) { try sendAlarm(\"Error loading the file\"); catch (error err) { printf(\"Failed to send the alarm\"); } return; } } try someOtherCall(); catch (error err) { printf(\"Some other error\\n\"); } }","title":"Scoped error catching"},{"location":"errorhandling/#default-values","text":"func int testDefault() { return try getIntNumberOrFail() else -1; }","title":"Default values"},{"location":"examples/","text":"if-statement func void if_example(int a) { if (a > 0) { // .. } else { // .. } } for-loop func void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io.printf(\"%d\\n\", i); } // also equal for (;;) { // .. } } while-loop func void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } } In-block declarations Any control structure may declare block level variables. func void example_if_while_for() { // a is initialized only once, when entering the while statement while (int a = 10; a > 0) { a--; } // a is initialized every time through the loop. while (int a = foo()) { // ... } // a is initialized once, but assigned every time through the loop. while (int a = 0; a = foo()) { // ... } if (int a = foo(), long b = bar(); a > 1) return @cast(int, a + b); for (int a = 0, long b = 0; a < 10; a++) { b += foo(); if (b > 10) break; } } enum + switch Switches have implicit break and scope. Use \"next\" to implicitly fallthrough or use comma: type Height enum u32 { LOW = 0, MEDIUM, HIGH, } func void demo_enum(Height h) { switch (h) { case Height.LOW, Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // This also works switch (h) { case Height.LOW, case Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // Completely empty cases are not allowed. switch (h) { case Height.LOW: break; // Explicit break required, since switches can't be empty. case Height.MEDIUM: io.printf(\"Medium\"); case Height.HIGH: break; } // special checking of switching on enum types switch (h) { case Height.LOW, case Height.MEDIUM, case Height.HIGH, break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"next\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case Height.LOW: int a = 1; printf(\"A\\n\"); next; case Height.MEDIUM, int a = 2; printf(\"B\\n\"); next; case Height.HIGH, // a is not defined here printf(\"C\\n\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .all returns an array with all enums. type State enum uint { Start, Stop, } const uint lowest = State.min; const uint highest = State.max; State start = State.all[0]; defer Defer will be invoked on scope exit. func void test(int x) { defer printf(\"A\"); if (x = 1) return; { defer printf(\"B\"); if (x == 0) return; } printf(\"!\") } test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"!BA\" Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. func void test(int x) { defer printf(\"A\"); defer catch printf(\"B\") defer catch (error e) printf(\"%s\", @name(e)); if (x = 1) return throw Error.FOO; printf(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and throws struct types type Callback func int(char c); type Status enum int { IDLE, BUSY, DONE, } type MyData struct { const char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } } Function pointers module demo; type Callback func int(const char* text, int value); // also shows function attribute func int my_callback(const char* text, int value) @(unused_params) { return 0; } Callback cb = demo.my_callback; func void example_cb() { int result = cb(\"demo\", 123); // .. } Error handling Errors are sent as a result value but uses an exception-like try/catch syntax. type RandomError error { NORMAL, EXCEPTIONAL } func int mayThrowError() throws RandomError { if (rand() > 0.5) throw RandomError.NORMAL; if (rand() > 0.99) throw RandomError.EXCEPTIONAL; return 1; } func void testMayError() throws { // all throwable sites must be annotated with \"try\" try mayThrowError(); } func void testWithoutError() { try testMayError(); // Catching will catch any try above in the scope. catch (error e) { case RandomError.NORMAL: io.printf(\"Normal Error\\n\"); case RandomError.EXCEPTIONAL: io.printf(\"You win!\"); default: io.printf(\"What is this error you're talking about?\"); } } Pre and post conditions Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure testFoo < 10000, testFoo > 0 **/ func int testFoo(int foo) { return foo * 10; } /** * @param array : the array to test * @param length : length of the array * @require length > 0 **/ func int getLastElement(int? array, int length) { return array[length - 1]; } Macros Macro arguments may be immediately evaluated. macro foo(a, b) { return *a(b); } func int square(int x) { return x * x; } func int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion. macro foo(&a, b, &c) { c = a(b) * b; } macro foo2(&a) { return a * a; } func int square(int x) { return x * x; } func int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } func int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x : value to square * @require x * x >= 0 : \"cannot multiply\" **/ macro square(x) { return x * x; } func void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' } Nullability annotations Use & for nullable pointers, * for non nullable pointers. func Foo* getFoo() { ... } func Foo& getFooNotNull() { ... } func testThings() { int i; Foo* foo1 = getFoo(); // i = foo1.intVal; // Error, reference may be null Foo& foo2 = getFooNotNull(); i = foo2.intVal; assert(foo1); i = foo1.intVal; }","title":"Examples"},{"location":"examples/#if-statement","text":"func void if_example(int a) { if (a > 0) { // .. } else { // .. } }","title":"if-statement"},{"location":"examples/#for-loop","text":"func void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io.printf(\"%d\\n\", i); } // also equal for (;;) { // .. } }","title":"for-loop"},{"location":"examples/#while-loop","text":"func void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } }","title":"while-loop"},{"location":"examples/#in-block-declarations","text":"Any control structure may declare block level variables. func void example_if_while_for() { // a is initialized only once, when entering the while statement while (int a = 10; a > 0) { a--; } // a is initialized every time through the loop. while (int a = foo()) { // ... } // a is initialized once, but assigned every time through the loop. while (int a = 0; a = foo()) { // ... } if (int a = foo(), long b = bar(); a > 1) return @cast(int, a + b); for (int a = 0, long b = 0; a < 10; a++) { b += foo(); if (b > 10) break; } }","title":"In-block declarations"},{"location":"examples/#enum-switch","text":"Switches have implicit break and scope. Use \"next\" to implicitly fallthrough or use comma: type Height enum u32 { LOW = 0, MEDIUM, HIGH, } func void demo_enum(Height h) { switch (h) { case Height.LOW, Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // This also works switch (h) { case Height.LOW, case Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // Completely empty cases are not allowed. switch (h) { case Height.LOW: break; // Explicit break required, since switches can't be empty. case Height.MEDIUM: io.printf(\"Medium\"); case Height.HIGH: break; } // special checking of switching on enum types switch (h) { case Height.LOW, case Height.MEDIUM, case Height.HIGH, break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"next\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case Height.LOW: int a = 1; printf(\"A\\n\"); next; case Height.MEDIUM, int a = 2; printf(\"B\\n\"); next; case Height.HIGH, // a is not defined here printf(\"C\\n\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .all returns an array with all enums. type State enum uint { Start, Stop, } const uint lowest = State.min; const uint highest = State.max; State start = State.all[0];","title":"enum + switch"},{"location":"examples/#defer","text":"Defer will be invoked on scope exit. func void test(int x) { defer printf(\"A\"); if (x = 1) return; { defer printf(\"B\"); if (x == 0) return; } printf(\"!\") } test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"!BA\" Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. func void test(int x) { defer printf(\"A\"); defer catch printf(\"B\") defer catch (error e) printf(\"%s\", @name(e)); if (x = 1) return throw Error.FOO; printf(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and throws","title":"defer"},{"location":"examples/#struct-types","text":"type Callback func int(char c); type Status enum int { IDLE, BUSY, DONE, } type MyData struct { const char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } }","title":"struct types"},{"location":"examples/#function-pointers","text":"module demo; type Callback func int(const char* text, int value); // also shows function attribute func int my_callback(const char* text, int value) @(unused_params) { return 0; } Callback cb = demo.my_callback; func void example_cb() { int result = cb(\"demo\", 123); // .. }","title":"Function pointers"},{"location":"examples/#error-handling","text":"Errors are sent as a result value but uses an exception-like try/catch syntax. type RandomError error { NORMAL, EXCEPTIONAL } func int mayThrowError() throws RandomError { if (rand() > 0.5) throw RandomError.NORMAL; if (rand() > 0.99) throw RandomError.EXCEPTIONAL; return 1; } func void testMayError() throws { // all throwable sites must be annotated with \"try\" try mayThrowError(); } func void testWithoutError() { try testMayError(); // Catching will catch any try above in the scope. catch (error e) { case RandomError.NORMAL: io.printf(\"Normal Error\\n\"); case RandomError.EXCEPTIONAL: io.printf(\"You win!\"); default: io.printf(\"What is this error you're talking about?\"); } }","title":"Error handling"},{"location":"examples/#pre-and-post-conditions","text":"Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure testFoo < 10000, testFoo > 0 **/ func int testFoo(int foo) { return foo * 10; } /** * @param array : the array to test * @param length : length of the array * @require length > 0 **/ func int getLastElement(int? array, int length) { return array[length - 1]; }","title":"Pre and post conditions"},{"location":"examples/#macros","text":"Macro arguments may be immediately evaluated. macro foo(a, b) { return *a(b); } func int square(int x) { return x * x; } func int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion. macro foo(&a, b, &c) { c = a(b) * b; } macro foo2(&a) { return a * a; } func int square(int x) { return x * x; } func int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } func int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x : value to square * @require x * x >= 0 : \"cannot multiply\" **/ macro square(x) { return x * x; } func void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' }","title":"Macros"},{"location":"examples/#nullability-annotations","text":"Use & for nullable pointers, * for non nullable pointers. func Foo* getFoo() { ... } func Foo& getFooNotNull() { ... } func testThings() { int i; Foo* foo1 = getFoo(); // i = foo1.intVal; // Error, reference may be null Foo& foo2 = getFooNotNull(); i = foo2.intVal; assert(foo1); i = foo1.intVal; }","title":"Nullability annotations"},{"location":"firstproject/","text":"Your First Project Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import stdio; public func int main(int argc, char*[] argv) { printf(\"Hello World!\\n\"); return 0; } Now in the terminal type: $ c3c hello_world.c3 $ ./hello_world.a Hello World $ A real project Once you go beyond simple files, you want to create a real project. Do so by entering c3c -new hello_world . You will get the following structure: $ c3c -new hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"Your first project"},{"location":"firstproject/#your-first-project","text":"Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import stdio; public func int main(int argc, char*[] argv) { printf(\"Hello World!\\n\"); return 0; } Now in the terminal type: $ c3c hello_world.c3 $ ./hello_world.a Hello World $","title":"Your First Project"},{"location":"firstproject/#a-real-project","text":"Once you go beyond simple files, you want to create a real project. Do so by entering c3c -new hello_world . You will get the following structure: $ c3c -new hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"A real project"},{"location":"generics/","text":"Generics Generic functionality is mostly provided by macros and generic modules. Bridging the gap is generic functions, that allow a limited for of overloading. Generic functions Generic functions is a specialized type of macros. They allow overloading using a common symbol, just like C11 _Generic: generic abs(x) { case double: return fabs(x); case int: return abs(x); } Unlike a regular macro, a generic function is not invoked with @. It may also be extended by other packages / files: // File 1 module foo; generic abs(x) { case double: return fabs(x); case int: return abs(x); } // File 2 module bar; generic foo.abs(x) { case long: return absl(x); case int: // Compile time error, already defined return abs(x); } It is possible to dispatch on multiple arguments: module foo; generic add(x, y) { case double, double: return x + y; case int, double: return (double)x + y; } Generics can also be used for overloading operators, although this is limited to the usual arithmetic operators. generic operator_add(x, y) { case vector3, vector3: return vector_add(x, y); } Note that generics is actually a macro expansion. Consequently this is possible: generic weird_fun(x) { case int: printf(\"%d\", x); case Foo: while (foo.bar > 0) { foo.bar--; printf(\"Hi\"); } } void func test() { Foo foo; weird_fun(2); // Prints \"2\" foo.bar = 4; wierd_fun(foo); // Prints \"HiHiHiHi\" } Shorthand There is also a shorthand for declaring generics that only match a single type \u2013 it's done by declaring the types directly in the header: generic add(double x, double y) { return x + y; } Generic modules Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: module vector (A, B, C); // A, B, C are generic parameters. The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test (A, B); type Foo struct { A a; } func C test(B b, Foo *foo) { return a + b; } When including a generic module, the generic parameters specified in the import, but must be aliased or imported as local . If local , more than one generic of the type may not be used. import vector(double, float, int) as generic_test; import foo(int, int) local; // import foo(float, float) local; \u2013 Not allowed Just like for macros, optional constraints may be added to improve compile errors: /** * @require c = a + b */ module vector (A, B, C); /* .. code * ../ import vector(Bar, f32, i32) as gen_test; // This would give the error // --> Illegal arguments for generic module vector, breaks requirement 'Bar' = 'f32' + 'i32'","title":"Generics"},{"location":"generics/#generics","text":"Generic functionality is mostly provided by macros and generic modules. Bridging the gap is generic functions, that allow a limited for of overloading.","title":"Generics"},{"location":"generics/#generic-functions","text":"Generic functions is a specialized type of macros. They allow overloading using a common symbol, just like C11 _Generic: generic abs(x) { case double: return fabs(x); case int: return abs(x); } Unlike a regular macro, a generic function is not invoked with @. It may also be extended by other packages / files: // File 1 module foo; generic abs(x) { case double: return fabs(x); case int: return abs(x); } // File 2 module bar; generic foo.abs(x) { case long: return absl(x); case int: // Compile time error, already defined return abs(x); } It is possible to dispatch on multiple arguments: module foo; generic add(x, y) { case double, double: return x + y; case int, double: return (double)x + y; } Generics can also be used for overloading operators, although this is limited to the usual arithmetic operators. generic operator_add(x, y) { case vector3, vector3: return vector_add(x, y); } Note that generics is actually a macro expansion. Consequently this is possible: generic weird_fun(x) { case int: printf(\"%d\", x); case Foo: while (foo.bar > 0) { foo.bar--; printf(\"Hi\"); } } void func test() { Foo foo; weird_fun(2); // Prints \"2\" foo.bar = 4; wierd_fun(foo); // Prints \"HiHiHiHi\" }","title":"Generic functions"},{"location":"generics/#shorthand","text":"There is also a shorthand for declaring generics that only match a single type \u2013 it's done by declaring the types directly in the header: generic add(double x, double y) { return x + y; }","title":"Shorthand"},{"location":"generics/#generic-modules","text":"Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: module vector (A, B, C); // A, B, C are generic parameters. The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test (A, B); type Foo struct { A a; } func C test(B b, Foo *foo) { return a + b; } When including a generic module, the generic parameters specified in the import, but must be aliased or imported as local . If local , more than one generic of the type may not be used. import vector(double, float, int) as generic_test; import foo(int, int) local; // import foo(float, float) local; \u2013 Not allowed Just like for macros, optional constraints may be added to improve compile errors: /** * @require c = a + b */ module vector (A, B, C); /* .. code * ../ import vector(Bar, f32, i32) as gen_test; // This would give the error // --> Illegal arguments for generic module vector, breaks requirement 'Bar' = 'f32' + 'i32'","title":"Generic modules"},{"location":"ideas/","text":"Ideas WARNING Unfinished ideas / brain dumps Unsorted Remove volatile Volatile is almost always wrong on a variable. Instead we introduce volatile sections: int a = 0; for (int i = 0; i < 10; i++) { @volatile { a = 1; // Never optimized. } } Remove const There is an issue with correct const handling. Not only are the qualifiers a bit hard to read. Const also lacks transitiveness. Const is not a guarantee of immutability, just a way to document that the pointer does not change. Replace this with optional comments: /** * @param foo const * @param bar **/ func void do_something(Foo* foo, Foo* bar) { foo.x = 0; // Warning, breaks contract above. foo.z.y = 0; // Warning, also breaks contract due to being transitive. bar.x = 0; // This is fine. } Require explicit uninitialization int a = ---; int a = void; // Other possible variant Defer sugar func bool do_stuff(i32 resource_id) { Resource* x = get_resource(resource_id) @defer(release_resource); // Inline defer if (!play_around_with(x)) return false; do_some_other_thing(x); return foo(x); } Defer on function signatures func Resource get_resource_with_release(int resource_id) @defer(release_resource); func bool do_stuff(i32 resource_id) { Resource* x = get_resource_with_release(resource_id); // inserts an implicit defer! if (!play_around_with(x)) return false; do_some_other_thing(x); return foo(x); } \"Managed\" qualifier // func const FILE open(...) { ... } => func const managed FILE open(...) { ... } And here any struct that is \"managed\" must have a StructName.release(StructName *struct) call. Extended \"case\" Switch as \"if-else\" switch (x) { case x > 200: return 0; case x < 2: small_x_warning(); case 0: .... case x > y && a < 1: ... } Case as a range switch (x) { case 1 .. 10: ... case 11 .. 100: ... } Easy to get properties Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports Associate properties to an enum type enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" } Tagged unions tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: type Shape struct { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And yet another... type Shape struct { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; } Interfaces func void Foo.renderPage(Foo& foo, Page& info) { /* ... */ } type Renderer interface { void renderPage(Renderer& renderer, Page& info) } func void render(Renderer* renderer, Page& info) { if (rendered == null) return; renderer->renderPage(info); } func void test() { Foo* foo = getFoo(); Page& page = getPage(); // Option 1 Renderer.render(foo, page); // Option 2 Renderer* renderer = foo; renderer.render(page); } // C equivalent: // struct RendererVtable { // void (*renderPage)(void*, Page*); // }; // struct RendererRef { // void* ref; RendererVTable *vtable; // }; // void Renderer__render(struct RendererRef renderer, Page *info) { // if (renderer.ref == null) return; // renderer.vtable->renderPage(renderer.ref, info); // } // // void test() { // Foo *foo = getFoo(); // Page *page = getPage(); // // static RenderVTable FooRendererVTable = { &Foo__renderPage }; // Renderer__render(struct RendererRef { foo, &FooRendererVTable }, page); // // struct RendererRef renderer = { foo, &FooRendererVTable }; // Renderer__render(renderer, page); // } Possible syntax ideas: func void test() { Renderer* renderer1 = getFoo(); // Implicit Renderer* renderer2 = Renderer(getFoo()); Renderer* renderer3 = getFoo() as Renderer; Renderer* renderer4 = @wrap(Renderer, getFoo()); // Macro Renderer renderer5 = getFoo(); // Look, no pointer! Renderer@ renderer6 = getFoo(); // Special pointer type? interface Renderer renderer7 = getFoo(); // Love long lines @Renderer renderer8 = getFoo(); Renderer^ renderer9 = getFoo(); // Pascal Renderer renderer10 = interface getFoo(); Renderer renderer11 = interface(getFoo()); Renderer renderer12 = virtual { getFoo() }; virtual Renderer renderer13 = getFoo(); virtual Renderer renderer14 = getFoo(); } func void render(Renderer renderer, Page& info) { renderer.renderPage(info); } virtual Renderer { void renderPage(Page &info); } func void render(virtual Renderer& renderer, Page& info) { renderer.renderPage(info); } func void render(virtual Renderer& renderer, Page& info) { renderer->renderPage(info); } func void render(interface Renderer& renderer, Page& info) { renderer->renderPage(info); } interface Renderer*[4] renderers; interface Renderer[4] renderers; virtual Renderer[4] renderers; Renderer*[4] renderers; Built in dynamic arrays // Pseudo code type _DynamicArray struct { A* data; usize capacity; usize size; } /** * @require array.size > 0 */ func A pop(_DynamicArray& array) { return array.data[--array.size]; } /** * @require array.size > 0 */ func A +=(_DynamicArray& array, A a) { if (capacity == size) array.increase_capacity(); return array.data[array.size] = a; } We could construct this using generics, but it is much more convenient to have a syntax built in. Question: what about memory management? int[+] dynamic_array; // Built-in dynamic arrays dynamic_array += 23; dynamic_array.pop(); dynamic_array.insert(0, 11); dynamic_array.insert_front(12); io.printf(\"%d\", dynamic_array[1]); // Prints 11 // It's possible to extend dynamic arrays with functionality: func usize int[+].find(int[+] &array, int value) { for (usize i = 0; i < dynamic_array.size; i++) { if (array[i] == value) return i; } return NOT_FOUND; } // This works if the function is in the same module // or if it's included as local dynamic_array.find(12); // => 0 // If it's in another module: module_name.int[+].find(dynamic_array, 12); Built in maps Same reasoing as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = try map[0]; // Requires a try // Retrive or use default int i = try map[12] else -1; // Extend a map: func bool int[int].remove_if_negative(int[int] &map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int &map, int32_t index); Built in string type Strings are built-in, refcounted(?) null-terminated character arrays. Take a long hard look at memory management (here too) string = \"Hello\"; string += \" World\"; char* data = &string; // Taking a pointer to the string, which may later be invalid. Built in managed pointers Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check. Sample code for (2) type Foo struct @(refcounted) { int a; } func Bar(Foo@ a) { printf(\"%d\\n\", sizeof(Foo)); // prints 8 due to RC printf(\"%d\\n\", rc(a)); // prints 1 Foo@ x = a; printf(\"%d\\n\", rc(a)); // prints 2 x = nil; printf(\"%d\\n\", rc(a)); // prints 1 Foo* y = a; printf(\"%d\\n\", rc(a)); // prints 1 Foo* z = malloc(sizeof(Foo)); // Not recommended! // TOOD discuss how to properly initialize a RC:ed variable. } Ideas around macros Just some previous thoughts and ideas I've considered. Many of those actually go against the current design. Compile time variables This is a variant of what already exists in C, but in a syntactically more friendly way. For example this would be ok: macro swap(a, b) { $x = typeof(a); static_assert(typeof(b) == $x); $x temp = a; a = b; b = a; } The example above is a bit contrived as in the above example we could simply have: macro swap(a, b) { static_assert(typeof(b) == typeof(b)); typeof(a) temp = a; a = b; b = a; } But still, it serves as an example on how to use it. Capturing trailing compound statement public macro foreach(thelist, @body(Element *) ) { Element* iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Or a version that is more flexible: public macro foreach(thelist, @body(typeof(thelist.first)) ) { typeof(thelist.first) iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } // Usage: foreach(list, Element *i) // <- Note type declaration! { i.print(); } Since type is going to appear very often, we could make a shortcut for it, like $@ as prefix meaning \"typeof\". We then get public macro foreach(thelist, @body($@thelist.first)) { $@thelist.first iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Possibly one could even write the code like this: public macro foreach(thelist, @body($element_type) ) { $element_type iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } In this case $element_type works like \"auto\", but is also assigned the type, which then can be referred to in the signature. Yet another way to do macros :D This was an older attempt... First, we have to consider macros as always expanding where they are referenced to keep it simple. macro @foo(int v) { v++; if (v > 10) return 10; return v; } func void test() { int a = 10; @foo(a); } This code would then be exactly equal to: func void test() { int a = 10; a++; if (a > 10) return 10; } Macros simply expand in place. Secondly, we can have macros returning values: macro int @foo2(int v, int w) { v++; if (v > 10) return 10; w += 3; return 0; } func void test() { int d = 0; int a = 10; int b = @foo(a, d); } This expands to: func void test() { int d = 0; int a = 10; a++ int b; if (a > 10) { b = 10; } else { b = 0; d += 3; } } Note that I'm using a sigil to indicate the code expansion to make macros more obvious. We can allow the macro to take a body (here I'm calling the type of the body \"{}\") macro int @foo3(int a, {} body) { while (a > 10) { a--; @body(); // Like a macro! } } func void test() { b = 20; @foo3(b) { print(b); } } We expand this to: func void test() { b = 20; while (b > 10) { b--; print(b); } } Stepwise from C macros into C3 macros #define ADD_TO(x, y) { x += y; } ADD_TO(x, 1) The { } introduces a multiline macro that does not need explicit linebreaks. No, add the \"$\" symbol to introduce hygienic temporaries: #define SWAP(x, y) { typeof(x) $tmp = x; x = y; y = $tmp; } Here $tmp will actually be replaced by __<macro>_<variable_name>_<instance> when translating to C, so __SWAP_tmp_1 , __SWAP_tmp_2 etc. We then introduce the syntax macros using: macro swap(&a, &b) { typeof(a) $tmp = a; b = a; a = $tmp; } (Note the different use of $ here as compared to previous macro ideas where $ is a compile time evaluated variable!) The use of &a follows C++ standard: it simply refers to a variable OR EXPRESSION that is imported into its scope. Using the unadorned variable name as evaluated expression allows us to write this code: macro max(a, b) { return (a > b ? a : b) } The above code is equivalent to: macro max(&a, &b) { typeof(a) $tmp_a = a; typeof(b) $tmp_b = b; $tmp_a > $tmp_b ? $tmp_a : $tmp_b } Or in (GNU) C: #define max(a,b) \\ ({ __typeof__ (a) _a = (a); \\ __typeof__ (b) _b = (b); \\ _a > _b ? _a : _b; }) To recap: Add the { } format to #define for multiline defines. Add $<name> format as hygienic variable names. Add the syntax \"macro\" type of definition. The syntax macro makes a difference between \"normal\" parameters (with & as prefix) and \"evaluated\" parameters (unadorned variables) Important is also to scope the macros: #define is always defined local to a scope (unlike in C). This means that #define FOO printf(\"foo\"); { #define BAR printf(\"bar\"); } FOO // adds printf(\"foo\"); BAR; // Error, define not available in scope; This also means that a define can be declared public to be accessed as if defined from the top of the file scope: // file 1 module foo public #define FOO { printf(\"FOO!\\n\"); } // file 2 import foo func void test() { foo.FOO } Only defines in the file scope that exists in the file scope may be public and used in other modules. Yet another macro proposal I found Simple macros macro @foo(&b) { b++; } func test() { int x = 1; @foo(x); } // Same as: func void test() { int x = 1; x++; } Macro with compile time values: macro @foo($x, &b) { b += $x; } func void test() { int x = 1; @foo(10, x); } // Expands to: func void test() { int x = 1; x += 10; } Macro with string capture macro @foo($x, #f) { `#f $x * $x`; } func void test() { i32 x = 1; @foo(4, \"x += \"); } // Expands to func void test() { i32 x = 1; x += 4 * 4; } macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { i32 x = 1; @foo2(\"x\"); } // Expands to funct void test2() { i32 x = 1; printf(\"%s was %d\\n\", \"x\", x); } Macro with conditional compile time values macro @foo($x, &b) { $IF ($x > 3) { b += $x * $x; } $ELSE { b += $x; } } func void test() { i32 x = 1; @foo(10, x); @foo(2, x); } // Expands to func void test() { i32 x = 1; x += 100; x += 2; } Nested macros (don't do this, but an example) macro @foo($a) { printf(\"%d\\n\", $a); $IF($a > 0) { @foo($a - 1); } } func void test() { @foo(2); } // Expands to func void test() { printf(\"%d\\n\", 2); printf(\"%d\\n\", 1); printf(\"%d\\n\", 0); } The above suggests macro sugar of loops: macro @foo($a) { $EACH(0..$a AS $x) { printf(\"%d\\n\", $x); } } macro @foo_enum(&a) { $EACH(a AS $x) { printf(\"%d\\n\", @cast(int, $x)); } } type MyEnum enum { A, B, FOO } func void test() { @foo_enum(MyEnum); } // Expands to func void test() { printf(\"%d\\n\", @cast(int, A)); printf(\"%d\\n\", @cast(int, B)); printf(\"%d\\n\", @cast(int, FOO)); } Each may iterate over: struct members (returned as string), enums (returned as the enum value) Type group helper macro @foo(int &a) // Macro only valid for a is any type of signed integer macro @foo(integer &a) // Valid for unsigned and signed integers macro @foo(number &a) // Valid for any float or integer Macros may force non local return macro @foo() { exit 1; // other keyword? 'escape'? I think exit is good, // but clashes with function name! } func int test() { @foo(); } // expands to func int test() { return 1; } Normal return creates a statement expression macro @foo(&a) { int x = a; x++; if (x > 0) return 1; return 2; } func int test() { b = 10; int y = @foo(b); } // Expands to: func int test() { b = 10; int __macro_ret_1; do { int __macro_x = b; __macro_x++; if (__macro_x > 0) { __macro_ret_1 = 1; break; } else { __macro_ret_1 = 2; break; } } while (0); int y = __macro_ret_1; } Bodies in macros macro @foo(&a, @body) { int z = 0; while (a < 10) { @body(); z++; } } func void test() { int i = 0; @foo(i) { i += 1; } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { i += 1; __macro_z++; } } } Bodies in macros with parameters macro @foo(&a, @body(&x, $y)) { int z = 0; while (a < 10) { @body(z, 2); z++; } } func void test() { int i = 0; @foo(i) { printf(\"%d / %d\\n\", x, y); } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { printf(\"%d / %d\\n\", __macro_z, 2); __macro_z++; } } } Expression is extended to parse: MACRO_IDENT => lookup $x in current macro scope and replace it with literal. Error if not in macro. MACRO_REPLACEMENT => invoke lexer on code inside, after doing a replace of any # inside. $IF requires that the expression can be evaluated to a constant value, similar holds for the range in $EACH . The general rule: 1. An argument prefixed with $ is always something that must be constant. 2. An argument prefixed with & is always a reference to an outer variable. 3. An argument prefixed with # always matches a string. It will be expanded when lexed in `` statements 4. A $ variable can be converted to a # variable. 5. A # can be evaluated to a $ 6. $ and # cannot be assigned to, they are always constant. 7. $ , & and # will never shadow variables from the outer scope.","title":"Crazy ideas"},{"location":"ideas/#ideas","text":"WARNING Unfinished ideas / brain dumps","title":"Ideas"},{"location":"ideas/#unsorted","text":"","title":"Unsorted"},{"location":"ideas/#remove-volatile","text":"Volatile is almost always wrong on a variable. Instead we introduce volatile sections: int a = 0; for (int i = 0; i < 10; i++) { @volatile { a = 1; // Never optimized. } }","title":"Remove volatile"},{"location":"ideas/#remove-const","text":"There is an issue with correct const handling. Not only are the qualifiers a bit hard to read. Const also lacks transitiveness. Const is not a guarantee of immutability, just a way to document that the pointer does not change. Replace this with optional comments: /** * @param foo const * @param bar **/ func void do_something(Foo* foo, Foo* bar) { foo.x = 0; // Warning, breaks contract above. foo.z.y = 0; // Warning, also breaks contract due to being transitive. bar.x = 0; // This is fine. }","title":"Remove const"},{"location":"ideas/#require-explicit-uninitialization","text":"int a = ---; int a = void; // Other possible variant","title":"Require explicit uninitialization"},{"location":"ideas/#defer-sugar","text":"func bool do_stuff(i32 resource_id) { Resource* x = get_resource(resource_id) @defer(release_resource); // Inline defer if (!play_around_with(x)) return false; do_some_other_thing(x); return foo(x); }","title":"Defer sugar"},{"location":"ideas/#defer-on-function-signatures","text":"func Resource get_resource_with_release(int resource_id) @defer(release_resource); func bool do_stuff(i32 resource_id) { Resource* x = get_resource_with_release(resource_id); // inserts an implicit defer! if (!play_around_with(x)) return false; do_some_other_thing(x); return foo(x); }","title":"Defer on function signatures"},{"location":"ideas/#managed-qualifier","text":"// func const FILE open(...) { ... } => func const managed FILE open(...) { ... } And here any struct that is \"managed\" must have a StructName.release(StructName *struct) call.","title":"\"Managed\" qualifier"},{"location":"ideas/#extended-case","text":"Switch as \"if-else\" switch (x) { case x > 200: return 0; case x < 2: small_x_warning(); case 0: .... case x > y && a < 1: ... }","title":"Extended \"case\""},{"location":"ideas/#case-as-a-range","text":"switch (x) { case 1 .. 10: ... case 11 .. 100: ... }","title":"Case as a range"},{"location":"ideas/#easy-to-get-properties","text":"Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports","title":"Easy to get properties"},{"location":"ideas/#associate-properties-to-an-enum","text":"type enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" }","title":"Associate properties to an enum"},{"location":"ideas/#tagged-unions","text":"tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: type Shape struct { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And yet another... type Shape struct { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; }","title":"Tagged unions"},{"location":"ideas/#interfaces","text":"func void Foo.renderPage(Foo& foo, Page& info) { /* ... */ } type Renderer interface { void renderPage(Renderer& renderer, Page& info) } func void render(Renderer* renderer, Page& info) { if (rendered == null) return; renderer->renderPage(info); } func void test() { Foo* foo = getFoo(); Page& page = getPage(); // Option 1 Renderer.render(foo, page); // Option 2 Renderer* renderer = foo; renderer.render(page); } // C equivalent: // struct RendererVtable { // void (*renderPage)(void*, Page*); // }; // struct RendererRef { // void* ref; RendererVTable *vtable; // }; // void Renderer__render(struct RendererRef renderer, Page *info) { // if (renderer.ref == null) return; // renderer.vtable->renderPage(renderer.ref, info); // } // // void test() { // Foo *foo = getFoo(); // Page *page = getPage(); // // static RenderVTable FooRendererVTable = { &Foo__renderPage }; // Renderer__render(struct RendererRef { foo, &FooRendererVTable }, page); // // struct RendererRef renderer = { foo, &FooRendererVTable }; // Renderer__render(renderer, page); // } Possible syntax ideas: func void test() { Renderer* renderer1 = getFoo(); // Implicit Renderer* renderer2 = Renderer(getFoo()); Renderer* renderer3 = getFoo() as Renderer; Renderer* renderer4 = @wrap(Renderer, getFoo()); // Macro Renderer renderer5 = getFoo(); // Look, no pointer! Renderer@ renderer6 = getFoo(); // Special pointer type? interface Renderer renderer7 = getFoo(); // Love long lines @Renderer renderer8 = getFoo(); Renderer^ renderer9 = getFoo(); // Pascal Renderer renderer10 = interface getFoo(); Renderer renderer11 = interface(getFoo()); Renderer renderer12 = virtual { getFoo() }; virtual Renderer renderer13 = getFoo(); virtual Renderer renderer14 = getFoo(); } func void render(Renderer renderer, Page& info) { renderer.renderPage(info); } virtual Renderer { void renderPage(Page &info); } func void render(virtual Renderer& renderer, Page& info) { renderer.renderPage(info); } func void render(virtual Renderer& renderer, Page& info) { renderer->renderPage(info); } func void render(interface Renderer& renderer, Page& info) { renderer->renderPage(info); } interface Renderer*[4] renderers; interface Renderer[4] renderers; virtual Renderer[4] renderers; Renderer*[4] renderers;","title":"Interfaces"},{"location":"ideas/#built-in-dynamic-arrays","text":"// Pseudo code type _DynamicArray struct { A* data; usize capacity; usize size; } /** * @require array.size > 0 */ func A pop(_DynamicArray& array) { return array.data[--array.size]; } /** * @require array.size > 0 */ func A +=(_DynamicArray& array, A a) { if (capacity == size) array.increase_capacity(); return array.data[array.size] = a; } We could construct this using generics, but it is much more convenient to have a syntax built in. Question: what about memory management? int[+] dynamic_array; // Built-in dynamic arrays dynamic_array += 23; dynamic_array.pop(); dynamic_array.insert(0, 11); dynamic_array.insert_front(12); io.printf(\"%d\", dynamic_array[1]); // Prints 11 // It's possible to extend dynamic arrays with functionality: func usize int[+].find(int[+] &array, int value) { for (usize i = 0; i < dynamic_array.size; i++) { if (array[i] == value) return i; } return NOT_FOUND; } // This works if the function is in the same module // or if it's included as local dynamic_array.find(12); // => 0 // If it's in another module: module_name.int[+].find(dynamic_array, 12);","title":"Built in dynamic arrays"},{"location":"ideas/#built-in-maps","text":"Same reasoing as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = try map[0]; // Requires a try // Retrive or use default int i = try map[12] else -1; // Extend a map: func bool int[int].remove_if_negative(int[int] &map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int &map, int32_t index);","title":"Built in maps"},{"location":"ideas/#built-in-string-type","text":"Strings are built-in, refcounted(?) null-terminated character arrays. Take a long hard look at memory management (here too) string = \"Hello\"; string += \" World\"; char* data = &string; // Taking a pointer to the string, which may later be invalid.","title":"Built in string type"},{"location":"ideas/#built-in-managed-pointers","text":"Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check. Sample code for (2) type Foo struct @(refcounted) { int a; } func Bar(Foo@ a) { printf(\"%d\\n\", sizeof(Foo)); // prints 8 due to RC printf(\"%d\\n\", rc(a)); // prints 1 Foo@ x = a; printf(\"%d\\n\", rc(a)); // prints 2 x = nil; printf(\"%d\\n\", rc(a)); // prints 1 Foo* y = a; printf(\"%d\\n\", rc(a)); // prints 1 Foo* z = malloc(sizeof(Foo)); // Not recommended! // TOOD discuss how to properly initialize a RC:ed variable. }","title":"Built in managed pointers"},{"location":"ideas/#ideas-around-macros","text":"Just some previous thoughts and ideas I've considered. Many of those actually go against the current design.","title":"Ideas around macros"},{"location":"ideas/#compile-time-variables","text":"This is a variant of what already exists in C, but in a syntactically more friendly way. For example this would be ok: macro swap(a, b) { $x = typeof(a); static_assert(typeof(b) == $x); $x temp = a; a = b; b = a; } The example above is a bit contrived as in the above example we could simply have: macro swap(a, b) { static_assert(typeof(b) == typeof(b)); typeof(a) temp = a; a = b; b = a; } But still, it serves as an example on how to use it.","title":"Compile time variables"},{"location":"ideas/#capturing-trailing-compound-statement","text":"public macro foreach(thelist, @body(Element *) ) { Element* iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Or a version that is more flexible: public macro foreach(thelist, @body(typeof(thelist.first)) ) { typeof(thelist.first) iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } // Usage: foreach(list, Element *i) // <- Note type declaration! { i.print(); } Since type is going to appear very often, we could make a shortcut for it, like $@ as prefix meaning \"typeof\". We then get public macro foreach(thelist, @body($@thelist.first)) { $@thelist.first iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Possibly one could even write the code like this: public macro foreach(thelist, @body($element_type) ) { $element_type iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } In this case $element_type works like \"auto\", but is also assigned the type, which then can be referred to in the signature.","title":"Capturing trailing compound statement"},{"location":"ideas/#yet-another-way-to-do-macros-d","text":"This was an older attempt... First, we have to consider macros as always expanding where they are referenced to keep it simple. macro @foo(int v) { v++; if (v > 10) return 10; return v; } func void test() { int a = 10; @foo(a); } This code would then be exactly equal to: func void test() { int a = 10; a++; if (a > 10) return 10; } Macros simply expand in place. Secondly, we can have macros returning values: macro int @foo2(int v, int w) { v++; if (v > 10) return 10; w += 3; return 0; } func void test() { int d = 0; int a = 10; int b = @foo(a, d); } This expands to: func void test() { int d = 0; int a = 10; a++ int b; if (a > 10) { b = 10; } else { b = 0; d += 3; } } Note that I'm using a sigil to indicate the code expansion to make macros more obvious. We can allow the macro to take a body (here I'm calling the type of the body \"{}\") macro int @foo3(int a, {} body) { while (a > 10) { a--; @body(); // Like a macro! } } func void test() { b = 20; @foo3(b) { print(b); } } We expand this to: func void test() { b = 20; while (b > 10) { b--; print(b); } }","title":"Yet another way to do macros :D"},{"location":"ideas/#stepwise-from-c-macros-into-c3-macros","text":"#define ADD_TO(x, y) { x += y; } ADD_TO(x, 1) The { } introduces a multiline macro that does not need explicit linebreaks. No, add the \"$\" symbol to introduce hygienic temporaries: #define SWAP(x, y) { typeof(x) $tmp = x; x = y; y = $tmp; } Here $tmp will actually be replaced by __<macro>_<variable_name>_<instance> when translating to C, so __SWAP_tmp_1 , __SWAP_tmp_2 etc. We then introduce the syntax macros using: macro swap(&a, &b) { typeof(a) $tmp = a; b = a; a = $tmp; } (Note the different use of $ here as compared to previous macro ideas where $ is a compile time evaluated variable!) The use of &a follows C++ standard: it simply refers to a variable OR EXPRESSION that is imported into its scope. Using the unadorned variable name as evaluated expression allows us to write this code: macro max(a, b) { return (a > b ? a : b) } The above code is equivalent to: macro max(&a, &b) { typeof(a) $tmp_a = a; typeof(b) $tmp_b = b; $tmp_a > $tmp_b ? $tmp_a : $tmp_b } Or in (GNU) C: #define max(a,b) \\ ({ __typeof__ (a) _a = (a); \\ __typeof__ (b) _b = (b); \\ _a > _b ? _a : _b; }) To recap: Add the { } format to #define for multiline defines. Add $<name> format as hygienic variable names. Add the syntax \"macro\" type of definition. The syntax macro makes a difference between \"normal\" parameters (with & as prefix) and \"evaluated\" parameters (unadorned variables) Important is also to scope the macros: #define is always defined local to a scope (unlike in C). This means that #define FOO printf(\"foo\"); { #define BAR printf(\"bar\"); } FOO // adds printf(\"foo\"); BAR; // Error, define not available in scope; This also means that a define can be declared public to be accessed as if defined from the top of the file scope: // file 1 module foo public #define FOO { printf(\"FOO!\\n\"); } // file 2 import foo func void test() { foo.FOO } Only defines in the file scope that exists in the file scope may be public and used in other modules.","title":"Stepwise from C macros into C3 macros"},{"location":"ideas/#yet-another-macro-proposal-i-found","text":"Simple macros macro @foo(&b) { b++; } func test() { int x = 1; @foo(x); } // Same as: func void test() { int x = 1; x++; } Macro with compile time values: macro @foo($x, &b) { b += $x; } func void test() { int x = 1; @foo(10, x); } // Expands to: func void test() { int x = 1; x += 10; } Macro with string capture macro @foo($x, #f) { `#f $x * $x`; } func void test() { i32 x = 1; @foo(4, \"x += \"); } // Expands to func void test() { i32 x = 1; x += 4 * 4; } macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { i32 x = 1; @foo2(\"x\"); } // Expands to funct void test2() { i32 x = 1; printf(\"%s was %d\\n\", \"x\", x); } Macro with conditional compile time values macro @foo($x, &b) { $IF ($x > 3) { b += $x * $x; } $ELSE { b += $x; } } func void test() { i32 x = 1; @foo(10, x); @foo(2, x); } // Expands to func void test() { i32 x = 1; x += 100; x += 2; } Nested macros (don't do this, but an example) macro @foo($a) { printf(\"%d\\n\", $a); $IF($a > 0) { @foo($a - 1); } } func void test() { @foo(2); } // Expands to func void test() { printf(\"%d\\n\", 2); printf(\"%d\\n\", 1); printf(\"%d\\n\", 0); } The above suggests macro sugar of loops: macro @foo($a) { $EACH(0..$a AS $x) { printf(\"%d\\n\", $x); } } macro @foo_enum(&a) { $EACH(a AS $x) { printf(\"%d\\n\", @cast(int, $x)); } } type MyEnum enum { A, B, FOO } func void test() { @foo_enum(MyEnum); } // Expands to func void test() { printf(\"%d\\n\", @cast(int, A)); printf(\"%d\\n\", @cast(int, B)); printf(\"%d\\n\", @cast(int, FOO)); } Each may iterate over: struct members (returned as string), enums (returned as the enum value) Type group helper macro @foo(int &a) // Macro only valid for a is any type of signed integer macro @foo(integer &a) // Valid for unsigned and signed integers macro @foo(number &a) // Valid for any float or integer Macros may force non local return macro @foo() { exit 1; // other keyword? 'escape'? I think exit is good, // but clashes with function name! } func int test() { @foo(); } // expands to func int test() { return 1; } Normal return creates a statement expression macro @foo(&a) { int x = a; x++; if (x > 0) return 1; return 2; } func int test() { b = 10; int y = @foo(b); } // Expands to: func int test() { b = 10; int __macro_ret_1; do { int __macro_x = b; __macro_x++; if (__macro_x > 0) { __macro_ret_1 = 1; break; } else { __macro_ret_1 = 2; break; } } while (0); int y = __macro_ret_1; } Bodies in macros macro @foo(&a, @body) { int z = 0; while (a < 10) { @body(); z++; } } func void test() { int i = 0; @foo(i) { i += 1; } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { i += 1; __macro_z++; } } } Bodies in macros with parameters macro @foo(&a, @body(&x, $y)) { int z = 0; while (a < 10) { @body(z, 2); z++; } } func void test() { int i = 0; @foo(i) { printf(\"%d / %d\\n\", x, y); } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { printf(\"%d / %d\\n\", __macro_z, 2); __macro_z++; } } } Expression is extended to parse: MACRO_IDENT => lookup $x in current macro scope and replace it with literal. Error if not in macro. MACRO_REPLACEMENT => invoke lexer on code inside, after doing a replace of any # inside. $IF requires that the expression can be evaluated to a constant value, similar holds for the range in $EACH . The general rule: 1. An argument prefixed with $ is always something that must be constant. 2. An argument prefixed with & is always a reference to an outer variable. 3. An argument prefixed with # always matches a string. It will be expanded when lexed in `` statements 4. A $ variable can be converted to a # variable. 5. A # can be evaluated to a $ 6. $ and # cannot be assigned to, they are always constant. 7. $ , & and # will never shadow variables from the outer scope.","title":"Yet another macro proposal I found"},{"location":"modules/","text":"Modules C3 groups functions, types, variables and macros into namespaces called modules. All C3 files must start with the module keyword, specifying the module. A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module baz; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar . Details Some details about the C3 module system: Modules are not nested, there only a single level to the name. Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters. Importing modules Importing a module uses the import keyword. Imports have file scope, so consequently if file_a.c3 imports the module networking , then file_b.c3 cannot use those symbols unless it also imports networking . file_a.c3 module foo; //import bar and stdio import bar; import stdio; /* ... */ file_b.c3 module foo; //import bar and networking imported, but not storage import bar; import networking; /* ... */ Named imports It is often convenient to alias the module name (affecting the current file only) to a shorter alias. module foo; import extended_filesystems_io as fs; The code in the file can now use the fs instead of the longer name. However, both names remain valid in the file scope. Local imports In many cases prefixes can become cumbersome. It is therefore also possible to use the local keyword to avoid the prefix completely. import networking as net local; import filesystem local; // Equivalent filesystem.doSomething(); doSomething(); // Equivalent net.connect(); networking.connect(); connect(); In the case where a symbol would be ambiguous, for example if both networking and filesystem would have an open() function, then the prefix is still mandatory. Visibility All files in the same module share the same global declaration namespace. However, by default a function is not visible outside the module. To make the symbol visible outside the module, use the keyword public . module foo; public func void init() { .. } func void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it isn't specified as public.","title":"Modules"},{"location":"modules/#modules","text":"C3 groups functions, types, variables and macros into namespaces called modules. All C3 files must start with the module keyword, specifying the module. A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module baz; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar .","title":"Modules"},{"location":"modules/#details","text":"Some details about the C3 module system: Modules are not nested, there only a single level to the name. Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters.","title":"Details"},{"location":"modules/#importing-modules","text":"Importing a module uses the import keyword. Imports have file scope, so consequently if file_a.c3 imports the module networking , then file_b.c3 cannot use those symbols unless it also imports networking . file_a.c3 module foo; //import bar and stdio import bar; import stdio; /* ... */ file_b.c3 module foo; //import bar and networking imported, but not storage import bar; import networking; /* ... */","title":"Importing modules"},{"location":"modules/#named-imports","text":"It is often convenient to alias the module name (affecting the current file only) to a shorter alias. module foo; import extended_filesystems_io as fs; The code in the file can now use the fs instead of the longer name. However, both names remain valid in the file scope.","title":"Named imports"},{"location":"modules/#local-imports","text":"In many cases prefixes can become cumbersome. It is therefore also possible to use the local keyword to avoid the prefix completely. import networking as net local; import filesystem local; // Equivalent filesystem.doSomething(); doSomething(); // Equivalent net.connect(); networking.connect(); connect(); In the case where a symbol would be ambiguous, for example if both networking and filesystem would have an open() function, then the prefix is still mandatory.","title":"Local imports"},{"location":"modules/#visibility","text":"All files in the same module share the same global declaration namespace. However, by default a function is not visible outside the module. To make the symbol visible outside the module, use the keyword public . module foo; public func void init() { .. } func void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it isn't specified as public.","title":"Visibility"},{"location":"naming/","text":"Naming rules As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character. Structs, unions and enums All user defined types must start with A-Z. For C-compatibility it's possible to alias the type to a C name using the attribute \"cname\". Variables and parameters All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not. Global constants Global constants must start with A-Z after any optional initial _ . _FOO , BAR_FOO , X are all valid global constants, _ , _bar , x are not. Modules Module names are limited to a-z and underscore. Functions and macros Functions and macros must start with a-z after any optional initial _ .","title":"Naming rules"},{"location":"naming/#naming-rules","text":"As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character.","title":"Naming rules"},{"location":"naming/#structs-unions-and-enums","text":"All user defined types must start with A-Z. For C-compatibility it's possible to alias the type to a C name using the attribute \"cname\".","title":"Structs, unions and enums"},{"location":"naming/#variables-and-parameters","text":"All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not.","title":"Variables and parameters"},{"location":"naming/#global-constants","text":"Global constants must start with A-Z after any optional initial _ . _FOO , BAR_FOO , X are all valid global constants, _ , _bar , x are not.","title":"Global constants"},{"location":"naming/#modules","text":"Module names are limited to a-z and underscore.","title":"Modules"},{"location":"naming/#functions-and-macros","text":"Functions and macros must start with a-z after any optional initial _ .","title":"Functions and macros"},{"location":"precedence/","text":"Precedence rules Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- prefix - , ~ , prefix * , & , prefix ++ and -- infix * , / , % << , >> ^ , | , infix & + , infix - == , != , >= , <= , > , < && , || ternary ?: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= , The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a || b && c a || (b && c) // C (&& binds tighter than ||) (a || b) && c // C3 (Same precedence, left-to-right evaluation) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 (Same precedence, left-to-right evaluation) a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 (Same precedence, left-to-right evaluation) The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of || and &&, relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence"},{"location":"precedence/#precedence-rules","text":"Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- prefix - , ~ , prefix * , & , prefix ++ and -- infix * , / , % << , >> ^ , | , infix & + , infix - == , != , >= , <= , > , < && , || ternary ?: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= , The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a || b && c a || (b && c) // C (&& binds tighter than ||) (a || b) && c // C3 (Same precedence, left-to-right evaluation) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 (Same precedence, left-to-right evaluation) a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 (Same precedence, left-to-right evaluation) The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of || and &&, relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence rules"},{"location":"project/","text":"Customizing A Project A new project is provided with a barebone structure: [[executable]] # name of the target name = \"hello_world\" # version using semantic versioning version = \"0.1.0\" # authors, optionally with email authors = [\"John Doe <john.doe@example.com>\"] # language version of C3 langrev = \"1\" # warnings used warnings = [\"no-unused\"] # sources compliled sources = [\"src/**\"] # libraries to use libs = [\"lib/**\"] Libraries look a little different: [[static-lib]] name = \"graphics\" version = \"0.1.0\" authors = [\"John Doe <john.doe@example.com>\"] langrev = \"1\" warnings = [\"no-unused\"] sources = [\"src/**\"] # exported modules export = [\"api\"] Target options config Under the config you define external constants (\"key = value\") that will be included in compilation as if they were global macro constants. export Define the list of modules to be exported by a library. Not valid for executables. generate C3 defaults to generating C code that is then compiled and remove. Simply compile to C without further compilation by setting generate = \"C\" warnings List of warnings to enable during compilation. lib List of libraries to use when compiling the target. Using environment variables In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Project Structure"},{"location":"project/#customizing-a-project","text":"A new project is provided with a barebone structure: [[executable]] # name of the target name = \"hello_world\" # version using semantic versioning version = \"0.1.0\" # authors, optionally with email authors = [\"John Doe <john.doe@example.com>\"] # language version of C3 langrev = \"1\" # warnings used warnings = [\"no-unused\"] # sources compliled sources = [\"src/**\"] # libraries to use libs = [\"lib/**\"] Libraries look a little different: [[static-lib]] name = \"graphics\" version = \"0.1.0\" authors = [\"John Doe <john.doe@example.com>\"] langrev = \"1\" warnings = [\"no-unused\"] sources = [\"src/**\"] # exported modules export = [\"api\"]","title":"Customizing A Project"},{"location":"project/#target-options","text":"","title":"Target options"},{"location":"project/#config","text":"Under the config you define external constants (\"key = value\") that will be included in compilation as if they were global macro constants.","title":"config"},{"location":"project/#export","text":"Define the list of modules to be exported by a library. Not valid for executables.","title":"export"},{"location":"project/#generate","text":"C3 defaults to generating C code that is then compiled and remove. Simply compile to C without further compilation by setting generate = \"C\"","title":"generate"},{"location":"project/#warnings","text":"List of warnings to enable during compilation.","title":"warnings"},{"location":"project/#lib","text":"List of libraries to use when compiling the target.","title":"lib"},{"location":"project/#using-environment-variables","text":"In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Using environment variables"},{"location":"sample/","text":"Sample Here is a bit of code manually converted to C3 from C. type Node struct { uint hole; uint size; Node* next; Node* prev; } type Footer struct { Node &header; } type Bin struct { Node& head; } type Heap struct { size start; size end; Bin* bins[BIN_COUNT]; } const uint offset = 8; /** * @require start > 0 */ void Heap.init(Heap& heap, usize start) { Node& init_region = @cast(Node&, start); init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - @sizeof(Node) - @sizeof(Footer); init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = @cast(void*, start); heap.end = @cast(void*, start + HEAP_INIT_SIZE); } void* Heap.alloc(Heap& heap, usize size) { uint index = get_bin_index(size); Bin& temp = @cast(Bin&, heap.bins[index]); Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node& split = @cast(Node*, @cast(char&, found) + sizeof(Node) + sizeof(Footer)) + size); split.size = found.size - size - sizeof(Node) - sizeof(Footer); split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node& wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ func void Heap.free(Heap* heap, void *p) { Bin& list; Footer& new_foot, old_foot; Node& head = @cast(Node&, @cast(char&, p) - offset); if (head == @cast(Node&, @cast(heap.start, usize)) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node& next = @cast(Node*, @cast(char*, head.getFoot()) + sizeof(Footer)); Footer& f = @cast(Footer*, @cast(char*, head) - sizeof(Footer)); Node& prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } func uint Heap.expand(Heap& heap, usize sz) { return 0; } func void Heap.contract(Heap& heap, usize sz) { return; } func uint get_bin_index(usize sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } func void Node.createFoot(Node& head) { Footer& foot = head.getFoot(); foot.header = head; } func Foot& Node.getFoot(Node& node) { return @cast(Footer&, @cast(char&, node) + sizeof(Node) + node.size); } func Node* getWilderness(Heap& heap) { Footer& wild_foot = @cast(Footer&, @cast(char&, heap.end) - sizeof(Footer)); return wild_foot.header; }","title":"Sample"},{"location":"sample/#sample","text":"Here is a bit of code manually converted to C3 from C. type Node struct { uint hole; uint size; Node* next; Node* prev; } type Footer struct { Node &header; } type Bin struct { Node& head; } type Heap struct { size start; size end; Bin* bins[BIN_COUNT]; } const uint offset = 8; /** * @require start > 0 */ void Heap.init(Heap& heap, usize start) { Node& init_region = @cast(Node&, start); init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - @sizeof(Node) - @sizeof(Footer); init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = @cast(void*, start); heap.end = @cast(void*, start + HEAP_INIT_SIZE); } void* Heap.alloc(Heap& heap, usize size) { uint index = get_bin_index(size); Bin& temp = @cast(Bin&, heap.bins[index]); Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node& split = @cast(Node*, @cast(char&, found) + sizeof(Node) + sizeof(Footer)) + size); split.size = found.size - size - sizeof(Node) - sizeof(Footer); split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node& wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ func void Heap.free(Heap* heap, void *p) { Bin& list; Footer& new_foot, old_foot; Node& head = @cast(Node&, @cast(char&, p) - offset); if (head == @cast(Node&, @cast(heap.start, usize)) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node& next = @cast(Node*, @cast(char*, head.getFoot()) + sizeof(Footer)); Footer& f = @cast(Footer*, @cast(char*, head) - sizeof(Footer)); Node& prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } func uint Heap.expand(Heap& heap, usize sz) { return 0; } func void Heap.contract(Heap& heap, usize sz) { return; } func uint get_bin_index(usize sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } func void Node.createFoot(Node& head) { Footer& foot = head.getFoot(); foot.header = head; } func Foot& Node.getFoot(Node& node) { return @cast(Footer&, @cast(char&, node) + sizeof(Node) + node.size); } func Node* getWilderness(Heap& heap) { Footer& wild_foot = @cast(Footer&, @cast(char&, heap.end) - sizeof(Footer)); return wild_foot.header; }","title":"Sample"},{"location":"setup/","text":"This is a placeholder page.","title":"Setup"},{"location":"specialfunctions/","text":"Built in functions C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc abs Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long) byteswap Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long) bitreverse Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long) ceil Return the closest integral number, rounded up. float ceilf(float) double ceil(double) clz Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong) cos Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad) ctz Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"Built in functions"},{"location":"specialfunctions/#built-in-functions","text":"C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc","title":"Built in functions"},{"location":"specialfunctions/#abs","text":"Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long)","title":"abs"},{"location":"specialfunctions/#byteswap","text":"Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long)","title":"byteswap"},{"location":"specialfunctions/#bitreverse","text":"Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long)","title":"bitreverse"},{"location":"specialfunctions/#ceil","text":"Return the closest integral number, rounded up. float ceilf(float) double ceil(double)","title":"ceil"},{"location":"specialfunctions/#clz","text":"Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong)","title":"clz"},{"location":"specialfunctions/#cos","text":"Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad)","title":"cos"},{"location":"specialfunctions/#ctz","text":"Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"ctz"},{"location":"syntax/","text":"Grammar The following (incomplete) grammar can be used with this: https://bottlecaps.de/rr/ui to get a railroad diagram of the grammar. source ::= module_def import_def+ top_level module_def ::= 'module' IDENT EOS import_def_ ::= 'import' IDENT ( ('as' IDENT) | 'local' )? EOS top_level ::= (array_append | global_decl)* global_decl ::= 'public'? (type_def | func_def | var_def | macro_def) array_append ::= IDENT '+=' init_value func_def ::= return_value IDENT '(' function_args ')' compound_stmt? generic_def ::= 'generic' IDENT '(' generic_arg_list ')' compound_stmt generic_arg_list ::= generic_arg (',' generic_arg)* generic_arg ::= type? IDENT macro_def ::= 'macro' IDENT '(' macro_arg_list? ')' compound_stmt macro_arg_list ::= macro_arg (',' macro_arg)* macro_arg ::= '&'? IDENT var_def ::= type_qualifier IDENT ... struct_or_union ::= 'struct' | 'union' type_def ::= 'type' IDENT type_def_body type_def_body ::= enum_def | func_type_def | struct_def | error_def enum_def ::= 'enum' type attributes? '{' enum_body? '}' enum_body ::= enum_value (',' enum_value)* ','? enum_value ::= IDENT ('=' expression)? error_def ::= 'error' IDENT '{' IDENT (',' IDENT)* '}' func_type_def ::= 'func' type attributes? '(' function_args ')' EOS struct_def ::= struct_or_union attributes? struct_body struct_body ::= '{' (struct_member (',' struct_member)* )? '}' struct_member ::= (type IDENT) | (struct_or_union IDENT? struct_body) compound_stmt ::= '{' (statement | declaration)* '}' statement ::= label_stmt | compound_stmt | expr_stmt | if_stmt | switch_stmt | iter_stmt | jump_stmt jump_stmt ::= ( ('goto' IDENT) | 'continue' | 'break' | 'next' | ('return' expression?) ) EOS label_stmt ::= IDENT ':' if_stmt ::= 'if' control_expr statement (ELSE statement)? switch_stmt ::= 'switch' control_expr '{' switch_body '}' switch_body ::= case_stmt | default_stmt case_stmt ::= 'case' expression ':' case_body default_stmt ::= 'default' ':' case_body case_body ::= (statement | declaration)* control_expr ::= '(' var_def_list? expression ')' var_def_list ::= var_def (',' var_def)* EOS iter_stmt ::= while_stmt | do_stmt | for_stmt while_stmt ::= 'while' control_stml statement do_stmt ::= 'do' statement while '(' expression ')' EOS for_stmt ::= 'for' '(' var_def_list? expression? EOS expression ')' statement type ::= base_type (pointer_suffix | array_suffix)* qualified_type ::= qualifier* base_type ((qualifier* pointer_suffix) | array_suffix)* base_type ::= built_in_type | IDENT built_in_type ::= bit_types | named_types | c_types bit_types ::= unsigned_bit_types | signed_bit_types | float_bit_types unsigned_bit_types ::= 'u8' | 'u16' | 'u32' | 'u64' | 'u1' signed_bit_types ::= 'i8' | 'i16' | 'i32' | 'i64' float_bit_types ::= 'f16' | 'f32' | 'f64' | 'f128' named_types ::= signed_named_types | unsigned_named_types | float_named_types | 'void' signed_named_types ::= 'char' | 'short' | 'int' | 'long' | 'isize' unsigned_named_types ::= 'bool' | 'byte' | 'ushort' | 'uint' | 'ulong' | 'usize' float_named_types ::= 'float' | 'double' | 'quad' c_types ::= signed_c_types | unsigned_c_types | float_c_types signed_c_types ::= 'c_ichar' | 'c_ushort' | 'c_int' | 'c_long' | 'c_longlong' unsigned_c_types ::= 'c_uchar' | 'c_ushort' | 'c_uint' | 'c_ulong' | 'c_ulonglong' float_c_types ::= 'c_float' | 'c_double' | 'c_longdouble' pointer_suffix ::= '*' | '&' array_suffix ::= '[' expression? ']' expr_stmt ::= expression EOS primary_expr ::= IDENT | CONSTANT | STRING_LITERL | '(' expression ')' postfix_expr ::= primary_expr postfix_op* postfix_op ::= array_op | call_op | dot_op | inc_dec_op array_op ::= '[' expression ']' call_op ::= '(' arg_expr_list? ')' dot_op ::= '.' IDENT inc_dec_op ::= '++' | '--' arg_expr_list ::= assign_expr (',' assign_expr)* unary_op ::= inc_dec_op | '&' | '*' | '+' | '-' | '~' | '!' unary_expr ::= inc_dec_op* postfix_expr binary_op ::= mult_op | arith_op | assign_op | rel_op | bit_op | bool_op assign_op ::= '=' | mult_assign_op | arith_assign_op | bit_assign_op mult_assign_op ::= '*=' | '/=' | '%=' arith_assign_op ::= '+=' | '-=' bit_assign_op ::= '>>=' | '<<=' | '>>>=' | '|=' | '&=' | '^=' arith_op ::= '+' | '-' mult_op ::= '*' | '/' | '%' bit_op ::= '|' | '&' | '^' | '>>' | '<<' | '>>>' bool_op ::= '&&' | '||' rel_op ::= '==' | '!=' | '<' | '>' | '<=' | '>=' binary_expr ::= unary_expr (binary_op unary_expr)* expression ::= binary_expr ('?' expression ':' cond_expr)? declaration ::= qualified_type IDENT ('=' init_expr)? EOS init_expr ::= expression | struct_init struct_init ::= '{' stuct_init_list? '}' struct_init_list ::= strict_init_decl (',' struct_init_decl)* struct_init_decl ::= member_init | init_expr member_init ::=_ '.' IDENT '=' init_expr","title":"Grammar"},{"location":"syntax/#grammar","text":"The following (incomplete) grammar can be used with this: https://bottlecaps.de/rr/ui to get a railroad diagram of the grammar. source ::= module_def import_def+ top_level module_def ::= 'module' IDENT EOS import_def_ ::= 'import' IDENT ( ('as' IDENT) | 'local' )? EOS top_level ::= (array_append | global_decl)* global_decl ::= 'public'? (type_def | func_def | var_def | macro_def) array_append ::= IDENT '+=' init_value func_def ::= return_value IDENT '(' function_args ')' compound_stmt? generic_def ::= 'generic' IDENT '(' generic_arg_list ')' compound_stmt generic_arg_list ::= generic_arg (',' generic_arg)* generic_arg ::= type? IDENT macro_def ::= 'macro' IDENT '(' macro_arg_list? ')' compound_stmt macro_arg_list ::= macro_arg (',' macro_arg)* macro_arg ::= '&'? IDENT var_def ::= type_qualifier IDENT ... struct_or_union ::= 'struct' | 'union' type_def ::= 'type' IDENT type_def_body type_def_body ::= enum_def | func_type_def | struct_def | error_def enum_def ::= 'enum' type attributes? '{' enum_body? '}' enum_body ::= enum_value (',' enum_value)* ','? enum_value ::= IDENT ('=' expression)? error_def ::= 'error' IDENT '{' IDENT (',' IDENT)* '}' func_type_def ::= 'func' type attributes? '(' function_args ')' EOS struct_def ::= struct_or_union attributes? struct_body struct_body ::= '{' (struct_member (',' struct_member)* )? '}' struct_member ::= (type IDENT) | (struct_or_union IDENT? struct_body) compound_stmt ::= '{' (statement | declaration)* '}' statement ::= label_stmt | compound_stmt | expr_stmt | if_stmt | switch_stmt | iter_stmt | jump_stmt jump_stmt ::= ( ('goto' IDENT) | 'continue' | 'break' | 'next' | ('return' expression?) ) EOS label_stmt ::= IDENT ':' if_stmt ::= 'if' control_expr statement (ELSE statement)? switch_stmt ::= 'switch' control_expr '{' switch_body '}' switch_body ::= case_stmt | default_stmt case_stmt ::= 'case' expression ':' case_body default_stmt ::= 'default' ':' case_body case_body ::= (statement | declaration)* control_expr ::= '(' var_def_list? expression ')' var_def_list ::= var_def (',' var_def)* EOS iter_stmt ::= while_stmt | do_stmt | for_stmt while_stmt ::= 'while' control_stml statement do_stmt ::= 'do' statement while '(' expression ')' EOS for_stmt ::= 'for' '(' var_def_list? expression? EOS expression ')' statement type ::= base_type (pointer_suffix | array_suffix)* qualified_type ::= qualifier* base_type ((qualifier* pointer_suffix) | array_suffix)* base_type ::= built_in_type | IDENT built_in_type ::= bit_types | named_types | c_types bit_types ::= unsigned_bit_types | signed_bit_types | float_bit_types unsigned_bit_types ::= 'u8' | 'u16' | 'u32' | 'u64' | 'u1' signed_bit_types ::= 'i8' | 'i16' | 'i32' | 'i64' float_bit_types ::= 'f16' | 'f32' | 'f64' | 'f128' named_types ::= signed_named_types | unsigned_named_types | float_named_types | 'void' signed_named_types ::= 'char' | 'short' | 'int' | 'long' | 'isize' unsigned_named_types ::= 'bool' | 'byte' | 'ushort' | 'uint' | 'ulong' | 'usize' float_named_types ::= 'float' | 'double' | 'quad' c_types ::= signed_c_types | unsigned_c_types | float_c_types signed_c_types ::= 'c_ichar' | 'c_ushort' | 'c_int' | 'c_long' | 'c_longlong' unsigned_c_types ::= 'c_uchar' | 'c_ushort' | 'c_uint' | 'c_ulong' | 'c_ulonglong' float_c_types ::= 'c_float' | 'c_double' | 'c_longdouble' pointer_suffix ::= '*' | '&' array_suffix ::= '[' expression? ']' expr_stmt ::= expression EOS primary_expr ::= IDENT | CONSTANT | STRING_LITERL | '(' expression ')' postfix_expr ::= primary_expr postfix_op* postfix_op ::= array_op | call_op | dot_op | inc_dec_op array_op ::= '[' expression ']' call_op ::= '(' arg_expr_list? ')' dot_op ::= '.' IDENT inc_dec_op ::= '++' | '--' arg_expr_list ::= assign_expr (',' assign_expr)* unary_op ::= inc_dec_op | '&' | '*' | '+' | '-' | '~' | '!' unary_expr ::= inc_dec_op* postfix_expr binary_op ::= mult_op | arith_op | assign_op | rel_op | bit_op | bool_op assign_op ::= '=' | mult_assign_op | arith_assign_op | bit_assign_op mult_assign_op ::= '*=' | '/=' | '%=' arith_assign_op ::= '+=' | '-=' bit_assign_op ::= '>>=' | '<<=' | '>>>=' | '|=' | '&=' | '^=' arith_op ::= '+' | '-' mult_op ::= '*' | '/' | '%' bit_op ::= '|' | '&' | '^' | '>>' | '<<' | '>>>' bool_op ::= '&&' | '||' rel_op ::= '==' | '!=' | '<' | '>' | '<=' | '>=' binary_expr ::= unary_expr (binary_op unary_expr)* expression ::= binary_expr ('?' expression ':' cond_expr)? declaration ::= qualified_type IDENT ('=' init_expr)? EOS init_expr ::= expression | struct_init struct_init ::= '{' stuct_init_list? '}' struct_init_list ::= strict_init_decl (',' struct_init_decl)* struct_init_decl ::= member_init | init_expr member_init ::=_ '.' IDENT '=' init_expr","title":"Grammar"},{"location":"types/","text":"Types As usual, types are divided into basic types and user defined types. The syntax for defining a new type is uniform: [public] type <name> <definition> . All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module. Naming All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. Since this runs into probles with C compatibility, it is possible to use attributes to change the c name of a type, as well as control whether a C typedef should be emitted for the type. type Stat struct { // ... } @(cname=\"stat\", no_typedef) func c_int stat(const c_char* pathname, Stat* buf); Basic types Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned. Integer types Name alias bit size signed bool u1 1 no char i8 8 yes byte u8 8 no short i16 16 yes ushort u16 16 no int i32 32 yes uint u32 32 no long i64 64 yes ulong u64 64 no isize* - varies yes usize* - varies no * isize and usize are pointer sized. Integer constants Integer constants are 1293832 or -918212. Unlike C the \"type\" of an integer constant is a special compile time int. All constant operations, for example 9283 << 2 will be resolved at compile time. An compile time error will result if the constant is too large to fit whatever variable it is assigned or compared to. Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100 Floating point types Name alias bit size float f32 32 double f64 64 quad* f128 128 *support will depend on platform Floating point constants Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediagely before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10 C compatibility For C compatibility the following types are also defined: Name c type c_char char c_ichar signed char c_uchar unsigned char c_short short int c_ushort unsigned short int c_int int c_uint unsigned int c_long long int c_ulong unsigned long int c_longlong long long c_ulonglong unsigned long long c_float float c_double double c_longdouble long double Pointer types Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo. Array types Arrays are indicated by [] after the type. Unlike C, the [] . Foo[] would be an array of unspecified length containing Foo structs. Enum Enum (enumerated) types use the following syntax: type State enum int { PENDING = 0, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING . Alias and function types Alias types are used to give an alias to a different type, like: type CharPtr char*; type Numbers int[10]; Function pointers must be aliased in C3. The syntax is simpler than that of C: public type Callback func void(int a, bool b); This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback cb(10, false); Struct types Structs are always named: type Person struct { char age; char* name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; io.printf(\"%s is %d years old.\", p.age, p.name); Person& pPtr = &p; pPtr.age = 20; // Ok! io.printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person&& and use dot access. \u2013 It's not, only one level of deref is done) Struct subtyping C3 allows creating struct subtypes: type ImportantPerson struct { inline Person person; char* title; } func printPerson(Person p) { io.printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied. inline is not strictly needed. It allows a struct or union to be both addressed by name and directly as an anonymous struct/union. (See below) Union types Union types are defined just like structs. type Integral union { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. io.printf(\"%d\", i.as_byte); Note that unions only take up as much space as their largest member, so sizeof(Integral) is equivalent to sizeof(long) . Anonymous sub-structs / unions Just like in later versions of C, anonymous sub-structs / unions are allowed. type Person struct { char age; char* name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } }","title":"Types"},{"location":"types/#types","text":"As usual, types are divided into basic types and user defined types. The syntax for defining a new type is uniform: [public] type <name> <definition> . All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module.","title":"Types"},{"location":"types/#naming","text":"All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. Since this runs into probles with C compatibility, it is possible to use attributes to change the c name of a type, as well as control whether a C typedef should be emitted for the type. type Stat struct { // ... } @(cname=\"stat\", no_typedef) func c_int stat(const c_char* pathname, Stat* buf);","title":"Naming"},{"location":"types/#basic-types","text":"Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned.","title":"Basic types"},{"location":"types/#integer-types","text":"Name alias bit size signed bool u1 1 no char i8 8 yes byte u8 8 no short i16 16 yes ushort u16 16 no int i32 32 yes uint u32 32 no long i64 64 yes ulong u64 64 no isize* - varies yes usize* - varies no * isize and usize are pointer sized.","title":"Integer types"},{"location":"types/#integer-constants","text":"Integer constants are 1293832 or -918212. Unlike C the \"type\" of an integer constant is a special compile time int. All constant operations, for example 9283 << 2 will be resolved at compile time. An compile time error will result if the constant is too large to fit whatever variable it is assigned or compared to. Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100","title":"Integer constants"},{"location":"types/#floating-point-types","text":"Name alias bit size float f32 32 double f64 64 quad* f128 128 *support will depend on platform","title":"Floating point types"},{"location":"types/#floating-point-constants","text":"Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediagely before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10","title":"Floating point constants"},{"location":"types/#c-compatibility","text":"For C compatibility the following types are also defined: Name c type c_char char c_ichar signed char c_uchar unsigned char c_short short int c_ushort unsigned short int c_int int c_uint unsigned int c_long long int c_ulong unsigned long int c_longlong long long c_ulonglong unsigned long long c_float float c_double double c_longdouble long double","title":"C compatibility"},{"location":"types/#pointer-types","text":"Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo.","title":"Pointer types"},{"location":"types/#array-types","text":"Arrays are indicated by [] after the type. Unlike C, the [] . Foo[] would be an array of unspecified length containing Foo structs.","title":"Array types"},{"location":"types/#enum","text":"Enum (enumerated) types use the following syntax: type State enum int { PENDING = 0, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING .","title":"Enum"},{"location":"types/#alias-and-function-types","text":"Alias types are used to give an alias to a different type, like: type CharPtr char*; type Numbers int[10]; Function pointers must be aliased in C3. The syntax is simpler than that of C: public type Callback func void(int a, bool b); This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback cb(10, false);","title":"Alias and function types"},{"location":"types/#struct-types","text":"Structs are always named: type Person struct { char age; char* name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; io.printf(\"%s is %d years old.\", p.age, p.name); Person& pPtr = &p; pPtr.age = 20; // Ok! io.printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person&& and use dot access. \u2013 It's not, only one level of deref is done)","title":"Struct types"},{"location":"types/#struct-subtyping","text":"C3 allows creating struct subtypes: type ImportantPerson struct { inline Person person; char* title; } func printPerson(Person p) { io.printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied. inline is not strictly needed. It allows a struct or union to be both addressed by name and directly as an anonymous struct/union. (See below)","title":"Struct subtyping"},{"location":"types/#union-types","text":"Union types are defined just like structs. type Integral union { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. io.printf(\"%d\", i.as_byte); Note that unions only take up as much space as their largest member, so sizeof(Integral) is equivalent to sizeof(long) .","title":"Union types"},{"location":"types/#anonymous-sub-structs-unions","text":"Just like in later versions of C, anonymous sub-structs / unions are allowed. type Person struct { char age; char* name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } }","title":"Anonymous sub-structs / unions"}]}
{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is C3? C3 is a systems language based on C. It intends tries to be a short step up from C rather than to replace it with a new paradigm or completely new syntax. C3 is built on top of the C2 lang project by Bas van den Berg . It goes substantially further in regards to error handling, macros, generics and strings. Although it might have some breaking changes, it can \u2013 at least currently \u2013 be considered a superset of C2. Last updated: 2019-07-30 . Planned features Transpile to C Transpile-compile using Clang, GCC or TCC Compile directly using LLVM C to C3 conversion (for a subset of C) Module system Generic modules Zero overhead errors Struct subtyping Built-in safe arrays High level containers and string handling Design principles Procedural \"get things done\"-type of language. Try to stay close to C - only change where truly needed. Flawless C integration. Learning C3 should be easy for a C programmer. Dare violating the \"close to metal\" principle if the value is great. Not an object oriented language. Avoid \"big ideas\". Avoid the kitchen sink language trap.","title":"About C3"},{"location":"#what-is-c3","text":"C3 is a systems language based on C. It intends tries to be a short step up from C rather than to replace it with a new paradigm or completely new syntax. C3 is built on top of the C2 lang project by Bas van den Berg . It goes substantially further in regards to error handling, macros, generics and strings. Although it might have some breaking changes, it can \u2013 at least currently \u2013 be considered a superset of C2. Last updated: 2019-07-30 .","title":"What is C3?"},{"location":"#planned-features","text":"Transpile to C Transpile-compile using Clang, GCC or TCC Compile directly using LLVM C to C3 conversion (for a subset of C) Module system Generic modules Zero overhead errors Struct subtyping Built-in safe arrays High level containers and string handling","title":"Planned features"},{"location":"#design-principles","text":"Procedural \"get things done\"-type of language. Try to stay close to C - only change where truly needed. Flawless C integration. Learning C3 should be easy for a C programmer. Dare violating the \"close to metal\" principle if the value is great. Not an object oriented language. Avoid \"big ideas\". Avoid the kitchen sink language trap.","title":"Design principles"},{"location":"buildcommands/","text":"Build Commands When starting out, with C3 it's natural to use compile and compile-run to try things out. For larger projects, the built-in build system is instead recommended. compile The default for c3c is compiling stand-alone files to output a binary. c3c compile <file1> <file2> <file3> compile-run The same as compile but then also runs the executable. Common additional parameters Additional parameters: - --lib <path> add a library to search. - --output <path> override the output directory. - --path <path> execute as if standing at init c3c init <project_name> [optional path] . Create a new project structure in the current directory. Use the --template to select a template. The following are built in: default - the default template, produces an executable. lib - template for producing a library. staticlib - template for producing a static library. It is also possible to give the path to a custom template. Additional parameters: - --template <path> indicate an alternative template to use. c3c init hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world build build [target] Build the project in the current path. It doesn't matter where in the project structure you are. The built in templates define two targets: debug (which is the default) and release . clean clean run run [target] Build the target (if needed) and run the executable. clean-run clean-run [target] Clean, build and run the target. dist dist [target] Clean, build and package the target. docs docs [target] Rebuilds the documentation. bench bench [target] Runs benchmarks on a target.","title":"Commands"},{"location":"buildcommands/#build-commands","text":"When starting out, with C3 it's natural to use compile and compile-run to try things out. For larger projects, the built-in build system is instead recommended.","title":"Build Commands"},{"location":"buildcommands/#compile","text":"The default for c3c is compiling stand-alone files to output a binary. c3c compile <file1> <file2> <file3>","title":"compile"},{"location":"buildcommands/#compile-run","text":"The same as compile but then also runs the executable.","title":"compile-run"},{"location":"buildcommands/#common-additional-parameters","text":"Additional parameters: - --lib <path> add a library to search. - --output <path> override the output directory. - --path <path> execute as if standing at","title":"Common additional parameters"},{"location":"buildcommands/#init","text":"c3c init <project_name> [optional path] . Create a new project structure in the current directory. Use the --template to select a template. The following are built in: default - the default template, produces an executable. lib - template for producing a library. staticlib - template for producing a static library. It is also possible to give the path to a custom template. Additional parameters: - --template <path> indicate an alternative template to use. c3c init hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world","title":"init"},{"location":"buildcommands/#build","text":"build [target] Build the project in the current path. It doesn't matter where in the project structure you are. The built in templates define two targets: debug (which is the default) and release .","title":"build"},{"location":"buildcommands/#clean","text":"clean","title":"clean"},{"location":"buildcommands/#run","text":"run [target] Build the target (if needed) and run the executable.","title":"run"},{"location":"buildcommands/#clean-run","text":"clean-run [target] Clean, build and run the target.","title":"clean-run"},{"location":"buildcommands/#dist","text":"dist [target] Clean, build and package the target.","title":"dist"},{"location":"buildcommands/#docs","text":"docs [target] Rebuilds the documentation.","title":"docs"},{"location":"buildcommands/#bench","text":"bench [target] Runs benchmarks on a target.","title":"bench"},{"location":"buildintro/","text":"Build System PLEASE NOTE this is just a spec of how the build system might work.","title":"Introduction"},{"location":"buildintro/#build-system","text":"PLEASE NOTE this is just a spec of how the build system might work.","title":"Build System"},{"location":"builtinmacros/","text":"Built-in macros There are several built-in macros to inspect the code during compile and runtime. @bitcast @cast @describe @elements @name @sizeof @typeof @bitcast Bitcast reinterprets the contents of a variable without any conversion. Bitsize must be the same for both types. float f = 12.3; int i = @bitcast(int, f); printf(\"%x\", i); // Prints 4144cccd @cast Cast one type to the other using the default conversion rules. Bit extension or truncation may occur. float f = 12.3; int i = @cast(int, f); printf(\"%d\", i); // Prints 12 @describe Creates a runtime description of a value. enum FooEnum { A, B } func char[] test() { FooEnum x = FooEnum.A; return @describe(x); // Returns \"FooEnum.A\" } struct Foo { int x; char[] y; } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @describe(x); // Returns \"Foo { x: 2, y: \"bar\" }\" } @elements Returns an array of an error set or enum set. FooEnum[] values = @elements(FooEnum); // Same as FooEnum[] values = { FooEnum.A, FooEnum.B }; @name Creates a runtime name of a value. func char[] test() { FooEnum x = FooEnum.B; return @name(x); // Returns \"A\" } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @name(x); // Returns \"Foo\" } @offset Returns the byte offset in a structure, like offsetof in C @offset(Foo, y); // => returns 4 or 8 @sizeof Returns the size of a type or an expression func usize size_test() { return @sizeof(Foo); // Might compile to 16 } func usize size_test2() { return @sizeof(size_test()); // Usually returns 8 (the size of usize) } @typeof Returns the type of an expression @typeof(size_test()) x = size_test(); @typeof(x) y = x + 1;","title":"Built-in Macros"},{"location":"builtinmacros/#built-in-macros","text":"There are several built-in macros to inspect the code during compile and runtime. @bitcast @cast @describe @elements @name @sizeof @typeof","title":"Built-in macros"},{"location":"builtinmacros/#bitcast","text":"Bitcast reinterprets the contents of a variable without any conversion. Bitsize must be the same for both types. float f = 12.3; int i = @bitcast(int, f); printf(\"%x\", i); // Prints 4144cccd","title":"@bitcast"},{"location":"builtinmacros/#cast","text":"Cast one type to the other using the default conversion rules. Bit extension or truncation may occur. float f = 12.3; int i = @cast(int, f); printf(\"%d\", i); // Prints 12","title":"@cast"},{"location":"builtinmacros/#describe","text":"Creates a runtime description of a value. enum FooEnum { A, B } func char[] test() { FooEnum x = FooEnum.A; return @describe(x); // Returns \"FooEnum.A\" } struct Foo { int x; char[] y; } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @describe(x); // Returns \"Foo { x: 2, y: \"bar\" }\" }","title":"@describe"},{"location":"builtinmacros/#elements","text":"Returns an array of an error set or enum set. FooEnum[] values = @elements(FooEnum); // Same as FooEnum[] values = { FooEnum.A, FooEnum.B };","title":"@elements"},{"location":"builtinmacros/#name","text":"Creates a runtime name of a value. func char[] test() { FooEnum x = FooEnum.B; return @name(x); // Returns \"A\" } func char[] test_struct() { Foo foo = { .x = 2, y = \"bar\" } return @name(x); // Returns \"Foo\" }","title":"@name"},{"location":"builtinmacros/#offset","text":"Returns the byte offset in a structure, like offsetof in C @offset(Foo, y); // => returns 4 or 8","title":"@offset"},{"location":"builtinmacros/#sizeof","text":"Returns the size of a type or an expression func usize size_test() { return @sizeof(Foo); // Might compile to 16 } func usize size_test2() { return @sizeof(size_test()); // Usually returns 8 (the size of usize) }","title":"@sizeof"},{"location":"builtinmacros/#typeof","text":"Returns the type of an expression @typeof(size_test()) x = size_test(); @typeof(x) y = x + 1;","title":"@typeof"},{"location":"changes/","text":"Change log Current revision made 2019-07-30. Revision 2019-07-30 Added default and named arguments to the functions page . Added varargs to the functions page . Added idea about hierarchal memory. Added idea of raw dynamic safe arrays & strings. Volatile sections are no longer prefixed by '@' Added idea regarding c3 interop Added page about c interop . Removed c_ichar and c_uchar types as they are redundant. Updates to keywords on the grammar page ../syntax). Revision 2019-07-27 Updated grammar with keywords. Added the docs & comments page. Updated the pre and post conditions . Revision 2019-07-24 Idea: typed varargs. Added \"pure\" post condition Updated c3c commands. Removed the type keyword for defining union/struct/enum/error. Revision 2019-07-23 Added to generic functions examples for [] and []= Developed ideas about vectors in the idea section . Defined 2's complement for signed integers. Idea: Managed pointers. Updated naming rules for types. Added more naming rules + examples of them. Removed \"defer on function signatures\" from ideas. Removed \"managed qualifier\" from ideas. Removed \"defer sugar\" from ideas. Removed \"built in dynamic arrays\" from ideas. Added library section. Added more about pre and post conditions . Revision 2019-07-22 Added \"Design Principles\" to the index page. Revision 2019-07-21 \"return\" rather than function name is used in post conditions. See Functions Added \"@include\" macro for textual includes. See Modules . Files to without module for single file compilations is now ok as a special case. See Modules Added cone style array idea to the idea section . Added idea about defer on error to the idea section . Added idea for aliasing generic structs in the import to the idea section . Added idea for changing automatic signed <-> unsigned conversion to the idea section . Added Changes from C and Statements sections. Removal of volatile . See Changes from C and Statements Removal of const See Changes from C","title":"Changes"},{"location":"changes/#change-log","text":"Current revision made 2019-07-30.","title":"Change log"},{"location":"changes/#revision-2019-07-30","text":"Added default and named arguments to the functions page . Added varargs to the functions page . Added idea about hierarchal memory. Added idea of raw dynamic safe arrays & strings. Volatile sections are no longer prefixed by '@' Added idea regarding c3 interop Added page about c interop . Removed c_ichar and c_uchar types as they are redundant. Updates to keywords on the grammar page ../syntax).","title":"Revision 2019-07-30"},{"location":"changes/#revision-2019-07-27","text":"Updated grammar with keywords. Added the docs & comments page. Updated the pre and post conditions .","title":"Revision 2019-07-27"},{"location":"changes/#revision-2019-07-24","text":"Idea: typed varargs. Added \"pure\" post condition Updated c3c commands. Removed the type keyword for defining union/struct/enum/error.","title":"Revision 2019-07-24"},{"location":"changes/#revision-2019-07-23","text":"Added to generic functions examples for [] and []= Developed ideas about vectors in the idea section . Defined 2's complement for signed integers. Idea: Managed pointers. Updated naming rules for types. Added more naming rules + examples of them. Removed \"defer on function signatures\" from ideas. Removed \"managed qualifier\" from ideas. Removed \"defer sugar\" from ideas. Removed \"built in dynamic arrays\" from ideas. Added library section. Added more about pre and post conditions .","title":"Revision 2019-07-23"},{"location":"changes/#revision-2019-07-22","text":"Added \"Design Principles\" to the index page.","title":"Revision 2019-07-22"},{"location":"changes/#revision-2019-07-21","text":"\"return\" rather than function name is used in post conditions. See Functions Added \"@include\" macro for textual includes. See Modules . Files to without module for single file compilations is now ok as a special case. See Modules Added cone style array idea to the idea section . Added idea about defer on error to the idea section . Added idea for aliasing generic structs in the import to the idea section . Added idea for changing automatic signed <-> unsigned conversion to the idea section . Added Changes from C and Statements sections. Removal of volatile . See Changes from C and Statements Removal of const See Changes from C","title":"Revision 2019-07-21"},{"location":"changesfromc/","text":"Changes from C Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes: No mandatory header files There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications. Removal of the old C macro system The old C macro system is replaced by a new C3 macro system. Import and modules C3 uses module imports instead of header includes to link modules together. Member access using . even for pointers The -> operator is removed, access uses dot for both direct and pointer access. Note that this is just single access: to access a pointer of a pointer (e.g. int** ) an explicit dereference would be needed. Different operator precedence Notably bit operations have higher precedence than +/-, making code like this: a & b == c evaluate like (a & b) == c instead of C's a & (b == c) . See the page about precedence rules . Removal of the volatile type qualifier The volatile type qualifier is replaced by volatile sections. A volatile section is guaranteed to not be optimized away. \\\\ C volatile void test() { volatile v = 0; for (int i = 0; i < 100; i++) { // Usually this would be optimized away, // but volatile will ensure it is executed. v = 1; } } \\\\ C3 func void test() { v = 0; for (int i = 0; i < 100; i++) { // Everything in the block // will avoid optimization @volatile { v = 1; } } } Removal of the const type qualifier The const qualifier is only retained for actual constant variables. C3 uses a special type of post condition for functions to indicate that they do not alter in parameters. /** * This function ensures that foo is not changed in the function, nor is bar.x altered. * @ensure const(foo), const(bar.x) **/ func void test(Foo& foo, Bar& bar) { bar.y = foo.x; // bar.x = foo.x - compile time error! // foo.x = bar.y - compile time error! }","title":"Changes from C"},{"location":"changesfromc/#changes-from-c","text":"Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes:","title":"Changes from C"},{"location":"changesfromc/#no-mandatory-header-files","text":"There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications.","title":"No mandatory header files"},{"location":"changesfromc/#removal-of-the-old-c-macro-system","text":"The old C macro system is replaced by a new C3 macro system.","title":"Removal of the old C macro system"},{"location":"changesfromc/#import-and-modules","text":"C3 uses module imports instead of header includes to link modules together.","title":"Import and modules"},{"location":"changesfromc/#member-access-using-even-for-pointers","text":"The -> operator is removed, access uses dot for both direct and pointer access. Note that this is just single access: to access a pointer of a pointer (e.g. int** ) an explicit dereference would be needed.","title":"Member access using . even for pointers"},{"location":"changesfromc/#different-operator-precedence","text":"Notably bit operations have higher precedence than +/-, making code like this: a & b == c evaluate like (a & b) == c instead of C's a & (b == c) . See the page about precedence rules .","title":"Different operator precedence"},{"location":"changesfromc/#removal-of-the-volatile-type-qualifier","text":"The volatile type qualifier is replaced by volatile sections. A volatile section is guaranteed to not be optimized away. \\\\ C volatile void test() { volatile v = 0; for (int i = 0; i < 100; i++) { // Usually this would be optimized away, // but volatile will ensure it is executed. v = 1; } } \\\\ C3 func void test() { v = 0; for (int i = 0; i < 100; i++) { // Everything in the block // will avoid optimization @volatile { v = 1; } } }","title":"Removal of the volatile type qualifier"},{"location":"changesfromc/#removal-of-the-const-type-qualifier","text":"The const qualifier is only retained for actual constant variables. C3 uses a special type of post condition for functions to indicate that they do not alter in parameters. /** * This function ensures that foo is not changed in the function, nor is bar.x altered. * @ensure const(foo), const(bar.x) **/ func void test(Foo& foo, Bar& bar) { bar.y = foo.x; // bar.x = foo.x - compile time error! // foo.x = bar.y - compile time error! }","title":"Removal of the const type qualifier"},{"location":"cinterop/","text":"C Interop C3 aims at seamless C interop. That means that you should be able to use import with C as easy as if it was a C3 module. See the idea section for more details","title":"C Interop"},{"location":"cinterop/#c-interop","text":"C3 aims at seamless C interop. That means that you should be able to use import with C as easy as if it was a C3 module. See the idea section for more details","title":"C Interop"},{"location":"comments/","text":"Comments and docs C3 uses three distinct comment types: The normal // line comment, which is terminated at the end of the line. The classic /* ... */ C style comment. Documentation comments /** ... **/ the text within these comments will be parsed as documentation and optional contracts on the following code. Nested comments /+ ... +/ . Like C style comments, but they are allowed to nest. Documentation Documentation comments start with /** and must be terminated using */ . Note that any number of * may follow /** and any number of stars may preceed */ . Any space and * in the beginning of each line will be ignored. Here is an example: /** * Here are som docs. * @param foo The number of foos. * @required foo > 4 * @deprecated * @mycustom 2 **/ void bar(int foo) { printf(\"%d\", foo); } In the example above, the following is parsed as description: \"Here are the docs.\" , then there is a description associated with the foo parameter: \"The number of foos\" . On top of that there are two annotations for the compiler: @required foo > 4 which tells the compiler and a user of the function that a precondition is that foo must be greater than 4. It is also marked as @deprecated, which can be used to display warnings. Finally a custom annotation, \"@mycustom\" is added. The compiler is free to silently ignore such annotations, but can optionally emit warnings for them, it is otherwise ignored. Available annotations Name format @param @param <param> <description> @return @return <description> @throws @throws <description> @deprecated @deprecated <optional description> @require @require <expr1>, <expr2>, ... @ensure @ensure <expre1>, <expr2>, ... @const @const <param1>, <param2>, ... @pure @pure @reqparse @reqparse <expr1>, <expr2>, ... See pre and post conditions for information regarding @require , @ensure , @const , @pure , @reqparse .","title":"Comments & Docs"},{"location":"comments/#comments-and-docs","text":"C3 uses three distinct comment types: The normal // line comment, which is terminated at the end of the line. The classic /* ... */ C style comment. Documentation comments /** ... **/ the text within these comments will be parsed as documentation and optional contracts on the following code. Nested comments /+ ... +/ . Like C style comments, but they are allowed to nest.","title":"Comments and docs"},{"location":"comments/#documentation","text":"Documentation comments start with /** and must be terminated using */ . Note that any number of * may follow /** and any number of stars may preceed */ . Any space and * in the beginning of each line will be ignored. Here is an example: /** * Here are som docs. * @param foo The number of foos. * @required foo > 4 * @deprecated * @mycustom 2 **/ void bar(int foo) { printf(\"%d\", foo); } In the example above, the following is parsed as description: \"Here are the docs.\" , then there is a description associated with the foo parameter: \"The number of foos\" . On top of that there are two annotations for the compiler: @required foo > 4 which tells the compiler and a user of the function that a precondition is that foo must be greater than 4. It is also marked as @deprecated, which can be used to display warnings. Finally a custom annotation, \"@mycustom\" is added. The compiler is free to silently ignore such annotations, but can optionally emit warnings for them, it is otherwise ignored.","title":"Documentation"},{"location":"comments/#available-annotations","text":"Name format @param @param <param> <description> @return @return <description> @throws @throws <description> @deprecated @deprecated <optional description> @require @require <expr1>, <expr2>, ... @ensure @ensure <expre1>, <expr2>, ... @const @const <param1>, <param2>, ... @pure @pure @reqparse @reqparse <expr1>, <expr2>, ... See pre and post conditions for information regarding @require , @ensure , @const , @pure , @reqparse .","title":"Available annotations"},{"location":"contribute/","text":"Currently C3 is being designed it means that there is no compiler yet. If you'd like to contribute: Discuss the language on the r/ProgrammingLanguages Discord https://discord.gg/RczBvt Suggest improvements (send them to christoffer@aegik.com) Offer to work on the compiler","title":"Contribute"},{"location":"conversion/","text":"Number conversions and promotions C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast float to boolean conversions do not require a cast. int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 double to float conversion is allowed, but may be set to warn narrowing integer conversions require a cast widening conversions do not require a cast signed/unsigned int conversions work differently from C as detailed below float to bool do not require a cast, any non zero float value considered true C3 uses two's complement arithmetic for all integer math. Signed/unsigned int conversions In C, the can be simply described as \"convert to the type with the largest positive value\" (aside from the promotion up to int). Consequently a signed int + unsigned int converts to unsigned int. In C3, the sign is considered more important. Consequently the conversion with mixed signed / unsigned will always be converted to a signed value. The rule is as follows: Find the largest bit size of the two operands. If either is signed: convert to a signed integer of the largest bit size. If both are unsigned: convert to an unsigned integer of the largest bit size. bool byte ushort uint ulong char short int long byte bool byte ushort uint ulong char short int long byte byte byte ushort uint ulong char short int long ushort ushort ushort ushort uint ulong short short int long uint uint uint uint uint ulong int int int long ulong ulong ulong ulong ulong ulong long long long long char char char short int long char short int long short short short short int long short short int long int int int int int long int int int long long long long long long long long long long long","title":"Number conversions and promotions"},{"location":"conversion/#number-conversions-and-promotions","text":"C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast float to boolean conversions do not require a cast. int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 double to float conversion is allowed, but may be set to warn narrowing integer conversions require a cast widening conversions do not require a cast signed/unsigned int conversions work differently from C as detailed below float to bool do not require a cast, any non zero float value considered true C3 uses two's complement arithmetic for all integer math.","title":"Number conversions and promotions"},{"location":"conversion/#signedunsigned-int-conversions","text":"In C, the can be simply described as \"convert to the type with the largest positive value\" (aside from the promotion up to int). Consequently a signed int + unsigned int converts to unsigned int. In C3, the sign is considered more important. Consequently the conversion with mixed signed / unsigned will always be converted to a signed value. The rule is as follows: Find the largest bit size of the two operands. If either is signed: convert to a signed integer of the largest bit size. If both are unsigned: convert to an unsigned integer of the largest bit size. bool byte ushort uint ulong char short int long byte bool byte ushort uint ulong char short int long byte byte byte ushort uint ulong char short int long ushort ushort ushort ushort uint ulong short short int long uint uint uint uint uint ulong int int int long ulong ulong ulong ulong ulong ulong long long long long char char char short int long char short int long short short short short int long short short int long int int int int int long int int int long long long long long long long long long long long","title":"Signed/unsigned int conversions"},{"location":"errorhandling/","text":"Error Handling Unlike usual exception handling, errors in C3 build on normal returns. A function declaring errors using the throws keyword essentially returns a union containing either the return value or an 64 bit integer. A register or a flag is used to determine if the result is an error or a normal result. Because there is no stack unwinding, error handling is completely deterministic and has no additional runtime cost. The call of a function which returns an error must be preceeded by the keyword try . Error returns From C, a function throwing an error value appears simply as a union: C3 code: func int getValue() throws Corresponding C code: struct Result { char error; union { int res; uint64_t err_code; }; }; struct Result getValue(); It is possible to extract the error code and also store it, to retrieve it later: try openFile(\"foo.txt\"); catch (error err) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @name(err)); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @describe(err)); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", @cast(ulong, err)); } Some simple examples. Defining an error set error FileError { FILE_NOT_FOUND, FILE_CANNOT_OPEN, PATH_DOES_NOT_EXIST, } Throwing an error func void findFile() throws { if (File.doesFileExist(\"foo.txt\")) throw FileError.FILE_NOT_FOUND; /* ... */ } Declaring a function as throwing a specific set of errors func void findFile() throws FileError { /* ... */ } Declaring a function to throw a union of errors func void findAndParseFile() throws FileError, ParseError { /* ... */ } Calling a function that throws func void findFileAndTest() throws { try findFile(); } Catching errors func void findFileAndNoExcept() { try findFile(); catch (error err) { printf(\"An error occurred!\\n\"); return; } } Catching error subsets func void findFileAndParse2() throws ParseError { try findFileAndParse(); catch (FileError err) { printf(\"Error loading the file!\\n\"); return; } // No catch for the ParseError, so it escapes. } Scoped error catching func void testErrorScopes() { { try findFileAndParse(); catch (FileError err) { try sendAlarm(\"Error loading the file\"); catch (error err) { printf(\"Failed to send the alarm\"); } return; } } try someOtherCall(); catch (error err) { printf(\"Some other error\\n\"); } } Default values func int testDefault() { return try getIntNumberOrFail() else -1; }","title":"Errors"},{"location":"errorhandling/#error-handling","text":"Unlike usual exception handling, errors in C3 build on normal returns. A function declaring errors using the throws keyword essentially returns a union containing either the return value or an 64 bit integer. A register or a flag is used to determine if the result is an error or a normal result. Because there is no stack unwinding, error handling is completely deterministic and has no additional runtime cost. The call of a function which returns an error must be preceeded by the keyword try .","title":"Error Handling"},{"location":"errorhandling/#error-returns","text":"From C, a function throwing an error value appears simply as a union: C3 code: func int getValue() throws Corresponding C code: struct Result { char error; union { int res; uint64_t err_code; }; }; struct Result getValue(); It is possible to extract the error code and also store it, to retrieve it later: try openFile(\"foo.txt\"); catch (error err) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @name(err)); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", @describe(err)); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", @cast(ulong, err)); }","title":"Error returns"},{"location":"errorhandling/#some-simple-examples","text":"","title":"Some simple examples."},{"location":"errorhandling/#defining-an-error-set","text":"error FileError { FILE_NOT_FOUND, FILE_CANNOT_OPEN, PATH_DOES_NOT_EXIST, }","title":"Defining an error set"},{"location":"errorhandling/#throwing-an-error","text":"func void findFile() throws { if (File.doesFileExist(\"foo.txt\")) throw FileError.FILE_NOT_FOUND; /* ... */ }","title":"Throwing an error"},{"location":"errorhandling/#declaring-a-function-as-throwing-a-specific-set-of-errors","text":"func void findFile() throws FileError { /* ... */ }","title":"Declaring a function as throwing a specific set of errors"},{"location":"errorhandling/#declaring-a-function-to-throw-a-union-of-errors","text":"func void findAndParseFile() throws FileError, ParseError { /* ... */ }","title":"Declaring a function to throw a union of errors"},{"location":"errorhandling/#calling-a-function-that-throws","text":"func void findFileAndTest() throws { try findFile(); }","title":"Calling a function that throws"},{"location":"errorhandling/#catching-errors","text":"func void findFileAndNoExcept() { try findFile(); catch (error err) { printf(\"An error occurred!\\n\"); return; } }","title":"Catching errors"},{"location":"errorhandling/#catching-error-subsets","text":"func void findFileAndParse2() throws ParseError { try findFileAndParse(); catch (FileError err) { printf(\"Error loading the file!\\n\"); return; } // No catch for the ParseError, so it escapes. }","title":"Catching error subsets"},{"location":"errorhandling/#scoped-error-catching","text":"func void testErrorScopes() { { try findFileAndParse(); catch (FileError err) { try sendAlarm(\"Error loading the file\"); catch (error err) { printf(\"Failed to send the alarm\"); } return; } } try someOtherCall(); catch (error err) { printf(\"Some other error\\n\"); } }","title":"Scoped error catching"},{"location":"errorhandling/#default-values","text":"func int testDefault() { return try getIntNumberOrFail() else -1; }","title":"Default values"},{"location":"examples/","text":"if-statement func void if_example(int a) { if (a > 0) { // .. } else { // .. } } for-loop func void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io.printf(\"%d\\n\", i); } // also equal for (;;) { // .. } } while-loop func void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } } In-block declarations Any control structure may declare block level variables. func void example_if_while_for() { // a is initialized only once, when entering the while statement while (int a = 10; a > 0) { a--; } // a is initialized every time through the loop. while (int a = foo()) { // ... } // a is initialized once, but assigned every time through the loop. while (int a = 0; a = foo()) { // ... } if (int a = foo(), long b = bar(); a > 1) return @cast(int, a + b); for (int a = 0, long b = 0; a < 10; a++) { b += foo(); if (b > 10) break; } } enum + switch Switches have implicit break and scope. Use \"next\" to implicitly fallthrough or use comma: enum Height : uint { LOW = 0, MEDIUM, HIGH, } func void demo_enum(Height h) { switch (h) { case Height.LOW, Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // This also works switch (h) { case Height.LOW, case Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // Completely empty cases are not allowed. switch (h) { case Height.LOW: break; // Explicit break required, since switches can't be empty. case Height.MEDIUM: io.printf(\"Medium\"); case Height.HIGH: break; } // special checking of switching on enum types switch (h) { case Height.LOW, case Height.MEDIUM, case Height.HIGH, break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"next\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case Height.LOW: int a = 1; printf(\"A\\n\"); next; case Height.MEDIUM, int a = 2; printf(\"B\\n\"); next; case Height.HIGH, // a is not defined here printf(\"C\\n\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .all returns an array with all enums. enum State : uint { Start, Stop, } const uint lowest = State.min; const uint highest = State.max; State start = State.all[0]; defer Defer will be invoked on scope exit. func void test(int x) { defer printf(\"A\"); if (x = 1) return; { defer printf(\"B\"); if (x == 0) return; } printf(\"!\") } test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"!BA\" Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. func void test(int x) { defer printf(\"A\"); defer catch printf(\"B\") defer catch (error e) printf(\"%s\", @name(e)); if (x = 1) return throw Error.FOO; printf(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and throws struct types type Callback func int(char c); enum Status : int { IDLE, BUSY, DONE, } struct MyData { char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } } Function pointers module demo; type Callback func int(char* text, int value); // also shows function attribute func int my_callback(char* text, int value) @(unused_params) { return 0; } Callback cb = demo.my_callback; func void example_cb() { int result = cb(\"demo\", 123); // .. } Error handling Errors are sent as a result value but uses an exception-like try/catch syntax. error RandomError { NORMAL, EXCEPTIONAL } func int mayThrowError() throws RandomError { if (rand() > 0.5) throw RandomError.NORMAL; if (rand() > 0.99) throw RandomError.EXCEPTIONAL; return 1; } func void testMayError() throws { // all throwable sites must be annotated with \"try\" try mayThrowError(); } func void testWithoutError() { try testMayError(); // Catching will catch any try above in the scope. catch (error e) { case RandomError.NORMAL: io.printf(\"Normal Error\\n\"); case RandomError.EXCEPTIONAL: io.printf(\"You win!\"); default: io.printf(\"What is this error you're talking about?\"); } } Pre and post conditions Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure testFoo < 10000, testFoo > 0 **/ func int testFoo(int foo) { return foo * 10; } /** * @param array : the array to test * @param length : length of the array * @require length > 0 **/ func int getLastElement(int? array, int length) { return array[length - 1]; } Macros Macro arguments may be immediately evaluated. macro foo(a, b) { return *a(b); } func int square(int x) { return x * x; } func int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion. macro foo(&a, b, &c) { c = a(b) * b; } macro foo2(&a) { return a * a; } func int square(int x) { return x * x; } func int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } func int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x : value to square * @require x * x >= 0 : \"cannot multiply\" **/ macro square(x) { return x * x; } func void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' } Nullability annotations Use * for nullable pointers, & for non nullable pointers. func Foo* getFoo() { ... } func Foo& getFooNotNull() { ... } func testThings() { int i; Foo* foo1 = getFoo(); // i = foo1.intVal; // Error, reference may be null Foo& foo2 = getFooNotNull(); i = foo2.intVal; assert(foo1); i = foo1.intVal; }","title":"Examples"},{"location":"examples/#if-statement","text":"func void if_example(int a) { if (a > 0) { // .. } else { // .. } }","title":"if-statement"},{"location":"examples/#for-loop","text":"func void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io.printf(\"%d\\n\", i); } // also equal for (;;) { // .. } }","title":"for-loop"},{"location":"examples/#while-loop","text":"func void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } }","title":"while-loop"},{"location":"examples/#in-block-declarations","text":"Any control structure may declare block level variables. func void example_if_while_for() { // a is initialized only once, when entering the while statement while (int a = 10; a > 0) { a--; } // a is initialized every time through the loop. while (int a = foo()) { // ... } // a is initialized once, but assigned every time through the loop. while (int a = 0; a = foo()) { // ... } if (int a = foo(), long b = bar(); a > 1) return @cast(int, a + b); for (int a = 0, long b = 0; a < 10; a++) { b += foo(); if (b > 10) break; } }","title":"In-block declarations"},{"location":"examples/#enum-switch","text":"Switches have implicit break and scope. Use \"next\" to implicitly fallthrough or use comma: enum Height : uint { LOW = 0, MEDIUM, HIGH, } func void demo_enum(Height h) { switch (h) { case Height.LOW, Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // This also works switch (h) { case Height.LOW, case Height.MEDIUM: io.printf(\"Not high\"); // Implicit break. case Height.HIGH: io.printf(\"High\"); } // Completely empty cases are not allowed. switch (h) { case Height.LOW: break; // Explicit break required, since switches can't be empty. case Height.MEDIUM: io.printf(\"Medium\"); case Height.HIGH: break; } // special checking of switching on enum types switch (h) { case Height.LOW, case Height.MEDIUM, case Height.HIGH, break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"next\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case Height.LOW: int a = 1; printf(\"A\\n\"); next; case Height.MEDIUM, int a = 2; printf(\"B\\n\"); next; case Height.HIGH, // a is not defined here printf(\"C\\n\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .all returns an array with all enums. enum State : uint { Start, Stop, } const uint lowest = State.min; const uint highest = State.max; State start = State.all[0];","title":"enum + switch"},{"location":"examples/#defer","text":"Defer will be invoked on scope exit. func void test(int x) { defer printf(\"A\"); if (x = 1) return; { defer printf(\"B\"); if (x == 0) return; } printf(\"!\") } test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"!BA\" Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. func void test(int x) { defer printf(\"A\"); defer catch printf(\"B\") defer catch (error e) printf(\"%s\", @name(e)); if (x = 1) return throw Error.FOO; printf(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and throws","title":"defer"},{"location":"examples/#struct-types","text":"type Callback func int(char c); enum Status : int { IDLE, BUSY, DONE, } struct MyData { char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } }","title":"struct types"},{"location":"examples/#function-pointers","text":"module demo; type Callback func int(char* text, int value); // also shows function attribute func int my_callback(char* text, int value) @(unused_params) { return 0; } Callback cb = demo.my_callback; func void example_cb() { int result = cb(\"demo\", 123); // .. }","title":"Function pointers"},{"location":"examples/#error-handling","text":"Errors are sent as a result value but uses an exception-like try/catch syntax. error RandomError { NORMAL, EXCEPTIONAL } func int mayThrowError() throws RandomError { if (rand() > 0.5) throw RandomError.NORMAL; if (rand() > 0.99) throw RandomError.EXCEPTIONAL; return 1; } func void testMayError() throws { // all throwable sites must be annotated with \"try\" try mayThrowError(); } func void testWithoutError() { try testMayError(); // Catching will catch any try above in the scope. catch (error e) { case RandomError.NORMAL: io.printf(\"Normal Error\\n\"); case RandomError.EXCEPTIONAL: io.printf(\"You win!\"); default: io.printf(\"What is this error you're talking about?\"); } }","title":"Error handling"},{"location":"examples/#pre-and-post-conditions","text":"Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure testFoo < 10000, testFoo > 0 **/ func int testFoo(int foo) { return foo * 10; } /** * @param array : the array to test * @param length : length of the array * @require length > 0 **/ func int getLastElement(int? array, int length) { return array[length - 1]; }","title":"Pre and post conditions"},{"location":"examples/#macros","text":"Macro arguments may be immediately evaluated. macro foo(a, b) { return *a(b); } func int square(int x) { return x * x; } func int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion. macro foo(&a, b, &c) { c = a(b) * b; } macro foo2(&a) { return a * a; } func int square(int x) { return x * x; } func int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } func int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x : value to square * @require x * x >= 0 : \"cannot multiply\" **/ macro square(x) { return x * x; } func void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' }","title":"Macros"},{"location":"examples/#nullability-annotations","text":"Use * for nullable pointers, & for non nullable pointers. func Foo* getFoo() { ... } func Foo& getFooNotNull() { ... } func testThings() { int i; Foo* foo1 = getFoo(); // i = foo1.intVal; // Error, reference may be null Foo& foo2 = getFooNotNull(); i = foo2.intVal; assert(foo1); i = foo1.intVal; }","title":"Nullability annotations"},{"location":"firstproject/","text":"Your First Project Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import stdio; public func int main(int argc, char*[] argv) { printf(\"Hello World!\\n\"); return 0; } Now in the terminal type: $ c3c hello_world.c3 $ ./hello_world.a Hello World $ A real project Once you go beyond simple files, you want to create a real project. Do so by entering c3c -new hello_world . You will get the following structure: $ c3c -new hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"Your first project"},{"location":"firstproject/#your-first-project","text":"Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import stdio; public func int main(int argc, char*[] argv) { printf(\"Hello World!\\n\"); return 0; } Now in the terminal type: $ c3c hello_world.c3 $ ./hello_world.a Hello World $","title":"Your First Project"},{"location":"firstproject/#a-real-project","text":"Once you go beyond simple files, you want to create a real project. Do so by entering c3c -new hello_world . You will get the following structure: $ c3c -new hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.toml \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"A real project"},{"location":"functions/","text":"Functions C3 has both regular functions and member functions. Member functions are name spaced using a type name, and allows invocations using the dot syntax. Regular functions Regular functions looks similar to C. It starts with the keyword func , followed by the conventional C declaration of <return type> <name>(<parameter list>) . C3 adds a throws declaration, that will declare that the function might return an error instead of its usual return value. func void test(int times) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i); } } Function arguments - NEW! C3 allows use of default arguments as well as named arguments. func int testWithDefault(int foo = 1) { return foo; } func void test() { testWithDefault(); testWithDefault(100); } Named arguments func void testNamed(int times, double data) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(data = 3.0, times = 1) testNamed(3, 4.0); } Named arguments with defaults: func void testNamedDefault(int times = 1, double data = 3.0, bool dummy = false) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(data = 3.0) // Mixing named and defaults: testNamed(3, dummy = false); // Mixing named and defaults leaving out initial values: testNamed(,,false, times = 1); } Varargs - NEW! There are two types of varargs: the usual C-style untyped varargs and typed varargs. Untyped varargs will always send arguments as-is, whereas typed arguments will do normal conversions. func void varargsUntyped(string foo, ...) { /* ... */ } func void varargsTyped(string bar, int... ints) { /* ... */ } func void test() { varargsUntyped(\"Hello\", 2, 1.0, cast(byte, 1), \"Test\"); varargsTyped(\"Test\", 2, cast(byte, 1)); // The second parameter will be converted to an int implicitly. } Using throws The throws parameter may return a generic throws clause \u2013 in this case the error type is unknown. The below example might throw errors from both the SomeError error domain as well as the OtherError error domain. func int test() throws { if (random_value() > 0.2) throw SomeError.BAD_JOSS_ERROR; if (random_value() > 0.5) throw OtherError.BAD_LUCK_ERROR; return 0; } The errors can be explicitly documented, by listing the error domains, separated by , func int test() throws SomeError, OtherError { if (random_value() > 0.2) throw SomeError.BAD_JOSS_ERROR; if (random_value() > 0.5) throw OtherError.BAD_LUCK_ERROR; return 0; } Member functions Member functions look exactly like functions, but are prefixed with the struct, union or enum name: struct Point { int x; int y; } func void Point.add(Point& p, int x) { p.x = x; } func void example() { Point p = { 1, 2 } // with struct-functions p.add(10); // Also callable as: Point.add(&p, 10); } If a member function does not take the type as the first parameter, then it may only be invoked qualified with the type name: func Point& Point.new(int x, int y) { Point &p = malloc(@sizeof(Point)); p.x = x; p.y = y; return p; } func void example2() { Point &p = Point.new(1, 2); } Struct and unions will always take pointer, whereas enums take the enum value. enum State { STOPPED, RUNNING } func bool State.mayOpen(State state) { switch (state) { case State.STOPPED: return true; case State.RUNNING: return false; } } Restrictions on member functions Member functions may not: Member functions on a struct/union may not have the same name as a member. Member functions only works on struct, union and enum types. When taking a function pointer of a member function, use the full name. Using sub types, overlapping function names will be shadowed. Pre and post conditions C3's error handling is not intended to use errors to signal invalid data or to check invariants and post conditions. Instead C3's approach is to add annotations to the function, that conditionally will be compiled into asserts. As an example, the following code: /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure return < 10000, return > 0 **/ func int testFoo(int foo) { return foo * 10; } Will in debug builds be compiled into something like this: func int testFoo(int foo) { assert(foo > 0); assert(foo < 1000); int _return = foo * 10; assert(_return < 10000); assert(_return > 0); return _return; } The compiler is allowed to use the pre and post conditions for optimizations. For example this: func int testExample(int bar) { if (testFoo(bar) == 0) return -1; return 1; } May be optimized to: func int testExample(int bar) { return 1; } In this case the compiler can look at the post condition of result > 0 to determine that testFoo(foo) == 0 must always be false. Looking closely at this code, we not that nothing guarantees that bar is not violating the preconditions. In debug builds this will usually be checked in runtime, but a sufficiently smart compiler will warn about the lack of checks on bar . Execution of code violating pre and post conditions has undefined behaviour.","title":"Functions"},{"location":"functions/#functions","text":"C3 has both regular functions and member functions. Member functions are name spaced using a type name, and allows invocations using the dot syntax.","title":"Functions"},{"location":"functions/#regular-functions","text":"Regular functions looks similar to C. It starts with the keyword func , followed by the conventional C declaration of <return type> <name>(<parameter list>) . C3 adds a throws declaration, that will declare that the function might return an error instead of its usual return value. func void test(int times) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i); } }","title":"Regular functions"},{"location":"functions/#function-arguments-new","text":"C3 allows use of default arguments as well as named arguments. func int testWithDefault(int foo = 1) { return foo; } func void test() { testWithDefault(); testWithDefault(100); } Named arguments func void testNamed(int times, double data) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(data = 3.0, times = 1) testNamed(3, 4.0); } Named arguments with defaults: func void testNamedDefault(int times = 1, double data = 3.0, bool dummy = false) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } func void test() { testNamed(data = 3.0) // Mixing named and defaults: testNamed(3, dummy = false); // Mixing named and defaults leaving out initial values: testNamed(,,false, times = 1); }","title":"Function arguments - NEW!"},{"location":"functions/#varargs-new","text":"There are two types of varargs: the usual C-style untyped varargs and typed varargs. Untyped varargs will always send arguments as-is, whereas typed arguments will do normal conversions. func void varargsUntyped(string foo, ...) { /* ... */ } func void varargsTyped(string bar, int... ints) { /* ... */ } func void test() { varargsUntyped(\"Hello\", 2, 1.0, cast(byte, 1), \"Test\"); varargsTyped(\"Test\", 2, cast(byte, 1)); // The second parameter will be converted to an int implicitly. }","title":"Varargs - NEW!"},{"location":"functions/#using-throws","text":"The throws parameter may return a generic throws clause \u2013 in this case the error type is unknown. The below example might throw errors from both the SomeError error domain as well as the OtherError error domain. func int test() throws { if (random_value() > 0.2) throw SomeError.BAD_JOSS_ERROR; if (random_value() > 0.5) throw OtherError.BAD_LUCK_ERROR; return 0; } The errors can be explicitly documented, by listing the error domains, separated by , func int test() throws SomeError, OtherError { if (random_value() > 0.2) throw SomeError.BAD_JOSS_ERROR; if (random_value() > 0.5) throw OtherError.BAD_LUCK_ERROR; return 0; }","title":"Using throws"},{"location":"functions/#member-functions","text":"Member functions look exactly like functions, but are prefixed with the struct, union or enum name: struct Point { int x; int y; } func void Point.add(Point& p, int x) { p.x = x; } func void example() { Point p = { 1, 2 } // with struct-functions p.add(10); // Also callable as: Point.add(&p, 10); } If a member function does not take the type as the first parameter, then it may only be invoked qualified with the type name: func Point& Point.new(int x, int y) { Point &p = malloc(@sizeof(Point)); p.x = x; p.y = y; return p; } func void example2() { Point &p = Point.new(1, 2); } Struct and unions will always take pointer, whereas enums take the enum value. enum State { STOPPED, RUNNING } func bool State.mayOpen(State state) { switch (state) { case State.STOPPED: return true; case State.RUNNING: return false; } }","title":"Member functions"},{"location":"functions/#restrictions-on-member-functions","text":"Member functions may not: Member functions on a struct/union may not have the same name as a member. Member functions only works on struct, union and enum types. When taking a function pointer of a member function, use the full name. Using sub types, overlapping function names will be shadowed.","title":"Restrictions on member functions"},{"location":"functions/#pre-and-post-conditions","text":"C3's error handling is not intended to use errors to signal invalid data or to check invariants and post conditions. Instead C3's approach is to add annotations to the function, that conditionally will be compiled into asserts. As an example, the following code: /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure return < 10000, return > 0 **/ func int testFoo(int foo) { return foo * 10; } Will in debug builds be compiled into something like this: func int testFoo(int foo) { assert(foo > 0); assert(foo < 1000); int _return = foo * 10; assert(_return < 10000); assert(_return > 0); return _return; } The compiler is allowed to use the pre and post conditions for optimizations. For example this: func int testExample(int bar) { if (testFoo(bar) == 0) return -1; return 1; } May be optimized to: func int testExample(int bar) { return 1; } In this case the compiler can look at the post condition of result > 0 to determine that testFoo(foo) == 0 must always be false. Looking closely at this code, we not that nothing guarantees that bar is not violating the preconditions. In debug builds this will usually be checked in runtime, but a sufficiently smart compiler will warn about the lack of checks on bar . Execution of code violating pre and post conditions has undefined behaviour.","title":"Pre and post conditions"},{"location":"generics/","text":"Generics Generic functionality is mostly provided by macros and generic modules. Bridging the gap is generic functions, that allow a limited for of overloading. Generic functions Generic functions is a specialized type of macros. They allow overloading using a common symbol, just like C11's _Generic : generic abs(x) { case double: return fabs(x); case int: return abs(x); } Unlike a regular macro, a generic function is not invoked with @. It may also be extended by other packages / files: // File 1 module foo; generic abs(x) { case double: return fabs(x); case int: return abs(x); } // File 2 module bar; generic foo.abs(x) { case long: return absl(x); case int: // Compile time error, already defined return abs(x); } It is possible to dispatch on multiple arguments: module foo; generic add(x, y) { case double, double: return x + y; case int, double: return (double)x + y; } Generics can also be used for overloading operators: generic operator_add(x, y) { case vector3, vector3: return vector_add(x, y); } generic operator_index(x, y) { case DynArray, int: return x.get(y); // Enables foo[12] } generic operator_index_assign(x, y, z) { case DynArray, int: return x.set(y, z); // Enables foo[12] = 2 } Note that generics is actually a macro expansion. Consequently this is possible: generic weird_fun(x) { case int: printf(\"%d\", x); case Foo: while (foo.bar > 0) { foo.bar--; printf(\"Hi\"); } } void func test() { Foo foo; weird_fun(2); // Prints \"2\" foo.bar = 4; wierd_fun(foo); // Prints \"HiHiHiHi\" } Shorthand There is also a shorthand for declaring generics that only match a single type \u2013 it's done by declaring the types directly in the header: generic add(double x, double y) { return x + y; } Generic modules Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: module vector (A, B, C); // A, B, C are generic parameters. The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test (A, B); struct Foo { A a; } func C test(B b, Foo *foo) { return a + b; } When including a generic module, the generic parameters specified in the import, but must be aliased or imported as local . If local , more than one generic of the type may not be used. import vector(double, float, int) as generic_test; import foo(int, int) local; // import foo(float, float) local; \u2013 Not allowed Just like for macros, optional constraints may be added to improve compile errors: /** * @require c = a + b */ module vector (A, B, C); /* .. code * ../ import vector(Bar, f32, i32) as gen_test; // This would give the error // --> Illegal arguments for generic module vector, breaks requirement 'Bar' = 'f32' + 'i32'","title":"Generics"},{"location":"generics/#generics","text":"Generic functionality is mostly provided by macros and generic modules. Bridging the gap is generic functions, that allow a limited for of overloading.","title":"Generics"},{"location":"generics/#generic-functions","text":"Generic functions is a specialized type of macros. They allow overloading using a common symbol, just like C11's _Generic : generic abs(x) { case double: return fabs(x); case int: return abs(x); } Unlike a regular macro, a generic function is not invoked with @. It may also be extended by other packages / files: // File 1 module foo; generic abs(x) { case double: return fabs(x); case int: return abs(x); } // File 2 module bar; generic foo.abs(x) { case long: return absl(x); case int: // Compile time error, already defined return abs(x); } It is possible to dispatch on multiple arguments: module foo; generic add(x, y) { case double, double: return x + y; case int, double: return (double)x + y; } Generics can also be used for overloading operators: generic operator_add(x, y) { case vector3, vector3: return vector_add(x, y); } generic operator_index(x, y) { case DynArray, int: return x.get(y); // Enables foo[12] } generic operator_index_assign(x, y, z) { case DynArray, int: return x.set(y, z); // Enables foo[12] = 2 } Note that generics is actually a macro expansion. Consequently this is possible: generic weird_fun(x) { case int: printf(\"%d\", x); case Foo: while (foo.bar > 0) { foo.bar--; printf(\"Hi\"); } } void func test() { Foo foo; weird_fun(2); // Prints \"2\" foo.bar = 4; wierd_fun(foo); // Prints \"HiHiHiHi\" }","title":"Generic functions"},{"location":"generics/#shorthand","text":"There is also a shorthand for declaring generics that only match a single type \u2013 it's done by declaring the types directly in the header: generic add(double x, double y) { return x + y; }","title":"Shorthand"},{"location":"generics/#generic-modules","text":"Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: module vector (A, B, C); // A, B, C are generic parameters. The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test (A, B); struct Foo { A a; } func C test(B b, Foo *foo) { return a + b; } When including a generic module, the generic parameters specified in the import, but must be aliased or imported as local . If local , more than one generic of the type may not be used. import vector(double, float, int) as generic_test; import foo(int, int) local; // import foo(float, float) local; \u2013 Not allowed Just like for macros, optional constraints may be added to improve compile errors: /** * @require c = a + b */ module vector (A, B, C); /* .. code * ../ import vector(Bar, f32, i32) as gen_test; // This would give the error // --> Illegal arguments for generic module vector, breaks requirement 'Bar' = 'f32' + 'i32'","title":"Generic modules"},{"location":"ideas/","text":"Ideas WARNING Unfinished ideas / brain dumps C interop Steps: Add group header in the builds: [c-libs] Add the search paths: cpath = [\"/xxx/foo/ \", \"/bar/headers/ \"] Add each library: [[lib]] [c-libs] cpath = [\"/xxx/foo/**\", \"/bar/headers/**\"] [[lib]] module = \"windows\" header = \"windows.h\" [[lib]] module = \"stdlib\" header = \"stdlib.h\" Managed pointers Managed pointers are introduced using the pointer @ after the type, e.g. Foo@ f . A manage value will need to implement the member function release and retain . What these functions actually does is up to the implementation. For example, we may have a struct that use these functions to handle a reference count. Managed pointers will then allow automatic reference counting: Foo@ f = Foo.alloc(); Foo@ b = f; // Converted to: f.retain(); b = f; f = nil; // Converted to: f.release(); f = nil; Any managed variable that goes out of the scope will automatically invoke release , as if the pointer was set to nil . { Foo@ b = Foo.alloc(); } // Automatic invocation of b.release(); In order to return a managed pointer that can be used as a temporary, it's often convenient to mark the return value as managed. func Foo@ createFoo() { return Foo.alloc(); } createFoo(); // Implicitly introduces a deferred release. If we assign a managed pointer to a variable, the release/retain is elided // The following becomes f1 = createFoo() - no deferred release or retains. Foo@ f1 = createFoo(); It's possible to manually manage a managed pointer: Foo* f2 = createFoo().retain(); f2.release(); // Required to prevent leaks. A managed pointer may safely assigned to a regular pointer as long as it's not retained outside of the scope. { Foo* f3 = createFoo(); printf(\"%d\", f3.someValue); // Safe, since f3 isn't actually used after the scope. } Foo* unsafeFoo; { unsafeFoo = createFoo(); } // <- access to unsafeFoo at this point will likely break things. Arrays Developing the Cone proposal a bit: Fixed Arrays <type>[<size>] e.g. int[4] . These are treated as values and will be copied if given as parameter. Unlike C, the number is part of its type. Taking a pointer to a fixed array will create a pointer to a fixed array, e.g. int[4]* . Fat array pointers <type>[] e.g. int[] . This is a pointer to an array and it is possible to convert any fixed array to a fat array pointer. int[4] a = { 1, 2, 3, 4}; int[] b = a; // Implicit conversion is always ok. int[4] c = @cast(int[4], b); // Will copy the value of b into c. int[4]* d = @cast(int[4]*, b); // Equivalent to d = &a b.len; // Returns 4 int* e = b; // Equivalent to e = &a e = d; // implicit conversion ok. d = e; // ERROR! Not allowed d = @cast(int[4]*, e); // Fine Conversion list int[4] int[] int[4]* int* int[4] assign cast - - int[] assign assign - - int[4]* - - assign cast int* - assign assign assign Internals Internally the layout of a fat array pointer is guaranteed to be struct { <type>* ptrToArray; usize arraySize; } . There is a built in struct __ArrayType_C3 which has the exact data layout of the fat array pointers. It is defined to be struct __ArrayType_C3 { void* ptrToArray; usize arraySize; } Raw dynamic, safe arrays - NEW! Works just like a pointer Not safe to keep reference to if made dynamic. Requires special method to dispose of and to allocate Knows its size. Raw dynamic, safe strings - NEW! Works just like a pointer. Not safe to keep reference if made dynamic Requires special method to dispose of and to allocate Knows its size. Dynamic arrays Dynamic arrays are provided as a library and they are usually ref counted: import array(int) alias IntArray; IntArray@ a = IntArray.new(); a += 23; // Append last a.pop(); // Remove last a.insert(1, 11); // Insert at position a.insert_front(12); // Insert at 0 a.pop_front(); // Remove first. a.last(); // Return last Thanks to generic overloading this is also possible: a += 23; a[2] = 11; a[2] // Prints 11. Unsorted Halloc - NEW! Hierarchal memory allocation http://swapped.cc/#!/halloc support it? Varargs Use typed varargs? E.g. void foo(int x, float... foo) where the type of foo becomes float[] Change main to void main(char*[] args) ? Unsigned conversion to signed Perhaps consider signed, rather than unsigned implicit conversion. Currently ulong + long becomes ulong + @cast(ulong, long) (according to C rules). Consider changing that to @cast(long, ulong) + long . That is, instead of \"unsigned wins\", use \"signed wins\". Aliasing in import It might be useful to express aliasing directly on import. Consider for example a generic library with a Set type. Typically we'd do like this: import set(int) as intset; func void test() { intset.Set* set = intset.Set.new(); /* ... */ } Or import it as a local variable, which is nice, but can only be done for a single set: import set(int) local; func void test() { Set* set = Set.new(); /* ... */ } Adding a direct alias on the set as it is imported would be nice: import set(int) as intset alias Set as IntSet; import set(double) as doubleset alias Set as DoubleSet; func void test() { IntSet* set = IntSet.new(); DoubleSet* set2 = DoubleSet.new(); /* ... */ } Note that the alias is always used without a prefix. If a generic module only has a single generic struct one wishes to use, it's useful to shorten this further at the cost of not being able to access any other symbols (as we cannot use the generic name as a namespace prefix). import set(int) alias Set as IntSet; import set(double) alias Set as DoubleSet; We could go even further, saying that if there is only a single generic struct inside, then we may shorten with the struct being used as a default: import set(int) alias IntSet; import set(double) alias DoubleSet; It's unclear whether this is is helpful or not. Should be discussed further. Tagged any A tagged pointer union type for any possible type. Defer for error Introduce an error defer that is only called on error: func void test() throws { defer throw(e) { printf(\"Had an error!\\n\"); } if (rand() == 0) throw Error.TEST; } The code above would be functionally equivalent to: func void test() throws { if (rand() == 0) { printf(\"Had an error!\\n\"); throw Error.TEST; } } Cone style arrays Fixed static sized arrays do not automatically decay into pointers (that is int[3] does not decay into int*) Fixed static sized arrays are treated as structs with that many identical items, and will be passed by value Fixed static sized arrays can be converted into fat array pointers int[] would be a fat pointer to an array. Iteration over fat array pointers are defined in the language Taking the reference of a static fixed pointer of size X yields a pointer to that fixed pointer, e.g. int[4]* Automatic conversion from fixed to fat pointer: int[4] y = { 1, 2, 3, 4 }; int[] x = y; Automatic conversion from dynamic array to fat pointer: int[+] y = { 1, 2 }; int[] x = y Require explicit uninitialization int a = ---; int a = void; // Other possible variant Extended \"case\" Switch as \"if-else\" switch (x) { case x > 200: return 0; case x < 2: small_x_warning(); case 0: .... case x > y && a < 1: ... } Case as a range switch (x) { case 1 .. 10: ... case 11 .. 100: ... } Easy to get properties Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports Associate properties to an enum enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" } Tagged unions tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And yet another... struct Shape { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; } Interfaces func void Foo.renderPage(Foo& foo, Page& info) { /* ... */ } interface Renderer { void renderPage(Renderer& renderer, Page& info); } func void render(Renderer* renderer, Page& info) { if (rendered == null) return; renderer->renderPage(info); } func void test() { Foo* foo = getFoo(); Page& page = getPage(); // Option 1 Renderer.render(foo, page); // Option 2 Renderer* renderer = foo; renderer.render(page); } // C equivalent: // struct RendererVtable { // void (*renderPage)(void*, Page*); // }; // struct RendererRef { // void* ref; RendererVTable *vtable; // }; // void Renderer__render(struct RendererRef renderer, Page *info) { // if (renderer.ref == null) return; // renderer.vtable->renderPage(renderer.ref, info); // } // // void test() { // Foo *foo = getFoo(); // Page *page = getPage(); // // static RenderVTable FooRendererVTable = { &Foo__renderPage }; // Renderer__render(struct RendererRef { foo, &FooRendererVTable }, page); // // struct RendererRef renderer = { foo, &FooRendererVTable }; // Renderer__render(renderer, page); // } Possible syntax ideas: func void test() { Renderer* renderer1 = getFoo(); // Implicit Renderer* renderer2 = Renderer(getFoo()); Renderer* renderer3 = getFoo() as Renderer; Renderer* renderer4 = @wrap(Renderer, getFoo()); // Macro Renderer renderer5 = getFoo(); // Look, no pointer! Renderer@ renderer6 = getFoo(); // Special pointer type? interface Renderer renderer7 = getFoo(); // Love long lines @Renderer renderer8 = getFoo(); Renderer^ renderer9 = getFoo(); // Pascal Renderer renderer10 = interface getFoo(); Renderer renderer11 = interface(getFoo()); Renderer renderer12 = virtual { getFoo() }; virtual Renderer renderer13 = getFoo(); virtual Renderer renderer14 = getFoo(); } func void render(Renderer renderer, Page& info) { renderer.renderPage(info); } virtual Renderer { void renderPage(Page &info); } func void render(virtual Renderer& renderer, Page& info) { renderer.renderPage(info); } func void render(virtual Renderer& renderer, Page& info) { renderer->renderPage(info); } func void render(interface Renderer& renderer, Page& info) { renderer->renderPage(info); } interface Renderer*[4] renderers; interface Renderer[4] renderers; virtual Renderer[4] renderers; Renderer*[4] renderers; Built in maps Same reasoing as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = try map[0]; // Requires a try // Retrive or use default int i = try map[12] else -1; // Extend a map: func bool int[int].remove_if_negative(int[int] &map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int &map, int32_t index); Built in string type Strings are built-in, refcounted(?) null-terminated character arrays. Take a long hard look at memory management (here too) string = \"Hello\"; string += \" World\"; char* data = &string; // Taking a pointer to the string, which may later be invalid. Built in managed pointers Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check. Ideas around macros Just some previous thoughts and ideas I've considered. Many of those actually go against the current design. Compile time variables This is a variant of what already exists in C, but in a syntactically more friendly way. For example this would be ok: macro swap(a, b) { $x = typeof(a); static_assert(typeof(b) == $x); $x temp = a; a = b; b = a; } The example above is a bit contrived as in the above example we could simply have: macro swap(a, b) { static_assert(typeof(b) == typeof(b)); typeof(a) temp = a; a = b; b = a; } But still, it serves as an example on how to use it. Capturing trailing compound statement public macro foreach(thelist, @body(Element *) ) { Element* iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Or a version that is more flexible: public macro foreach(thelist, @body(typeof(thelist.first)) ) { typeof(thelist.first) iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } // Usage: foreach(list, Element *i) // <- Note type declaration! { i.print(); } Since type is going to appear very often, we could make a shortcut for it, like $@ as prefix meaning \"typeof\". We then get public macro foreach(thelist, @body($@thelist.first)) { $@thelist.first iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Possibly one could even write the code like this: public macro foreach(thelist, @body($element_type) ) { $element_type iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } In this case $element_type works like \"auto\", but is also assigned the type, which then can be referred to in the signature. Yet another way to do macros :D This was an older attempt... First, we have to consider macros as always expanding where they are referenced to keep it simple. macro @foo(int v) { v++; if (v > 10) return 10; return v; } func void test() { int a = 10; @foo(a); } This code would then be exactly equal to: func void test() { int a = 10; a++; if (a > 10) return 10; } Macros simply expand in place. Secondly, we can have macros returning values: macro int @foo2(int v, int w) { v++; if (v > 10) return 10; w += 3; return 0; } func void test() { int d = 0; int a = 10; int b = @foo(a, d); } This expands to: func void test() { int d = 0; int a = 10; a++ int b; if (a > 10) { b = 10; } else { b = 0; d += 3; } } Note that I'm using a sigil to indicate the code expansion to make macros more obvious. We can allow the macro to take a body (here I'm calling the type of the body \"{}\") macro int @foo3(int a, {} body) { while (a > 10) { a--; @body(); // Like a macro! } } func void test() { b = 20; @foo3(b) { print(b); } } We expand this to: func void test() { b = 20; while (b > 10) { b--; print(b); } } Stepwise from C macros into C3 macros #define ADD_TO(x, y) { x += y; } ADD_TO(x, 1) The { } introduces a multiline macro that does not need explicit linebreaks. No, add the \"$\" symbol to introduce hygienic temporaries: #define SWAP(x, y) { typeof(x) $tmp = x; x = y; y = $tmp; } Here $tmp will actually be replaced by __<macro>_<variable_name>_<instance> when translating to C, so __SWAP_tmp_1 , __SWAP_tmp_2 etc. We then introduce the syntax macros using: macro swap(&a, &b) { typeof(a) $tmp = a; b = a; a = $tmp; } (Note the different use of $ here as compared to previous macro ideas where $ is a compile time evaluated variable!) The use of &a follows C++ standard: it simply refers to a variable OR EXPRESSION that is imported into its scope. Using the unadorned variable name as evaluated expression allows us to write this code: macro max(a, b) { return (a > b ? a : b) } The above code is equivalent to: macro max(&a, &b) { typeof(a) $tmp_a = a; typeof(b) $tmp_b = b; $tmp_a > $tmp_b ? $tmp_a : $tmp_b } Or in (GNU) C: #define max(a,b) \\ ({ __typeof__ (a) _a = (a); \\ __typeof__ (b) _b = (b); \\ _a > _b ? _a : _b; }) To recap: Add the { } format to #define for multiline defines. Add $<name> format as hygienic variable names. Add the syntax \"macro\" type of definition. The syntax macro makes a difference between \"normal\" parameters (with & as prefix) and \"evaluated\" parameters (unadorned variables) Important is also to scope the macros: #define is always defined local to a scope (unlike in C). This means that #define FOO printf(\"foo\"); { #define BAR printf(\"bar\"); } FOO // adds printf(\"foo\"); BAR; // Error, define not available in scope; This also means that a define can be declared public to be accessed as if defined from the top of the file scope: // file 1 module foo public #define FOO { printf(\"FOO!\\n\"); } // file 2 import foo func void test() { foo.FOO } Only defines in the file scope that exists in the file scope may be public and used in other modules. Yet another macro proposal I found Simple macros macro @foo(&b) { b++; } func test() { int x = 1; @foo(x); } // Same as: func void test() { int x = 1; x++; } Macro with compile time values: macro @foo($x, &b) { b += $x; } func void test() { int x = 1; @foo(10, x); } // Expands to: func void test() { int x = 1; x += 10; } Macro with string capture macro @foo($x, #f) { `#f $x * $x`; } func void test() { i32 x = 1; @foo(4, \"x += \"); } // Expands to func void test() { i32 x = 1; x += 4 * 4; } macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { i32 x = 1; @foo2(\"x\"); } // Expands to funct void test2() { i32 x = 1; printf(\"%s was %d\\n\", \"x\", x); } Macro with conditional compile time values macro @foo($x, &b) { $IF ($x > 3) { b += $x * $x; } $ELSE { b += $x; } } func void test() { i32 x = 1; @foo(10, x); @foo(2, x); } // Expands to func void test() { i32 x = 1; x += 100; x += 2; } Nested macros (don't do this, but an example) macro @foo($a) { printf(\"%d\\n\", $a); $IF($a > 0) { @foo($a - 1); } } func void test() { @foo(2); } // Expands to func void test() { printf(\"%d\\n\", 2); printf(\"%d\\n\", 1); printf(\"%d\\n\", 0); } The above suggests macro sugar of loops: macro @foo($a) { $EACH(0..$a AS $x) { printf(\"%d\\n\", $x); } } macro @foo_enum(&a) { $EACH(a AS $x) { printf(\"%d\\n\", @cast(int, $x)); } } enum MyEnum { A, B, FOO } func void test() { @foo_enum(MyEnum); } // Expands to func void test() { printf(\"%d\\n\", @cast(int, A)); printf(\"%d\\n\", @cast(int, B)); printf(\"%d\\n\", @cast(int, FOO)); } Each may iterate over: struct members (returned as string), enums (returned as the enum value) Type group helper macro @foo(int &a) // Macro only valid for a is any type of signed integer macro @foo(integer &a) // Valid for unsigned and signed integers macro @foo(number &a) // Valid for any float or integer Macros may force non local return macro @foo() { exit 1; // other keyword? 'escape'? I think exit is good, // but clashes with function name! } func int test() { @foo(); } // expands to func int test() { return 1; } Normal return creates a statement expression macro @foo(&a) { int x = a; x++; if (x > 0) return 1; return 2; } func int test() { b = 10; int y = @foo(b); } // Expands to: func int test() { b = 10; int __macro_ret_1; do { int __macro_x = b; __macro_x++; if (__macro_x > 0) { __macro_ret_1 = 1; break; } else { __macro_ret_1 = 2; break; } } while (0); int y = __macro_ret_1; } Bodies in macros macro @foo(&a, @body) { int z = 0; while (a < 10) { @body(); z++; } } func void test() { int i = 0; @foo(i) { i += 1; } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { i += 1; __macro_z++; } } } Bodies in macros with parameters macro @foo(&a, @body(&x, $y)) { int z = 0; while (a < 10) { @body(z, 2); z++; } } func void test() { int i = 0; @foo(i) { printf(\"%d / %d\\n\", x, y); } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { printf(\"%d / %d\\n\", __macro_z, 2); __macro_z++; } } } Expression is extended to parse: MACRO_IDENT => lookup $x in current macro scope and replace it with literal. Error if not in macro. MACRO_REPLACEMENT => invoke lexer on code inside, after doing a replace of any # inside. $IF requires that the expression can be evaluated to a constant value, similar holds for the range in $EACH . The general rule: 1. An argument prefixed with $ is always something that must be constant. 2. An argument prefixed with & is always a reference to an outer variable. 3. An argument prefixed with # always matches a string. It will be expanded when lexed in `` statements 4. A $ variable can be converted to a # variable. 5. A # can be evaluated to a $ 6. $ and # cannot be assigned to, they are always constant. 7. $ , & and # will never shadow variables from the outer scope.","title":"Crazy ideas"},{"location":"ideas/#ideas","text":"WARNING Unfinished ideas / brain dumps","title":"Ideas"},{"location":"ideas/#c-interop","text":"Steps: Add group header in the builds: [c-libs] Add the search paths: cpath = [\"/xxx/foo/ \", \"/bar/headers/ \"] Add each library: [[lib]] [c-libs] cpath = [\"/xxx/foo/**\", \"/bar/headers/**\"] [[lib]] module = \"windows\" header = \"windows.h\" [[lib]] module = \"stdlib\" header = \"stdlib.h\"","title":"C interop"},{"location":"ideas/#managed-pointers","text":"Managed pointers are introduced using the pointer @ after the type, e.g. Foo@ f . A manage value will need to implement the member function release and retain . What these functions actually does is up to the implementation. For example, we may have a struct that use these functions to handle a reference count. Managed pointers will then allow automatic reference counting: Foo@ f = Foo.alloc(); Foo@ b = f; // Converted to: f.retain(); b = f; f = nil; // Converted to: f.release(); f = nil; Any managed variable that goes out of the scope will automatically invoke release , as if the pointer was set to nil . { Foo@ b = Foo.alloc(); } // Automatic invocation of b.release(); In order to return a managed pointer that can be used as a temporary, it's often convenient to mark the return value as managed. func Foo@ createFoo() { return Foo.alloc(); } createFoo(); // Implicitly introduces a deferred release. If we assign a managed pointer to a variable, the release/retain is elided // The following becomes f1 = createFoo() - no deferred release or retains. Foo@ f1 = createFoo(); It's possible to manually manage a managed pointer: Foo* f2 = createFoo().retain(); f2.release(); // Required to prevent leaks. A managed pointer may safely assigned to a regular pointer as long as it's not retained outside of the scope. { Foo* f3 = createFoo(); printf(\"%d\", f3.someValue); // Safe, since f3 isn't actually used after the scope. } Foo* unsafeFoo; { unsafeFoo = createFoo(); } // <- access to unsafeFoo at this point will likely break things.","title":"Managed pointers"},{"location":"ideas/#arrays","text":"Developing the Cone proposal a bit:","title":"Arrays"},{"location":"ideas/#fixed-arrays","text":"<type>[<size>] e.g. int[4] . These are treated as values and will be copied if given as parameter. Unlike C, the number is part of its type. Taking a pointer to a fixed array will create a pointer to a fixed array, e.g. int[4]* .","title":"Fixed Arrays"},{"location":"ideas/#fat-array-pointers","text":"<type>[] e.g. int[] . This is a pointer to an array and it is possible to convert any fixed array to a fat array pointer. int[4] a = { 1, 2, 3, 4}; int[] b = a; // Implicit conversion is always ok. int[4] c = @cast(int[4], b); // Will copy the value of b into c. int[4]* d = @cast(int[4]*, b); // Equivalent to d = &a b.len; // Returns 4 int* e = b; // Equivalent to e = &a e = d; // implicit conversion ok. d = e; // ERROR! Not allowed d = @cast(int[4]*, e); // Fine","title":"Fat array pointers"},{"location":"ideas/#conversion-list","text":"int[4] int[] int[4]* int* int[4] assign cast - - int[] assign assign - - int[4]* - - assign cast int* - assign assign assign","title":"Conversion list"},{"location":"ideas/#internals","text":"Internally the layout of a fat array pointer is guaranteed to be struct { <type>* ptrToArray; usize arraySize; } . There is a built in struct __ArrayType_C3 which has the exact data layout of the fat array pointers. It is defined to be struct __ArrayType_C3 { void* ptrToArray; usize arraySize; }","title":"Internals"},{"location":"ideas/#raw-dynamic-safe-arrays-new","text":"Works just like a pointer Not safe to keep reference to if made dynamic. Requires special method to dispose of and to allocate Knows its size.","title":"Raw dynamic, safe arrays - NEW!"},{"location":"ideas/#raw-dynamic-safe-strings-new","text":"Works just like a pointer. Not safe to keep reference if made dynamic Requires special method to dispose of and to allocate Knows its size.","title":"Raw dynamic, safe strings - NEW!"},{"location":"ideas/#dynamic-arrays","text":"Dynamic arrays are provided as a library and they are usually ref counted: import array(int) alias IntArray; IntArray@ a = IntArray.new(); a += 23; // Append last a.pop(); // Remove last a.insert(1, 11); // Insert at position a.insert_front(12); // Insert at 0 a.pop_front(); // Remove first. a.last(); // Return last Thanks to generic overloading this is also possible: a += 23; a[2] = 11; a[2] // Prints 11.","title":"Dynamic arrays"},{"location":"ideas/#unsorted","text":"","title":"Unsorted"},{"location":"ideas/#halloc-new","text":"Hierarchal memory allocation http://swapped.cc/#!/halloc support it?","title":"Halloc - NEW!"},{"location":"ideas/#varargs","text":"Use typed varargs? E.g. void foo(int x, float... foo) where the type of foo becomes float[] Change main to void main(char*[] args) ?","title":"Varargs"},{"location":"ideas/#unsigned-conversion-to-signed","text":"Perhaps consider signed, rather than unsigned implicit conversion. Currently ulong + long becomes ulong + @cast(ulong, long) (according to C rules). Consider changing that to @cast(long, ulong) + long . That is, instead of \"unsigned wins\", use \"signed wins\".","title":"Unsigned conversion to signed"},{"location":"ideas/#aliasing-in-import","text":"It might be useful to express aliasing directly on import. Consider for example a generic library with a Set type. Typically we'd do like this: import set(int) as intset; func void test() { intset.Set* set = intset.Set.new(); /* ... */ } Or import it as a local variable, which is nice, but can only be done for a single set: import set(int) local; func void test() { Set* set = Set.new(); /* ... */ } Adding a direct alias on the set as it is imported would be nice: import set(int) as intset alias Set as IntSet; import set(double) as doubleset alias Set as DoubleSet; func void test() { IntSet* set = IntSet.new(); DoubleSet* set2 = DoubleSet.new(); /* ... */ } Note that the alias is always used without a prefix. If a generic module only has a single generic struct one wishes to use, it's useful to shorten this further at the cost of not being able to access any other symbols (as we cannot use the generic name as a namespace prefix). import set(int) alias Set as IntSet; import set(double) alias Set as DoubleSet; We could go even further, saying that if there is only a single generic struct inside, then we may shorten with the struct being used as a default: import set(int) alias IntSet; import set(double) alias DoubleSet; It's unclear whether this is is helpful or not. Should be discussed further.","title":"Aliasing in import"},{"location":"ideas/#tagged-any","text":"A tagged pointer union type for any possible type.","title":"Tagged any"},{"location":"ideas/#defer-for-error","text":"Introduce an error defer that is only called on error: func void test() throws { defer throw(e) { printf(\"Had an error!\\n\"); } if (rand() == 0) throw Error.TEST; } The code above would be functionally equivalent to: func void test() throws { if (rand() == 0) { printf(\"Had an error!\\n\"); throw Error.TEST; } }","title":"Defer for error"},{"location":"ideas/#cone-style-arrays","text":"Fixed static sized arrays do not automatically decay into pointers (that is int[3] does not decay into int*) Fixed static sized arrays are treated as structs with that many identical items, and will be passed by value Fixed static sized arrays can be converted into fat array pointers int[] would be a fat pointer to an array. Iteration over fat array pointers are defined in the language Taking the reference of a static fixed pointer of size X yields a pointer to that fixed pointer, e.g. int[4]* Automatic conversion from fixed to fat pointer: int[4] y = { 1, 2, 3, 4 }; int[] x = y; Automatic conversion from dynamic array to fat pointer: int[+] y = { 1, 2 }; int[] x = y","title":"Cone style arrays"},{"location":"ideas/#require-explicit-uninitialization","text":"int a = ---; int a = void; // Other possible variant","title":"Require explicit uninitialization"},{"location":"ideas/#extended-case","text":"Switch as \"if-else\" switch (x) { case x > 200: return 0; case x < 2: small_x_warning(); case 0: .... case x > y && a < 1: ... }","title":"Extended \"case\""},{"location":"ideas/#case-as-a-range","text":"switch (x) { case 1 .. 10: ... case 11 .. 100: ... }","title":"Case as a range"},{"location":"ideas/#easy-to-get-properties","text":"Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports","title":"Easy to get properties"},{"location":"ideas/#associate-properties-to-an-enum","text":"enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" }","title":"Associate properties to an enum"},{"location":"ideas/#tagged-unions","text":"tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And yet another... struct Shape { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; }","title":"Tagged unions"},{"location":"ideas/#interfaces","text":"func void Foo.renderPage(Foo& foo, Page& info) { /* ... */ } interface Renderer { void renderPage(Renderer& renderer, Page& info); } func void render(Renderer* renderer, Page& info) { if (rendered == null) return; renderer->renderPage(info); } func void test() { Foo* foo = getFoo(); Page& page = getPage(); // Option 1 Renderer.render(foo, page); // Option 2 Renderer* renderer = foo; renderer.render(page); } // C equivalent: // struct RendererVtable { // void (*renderPage)(void*, Page*); // }; // struct RendererRef { // void* ref; RendererVTable *vtable; // }; // void Renderer__render(struct RendererRef renderer, Page *info) { // if (renderer.ref == null) return; // renderer.vtable->renderPage(renderer.ref, info); // } // // void test() { // Foo *foo = getFoo(); // Page *page = getPage(); // // static RenderVTable FooRendererVTable = { &Foo__renderPage }; // Renderer__render(struct RendererRef { foo, &FooRendererVTable }, page); // // struct RendererRef renderer = { foo, &FooRendererVTable }; // Renderer__render(renderer, page); // } Possible syntax ideas: func void test() { Renderer* renderer1 = getFoo(); // Implicit Renderer* renderer2 = Renderer(getFoo()); Renderer* renderer3 = getFoo() as Renderer; Renderer* renderer4 = @wrap(Renderer, getFoo()); // Macro Renderer renderer5 = getFoo(); // Look, no pointer! Renderer@ renderer6 = getFoo(); // Special pointer type? interface Renderer renderer7 = getFoo(); // Love long lines @Renderer renderer8 = getFoo(); Renderer^ renderer9 = getFoo(); // Pascal Renderer renderer10 = interface getFoo(); Renderer renderer11 = interface(getFoo()); Renderer renderer12 = virtual { getFoo() }; virtual Renderer renderer13 = getFoo(); virtual Renderer renderer14 = getFoo(); } func void render(Renderer renderer, Page& info) { renderer.renderPage(info); } virtual Renderer { void renderPage(Page &info); } func void render(virtual Renderer& renderer, Page& info) { renderer.renderPage(info); } func void render(virtual Renderer& renderer, Page& info) { renderer->renderPage(info); } func void render(interface Renderer& renderer, Page& info) { renderer->renderPage(info); } interface Renderer*[4] renderers; interface Renderer[4] renderers; virtual Renderer[4] renderers; Renderer*[4] renderers;","title":"Interfaces"},{"location":"ideas/#built-in-maps","text":"Same reasoing as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = try map[0]; // Requires a try // Retrive or use default int i = try map[12] else -1; // Extend a map: func bool int[int].remove_if_negative(int[int] &map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int &map, int32_t index);","title":"Built in maps"},{"location":"ideas/#built-in-string-type","text":"Strings are built-in, refcounted(?) null-terminated character arrays. Take a long hard look at memory management (here too) string = \"Hello\"; string += \" World\"; char* data = &string; // Taking a pointer to the string, which may later be invalid.","title":"Built in string type"},{"location":"ideas/#built-in-managed-pointers","text":"Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check.","title":"Built in managed pointers"},{"location":"ideas/#ideas-around-macros","text":"Just some previous thoughts and ideas I've considered. Many of those actually go against the current design.","title":"Ideas around macros"},{"location":"ideas/#compile-time-variables","text":"This is a variant of what already exists in C, but in a syntactically more friendly way. For example this would be ok: macro swap(a, b) { $x = typeof(a); static_assert(typeof(b) == $x); $x temp = a; a = b; b = a; } The example above is a bit contrived as in the above example we could simply have: macro swap(a, b) { static_assert(typeof(b) == typeof(b)); typeof(a) temp = a; a = b; b = a; } But still, it serves as an example on how to use it.","title":"Compile time variables"},{"location":"ideas/#capturing-trailing-compound-statement","text":"public macro foreach(thelist, @body(Element *) ) { Element* iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Or a version that is more flexible: public macro foreach(thelist, @body(typeof(thelist.first)) ) { typeof(thelist.first) iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } // Usage: foreach(list, Element *i) // <- Note type declaration! { i.print(); } Since type is going to appear very often, we could make a shortcut for it, like $@ as prefix meaning \"typeof\". We then get public macro foreach(thelist, @body($@thelist.first)) { $@thelist.first iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } Possibly one could even write the code like this: public macro foreach(thelist, @body($element_type) ) { $element_type iname = thelist.first; while (iname != nil) { @body(iname); iname = iname.next; } } In this case $element_type works like \"auto\", but is also assigned the type, which then can be referred to in the signature.","title":"Capturing trailing compound statement"},{"location":"ideas/#yet-another-way-to-do-macros-d","text":"This was an older attempt... First, we have to consider macros as always expanding where they are referenced to keep it simple. macro @foo(int v) { v++; if (v > 10) return 10; return v; } func void test() { int a = 10; @foo(a); } This code would then be exactly equal to: func void test() { int a = 10; a++; if (a > 10) return 10; } Macros simply expand in place. Secondly, we can have macros returning values: macro int @foo2(int v, int w) { v++; if (v > 10) return 10; w += 3; return 0; } func void test() { int d = 0; int a = 10; int b = @foo(a, d); } This expands to: func void test() { int d = 0; int a = 10; a++ int b; if (a > 10) { b = 10; } else { b = 0; d += 3; } } Note that I'm using a sigil to indicate the code expansion to make macros more obvious. We can allow the macro to take a body (here I'm calling the type of the body \"{}\") macro int @foo3(int a, {} body) { while (a > 10) { a--; @body(); // Like a macro! } } func void test() { b = 20; @foo3(b) { print(b); } } We expand this to: func void test() { b = 20; while (b > 10) { b--; print(b); } }","title":"Yet another way to do macros :D"},{"location":"ideas/#stepwise-from-c-macros-into-c3-macros","text":"#define ADD_TO(x, y) { x += y; } ADD_TO(x, 1) The { } introduces a multiline macro that does not need explicit linebreaks. No, add the \"$\" symbol to introduce hygienic temporaries: #define SWAP(x, y) { typeof(x) $tmp = x; x = y; y = $tmp; } Here $tmp will actually be replaced by __<macro>_<variable_name>_<instance> when translating to C, so __SWAP_tmp_1 , __SWAP_tmp_2 etc. We then introduce the syntax macros using: macro swap(&a, &b) { typeof(a) $tmp = a; b = a; a = $tmp; } (Note the different use of $ here as compared to previous macro ideas where $ is a compile time evaluated variable!) The use of &a follows C++ standard: it simply refers to a variable OR EXPRESSION that is imported into its scope. Using the unadorned variable name as evaluated expression allows us to write this code: macro max(a, b) { return (a > b ? a : b) } The above code is equivalent to: macro max(&a, &b) { typeof(a) $tmp_a = a; typeof(b) $tmp_b = b; $tmp_a > $tmp_b ? $tmp_a : $tmp_b } Or in (GNU) C: #define max(a,b) \\ ({ __typeof__ (a) _a = (a); \\ __typeof__ (b) _b = (b); \\ _a > _b ? _a : _b; }) To recap: Add the { } format to #define for multiline defines. Add $<name> format as hygienic variable names. Add the syntax \"macro\" type of definition. The syntax macro makes a difference between \"normal\" parameters (with & as prefix) and \"evaluated\" parameters (unadorned variables) Important is also to scope the macros: #define is always defined local to a scope (unlike in C). This means that #define FOO printf(\"foo\"); { #define BAR printf(\"bar\"); } FOO // adds printf(\"foo\"); BAR; // Error, define not available in scope; This also means that a define can be declared public to be accessed as if defined from the top of the file scope: // file 1 module foo public #define FOO { printf(\"FOO!\\n\"); } // file 2 import foo func void test() { foo.FOO } Only defines in the file scope that exists in the file scope may be public and used in other modules.","title":"Stepwise from C macros into C3 macros"},{"location":"ideas/#yet-another-macro-proposal-i-found","text":"Simple macros macro @foo(&b) { b++; } func test() { int x = 1; @foo(x); } // Same as: func void test() { int x = 1; x++; } Macro with compile time values: macro @foo($x, &b) { b += $x; } func void test() { int x = 1; @foo(10, x); } // Expands to: func void test() { int x = 1; x += 10; } Macro with string capture macro @foo($x, #f) { `#f $x * $x`; } func void test() { i32 x = 1; @foo(4, \"x += \"); } // Expands to func void test() { i32 x = 1; x += 4 * 4; } macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { i32 x = 1; @foo2(\"x\"); } // Expands to funct void test2() { i32 x = 1; printf(\"%s was %d\\n\", \"x\", x); } Macro with conditional compile time values macro @foo($x, &b) { $IF ($x > 3) { b += $x * $x; } $ELSE { b += $x; } } func void test() { i32 x = 1; @foo(10, x); @foo(2, x); } // Expands to func void test() { i32 x = 1; x += 100; x += 2; } Nested macros (don't do this, but an example) macro @foo($a) { printf(\"%d\\n\", $a); $IF($a > 0) { @foo($a - 1); } } func void test() { @foo(2); } // Expands to func void test() { printf(\"%d\\n\", 2); printf(\"%d\\n\", 1); printf(\"%d\\n\", 0); } The above suggests macro sugar of loops: macro @foo($a) { $EACH(0..$a AS $x) { printf(\"%d\\n\", $x); } } macro @foo_enum(&a) { $EACH(a AS $x) { printf(\"%d\\n\", @cast(int, $x)); } } enum MyEnum { A, B, FOO } func void test() { @foo_enum(MyEnum); } // Expands to func void test() { printf(\"%d\\n\", @cast(int, A)); printf(\"%d\\n\", @cast(int, B)); printf(\"%d\\n\", @cast(int, FOO)); } Each may iterate over: struct members (returned as string), enums (returned as the enum value) Type group helper macro @foo(int &a) // Macro only valid for a is any type of signed integer macro @foo(integer &a) // Valid for unsigned and signed integers macro @foo(number &a) // Valid for any float or integer Macros may force non local return macro @foo() { exit 1; // other keyword? 'escape'? I think exit is good, // but clashes with function name! } func int test() { @foo(); } // expands to func int test() { return 1; } Normal return creates a statement expression macro @foo(&a) { int x = a; x++; if (x > 0) return 1; return 2; } func int test() { b = 10; int y = @foo(b); } // Expands to: func int test() { b = 10; int __macro_ret_1; do { int __macro_x = b; __macro_x++; if (__macro_x > 0) { __macro_ret_1 = 1; break; } else { __macro_ret_1 = 2; break; } } while (0); int y = __macro_ret_1; } Bodies in macros macro @foo(&a, @body) { int z = 0; while (a < 10) { @body(); z++; } } func void test() { int i = 0; @foo(i) { i += 1; } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { i += 1; __macro_z++; } } } Bodies in macros with parameters macro @foo(&a, @body(&x, $y)) { int z = 0; while (a < 10) { @body(z, 2); z++; } } func void test() { int i = 0; @foo(i) { printf(\"%d / %d\\n\", x, y); } } // Expands to func void test() { int i = 0; { int __macro_z = 0; while (i < 10) { printf(\"%d / %d\\n\", __macro_z, 2); __macro_z++; } } } Expression is extended to parse: MACRO_IDENT => lookup $x in current macro scope and replace it with literal. Error if not in macro. MACRO_REPLACEMENT => invoke lexer on code inside, after doing a replace of any # inside. $IF requires that the expression can be evaluated to a constant value, similar holds for the range in $EACH . The general rule: 1. An argument prefixed with $ is always something that must be constant. 2. An argument prefixed with & is always a reference to an outer variable. 3. An argument prefixed with # always matches a string. It will be expanded when lexed in `` statements 4. A $ variable can be converted to a # variable. 5. A # can be evaluated to a $ 6. $ and # cannot be assigned to, they are always constant. 7. $ , & and # will never shadow variables from the outer scope.","title":"Yet another macro proposal I found"},{"location":"library/","text":"Library Ref counting Any struct can enable ref counting by including the RefCount struct: import refcount local; struct Person { RefCount rc inline; char[] name; } func void test() { Person* person = malloc(sizeof(Person)); person.initRC(&free); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.retain(); printf(\"RC = %d\\n\", person.refCount); // Prints 2 person.release(); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.release(); // Will call free(person) // More briefly, use @rcmalloc Person@ person2 = @rcmalloc(Person); // Above will call malloc & free and return a managed pointer }","title":"Library"},{"location":"library/#library","text":"","title":"Library"},{"location":"library/#ref-counting","text":"Any struct can enable ref counting by including the RefCount struct: import refcount local; struct Person { RefCount rc inline; char[] name; } func void test() { Person* person = malloc(sizeof(Person)); person.initRC(&free); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.retain(); printf(\"RC = %d\\n\", person.refCount); // Prints 2 person.release(); printf(\"RC = %d\\n\", person.refCount); // Prints 1 person.release(); // Will call free(person) // More briefly, use @rcmalloc Person@ person2 = @rcmalloc(Person); // Above will call malloc & free and return a managed pointer }","title":"Ref counting"},{"location":"macros/","text":"Macros !!!THIS IS JUST AN EXPERIMENTAL DRAFT!!! Macros is a form of compile time evaluation. There are compile time variables (prefixed with $ ) and compile time template code (macros). Compile time evaluation The C3 compiler always does a first pass through the code reading all definitions and resolving compile time variables. Compile time variables with the $ prefix are resolved in order . Macro declarations A macro is defined using macro @<name>(<parameters>) . All user defined macros use the @ symbol. The parameters have different sigils: $ means compile time evaluated (captured variable, symbol or expression). # means full string capture. Any parameters without sigils are passed by value , as if it was a normal function parameter. A basic swap: /** * @ensure parse($a = $b), parse($b = $a) */ macro @swap($a, $b) { typeof($a) temp = $a; $a = $b; $b = temp; } This expands on usage like this: func void test() { int a = 10; int b = 20; @swap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __temp = a; a = b; b = __temp; } } Note the necessary $ . Here is an incorrect swap and what it would expand to: macro @badswap(a, b) { typeof(a) temp = a; a = b; b = temp; } func void test() { int a = 10; int b = 20; @badswap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __a = a; int __b = b; int __temp = __a; __a = __b; __b = __temp; } } Capturing a macro body We may add a trailing parameter in the format: : @<param name>(arg1, arg2, ...) it then captures any trailing compound statement. /** * @ensure parse(int i = a.len), parse(value1 = a[i]) * @ensure parse(value2 = 2 * value1) */ macro @foreach(a : @body(value1, value2) ) { for (int i = 0; i < a.len; i++) { @body(a[i], a[i] * 2); } } func void test() { int[] a = { 1, 2, 3 }; @foreach(a : int value, int mult) { printf(\"Value: %d, x2: %d\\n\", value, mult); } } // Expands to code similar to: func void test() { int[] a = { 1, 2, 3 }; { int[] __a = a; for (int __i = 0; i < __a.len; i++) { typeof(__a[__i]) __value1 = __a[__i]; typeof(__a[__i] * 2) __value2 = __a[__i] * 2; printf(\"Value: %d, x2: %d\\n\", __value1, __value2); } } } Macros returning values A macro may return a value, it is then considered an expression rather than a statement: macro square(x) { return x * x; } int getTheSquare(int x) { return square(x); } double getTheSquare2(double x) { return square(x); } Calling macros It's perfectly fine for a macro to invoke another macro or itself. macro @square(x) { return x * x } macro @squarePlusOne(x) { return @square(x) + 1; // Expands to \"return x * x + 1;\" } Obviously this can cause infinite recursion, so the actual recursion depth is limited to what the build setting macro-recursion-depth is set to. Macro directives Inside of a macro, we can use the compile time statements $if , $else \u201a $each and $switch . Macros may also be recursively invoked. $if, $else and $elif $if (<const expr>) takes a compile time constant value and evaluates it to true or false. macro @foo($X, $y) { $if ($x > 3) { $y += $x * $x; } $else { $y += $x; } } const int FOO = 10; func void test() { int a = 5; int b = 4; @foo(1, a); // Allowed, expands to a += 1; // @foo(b, a); // Error: b is not a compile time constant. @foo(FOO, a); // Allowed, expands to a += FOO * FOO; } There is an alternative form of $if / $else / $elif using : and terminated with $endif . These have by convention no indentation. This is mostly useful for top level use where indentation might not be desired. macro @foo($X, $y) { $if ($x > 3): $y += $x * $x; $elif ($x < 100): $y += -$x; $else: $y += $x; $endif; } Loops using $each $each (<range> as <variable>) { ... } allows compile time recursion. $each may recurse over enums, struct fields or constant ranges. Everything must be known at compile time. Looping over ranges: macro @foo($A) { $each (0..$A as $x) { printf(\"%d\\n\", $x); } } func void test() { @foo(2); // Expands to -> // printf(\"%d\\n\", 0); // printf(\"%d\\n\", 1); } Looping over enums: macro @foo_enum($THE_ENUM) { $each($THE_ENUM AS $x) { printf(\"%d\\n\", @cast(int, $x)); } } enum MyEnum { A, B, } func void test() { @foo_enum(MyEnum); // Expands to -> // printf(\"%d\\n\", @cast(int, MyEnum.A)); // printf(\"%d\\n\", @cast(int, MyEnum.B)); } An important thing to note is that the content of the $each body must be a complete statement. It's not possible to compile partial statements. Switching on type with $switch It's possible to switch on type, similar to generic functions, but used internal to the macro: macro foo(a, b) { $switch(a, b) { $case int, int: return a * b; } return a + b; } Macro text interpolation For certain cases, pure text interpolation might be needed. The sigil # is used to indicate a stringified capture. Within a macro, any text within `` is evaluated as text. macro @foo($x, #f) { `#f $x * $x`; } func void test() { int x = 1; @foo(4, x += ); // Expands to -> // x += 4 * 4; } Another example, showing the difference between #var and `#var` : macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { int x = 1; @foo2(x); // Expands to -> // printf(\"%s was %d\\n\", \"x\", x); } Compile time string functions In order to facilitate certain types of macros, the following macros are built in: @strToUpper(#f) Convert string to upper case. @strToLower(#f) Convert string to lower case. @strToVarName(#f, #space) Convert string to camel case from a space-based name scheme. @strToTypeName(#f, #space) Convert string to title case from a space-based name scheme. @strFromName(#f, #space) Convert title case or lower camel case to a space based scheme. @strReplace(#str, #pattern, #replacement, #count) Replace a string with another. @subString(#str, #start, #length) Return a substring of a compile time string. @strFind(#str, #stringToFind) Find a substring in a compile time string. @strHash(#str) Return the FNV1a hash of a string. @strLen(#str) Return a compile time length of a string. @stringify(#str) Escapes a string so it becomes a valid string. Escape macros A usual macro will generate its own scope, so that break, return, continue and goto only stays valid inside of its own \"scope\". A return from inside a macro does not normally escape the scope into which it's called: macro @foo() { return; } func void test() { @foo(); // Doesn't do anything. printf(\"Test\\n\"); } However, there is a way to make a macro break out of the outer scope, and that is to add a ! to the macro name. Such a macro may escape its boundaries. macro @foo!() { return; } func void test() { @foo!(); // The function returns here. printf(\"Test\\n\"); // Never printed! } This is not limited to return: break , continue and even goto is allowed. macro @goto!($f) { goto $f; } func void test() { @goto!(test) printf(\"Foo!\\n\") return; test: printf(\"Bar!\\n\") } The above code will print \"Bar!\" Conditional macros at the top level A limitation with the macros is that they are only used within functions. This is deliberate \u2013 macros expanding at the top level are much harder to reason about since they should be able to define new types or change the meaning of the code that follows. Still, the usefulness of top level macros is great, which is why C3 offers four pieces of functionality for the top level: conditional compilation, global compile time varibles, decorators and incremental arrays. Conditional compilation Conditional compilation is done with $if and $else, which works just like inside of functions. $if (@defined($os) && $os == 'WIN32') func void doSomethingWin32Specific() { /* .... */ } $endif Global compile time variables Variables on the top level work like compile time variables in macros \u2013 with the exception that they must always be declared constant. They are always evaluated in order, which has to be taken into account when used in conjunction with @defined. Consider this code: macro @foo() { $if (@defined($a)) return $a + 1; return 1; } const $z = @foo(); // $z = 1 const $a = @foo(); // $a = 1 const $b = @foo(); // $b = 2 Decorators Decorators are attributes placed on functions, types and variables. They may take a type as argument, much like a function. It's possible iterate over all decorated symbols of a particular type. decorator func @myvar(int i = 0); decorator struct, union, enum @foo; func void test() @myvar(2) { /** ... */ } struct Test @foo { int i; } What's useful about decorators is that they can be accessed during compile time: macro @fooCheck($a) { $if (@defined($a.@foo)) { return \"Was fooed\"; } return \"Ok\"; } struct TestA { int i; } struct TestB @Foo { float f; } func void test() { printf(\"Check TestA: \" @fooCheck(TestA) \"\\n\"); printf(\"Check TestB: \" @fooCheck(TestB) \"\\n\"); // Prints: // Check TestA: Ok // Check TestB: Was fooed } It's also possible to get hold of the values: decorator func @myvar(int i = 0); func void test() @myvar(200) { ... } func void test() { printf(\"%d\", test.@myvar.i); // Prints 200 } Incremental arrays Incremental arrays allows compile time arrays to be constructed piecemeal within a single source file. An incremental array uses the [+] ending, but will be considered to be a fixed size array for all other purposes. Append to an incremental array using += which done during compile time. int[+] a = { 1 }; a += 1; /* ... other code .. */ a += 2; // Equivalent to the declaration int[3] a = { 1, 1, 2 }; This can be especially useful in conjuction with $each : enum MyEnum { A, B } macro @foo_enum($theEnum) { string[+] arr = {}; $each($theEnum AS $x) { arr += @name($x); } } // allMyEnum will contain { \"A\", \"B\" } const string[] allMyEnum = @foo_enum(MyEnum); Here is a similar example but for decorators: decorator struct @special; struct TestA @special { int i; } struct TestB { float f; } struct TestC @special { float f; } macro @specialStructs() { string[+] res = {}; $each(@special as $x) { res += @name($x); } // The above expands to: // res += \"TestA\"; // res += \"TestC\"; return res; } // SPECIAL_STRUCTS = { \"TestA\", \"TestB\" } const string[] SPECIAL_STRUCTS = @specialStructs();","title":"Macros"},{"location":"macros/#macros","text":"!!!THIS IS JUST AN EXPERIMENTAL DRAFT!!! Macros is a form of compile time evaluation. There are compile time variables (prefixed with $ ) and compile time template code (macros).","title":"Macros"},{"location":"macros/#compile-time-evaluation","text":"The C3 compiler always does a first pass through the code reading all definitions and resolving compile time variables. Compile time variables with the $ prefix are resolved in order .","title":"Compile time evaluation"},{"location":"macros/#macro-declarations","text":"A macro is defined using macro @<name>(<parameters>) . All user defined macros use the @ symbol. The parameters have different sigils: $ means compile time evaluated (captured variable, symbol or expression). # means full string capture. Any parameters without sigils are passed by value , as if it was a normal function parameter. A basic swap: /** * @ensure parse($a = $b), parse($b = $a) */ macro @swap($a, $b) { typeof($a) temp = $a; $a = $b; $b = temp; } This expands on usage like this: func void test() { int a = 10; int b = 20; @swap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __temp = a; a = b; b = __temp; } } Note the necessary $ . Here is an incorrect swap and what it would expand to: macro @badswap(a, b) { typeof(a) temp = a; a = b; b = temp; } func void test() { int a = 10; int b = 20; @badswap(a, b); } // Equivalent to: func void test() { int a = 10; int b = 20; { int __a = a; int __b = b; int __temp = __a; __a = __b; __b = __temp; } }","title":"Macro declarations"},{"location":"macros/#capturing-a-macro-body","text":"We may add a trailing parameter in the format: : @<param name>(arg1, arg2, ...) it then captures any trailing compound statement. /** * @ensure parse(int i = a.len), parse(value1 = a[i]) * @ensure parse(value2 = 2 * value1) */ macro @foreach(a : @body(value1, value2) ) { for (int i = 0; i < a.len; i++) { @body(a[i], a[i] * 2); } } func void test() { int[] a = { 1, 2, 3 }; @foreach(a : int value, int mult) { printf(\"Value: %d, x2: %d\\n\", value, mult); } } // Expands to code similar to: func void test() { int[] a = { 1, 2, 3 }; { int[] __a = a; for (int __i = 0; i < __a.len; i++) { typeof(__a[__i]) __value1 = __a[__i]; typeof(__a[__i] * 2) __value2 = __a[__i] * 2; printf(\"Value: %d, x2: %d\\n\", __value1, __value2); } } }","title":"Capturing a macro body"},{"location":"macros/#macros-returning-values","text":"A macro may return a value, it is then considered an expression rather than a statement: macro square(x) { return x * x; } int getTheSquare(int x) { return square(x); } double getTheSquare2(double x) { return square(x); }","title":"Macros returning values"},{"location":"macros/#calling-macros","text":"It's perfectly fine for a macro to invoke another macro or itself. macro @square(x) { return x * x } macro @squarePlusOne(x) { return @square(x) + 1; // Expands to \"return x * x + 1;\" } Obviously this can cause infinite recursion, so the actual recursion depth is limited to what the build setting macro-recursion-depth is set to.","title":"Calling macros"},{"location":"macros/#macro-directives","text":"Inside of a macro, we can use the compile time statements $if , $else \u201a $each and $switch . Macros may also be recursively invoked.","title":"Macro directives"},{"location":"macros/#if-else-and-elif","text":"$if (<const expr>) takes a compile time constant value and evaluates it to true or false. macro @foo($X, $y) { $if ($x > 3) { $y += $x * $x; } $else { $y += $x; } } const int FOO = 10; func void test() { int a = 5; int b = 4; @foo(1, a); // Allowed, expands to a += 1; // @foo(b, a); // Error: b is not a compile time constant. @foo(FOO, a); // Allowed, expands to a += FOO * FOO; } There is an alternative form of $if / $else / $elif using : and terminated with $endif . These have by convention no indentation. This is mostly useful for top level use where indentation might not be desired. macro @foo($X, $y) { $if ($x > 3): $y += $x * $x; $elif ($x < 100): $y += -$x; $else: $y += $x; $endif; }","title":"$if, $else and $elif"},{"location":"macros/#loops-using-each","text":"$each (<range> as <variable>) { ... } allows compile time recursion. $each may recurse over enums, struct fields or constant ranges. Everything must be known at compile time. Looping over ranges: macro @foo($A) { $each (0..$A as $x) { printf(\"%d\\n\", $x); } } func void test() { @foo(2); // Expands to -> // printf(\"%d\\n\", 0); // printf(\"%d\\n\", 1); } Looping over enums: macro @foo_enum($THE_ENUM) { $each($THE_ENUM AS $x) { printf(\"%d\\n\", @cast(int, $x)); } } enum MyEnum { A, B, } func void test() { @foo_enum(MyEnum); // Expands to -> // printf(\"%d\\n\", @cast(int, MyEnum.A)); // printf(\"%d\\n\", @cast(int, MyEnum.B)); } An important thing to note is that the content of the $each body must be a complete statement. It's not possible to compile partial statements.","title":"Loops using $each"},{"location":"macros/#switching-on-type-with-switch","text":"It's possible to switch on type, similar to generic functions, but used internal to the macro: macro foo(a, b) { $switch(a, b) { $case int, int: return a * b; } return a + b; }","title":"Switching on type with $switch"},{"location":"macros/#macro-text-interpolation","text":"For certain cases, pure text interpolation might be needed. The sigil # is used to indicate a stringified capture. Within a macro, any text within `` is evaluated as text. macro @foo($x, #f) { `#f $x * $x`; } func void test() { int x = 1; @foo(4, x += ); // Expands to -> // x += 4 * 4; } Another example, showing the difference between #var and `#var` : macro @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { int x = 1; @foo2(x); // Expands to -> // printf(\"%s was %d\\n\", \"x\", x); }","title":"Macro text interpolation"},{"location":"macros/#compile-time-string-functions","text":"In order to facilitate certain types of macros, the following macros are built in: @strToUpper(#f) Convert string to upper case. @strToLower(#f) Convert string to lower case. @strToVarName(#f, #space) Convert string to camel case from a space-based name scheme. @strToTypeName(#f, #space) Convert string to title case from a space-based name scheme. @strFromName(#f, #space) Convert title case or lower camel case to a space based scheme. @strReplace(#str, #pattern, #replacement, #count) Replace a string with another. @subString(#str, #start, #length) Return a substring of a compile time string. @strFind(#str, #stringToFind) Find a substring in a compile time string. @strHash(#str) Return the FNV1a hash of a string. @strLen(#str) Return a compile time length of a string. @stringify(#str) Escapes a string so it becomes a valid string.","title":"Compile time string functions"},{"location":"macros/#escape-macros","text":"A usual macro will generate its own scope, so that break, return, continue and goto only stays valid inside of its own \"scope\". A return from inside a macro does not normally escape the scope into which it's called: macro @foo() { return; } func void test() { @foo(); // Doesn't do anything. printf(\"Test\\n\"); } However, there is a way to make a macro break out of the outer scope, and that is to add a ! to the macro name. Such a macro may escape its boundaries. macro @foo!() { return; } func void test() { @foo!(); // The function returns here. printf(\"Test\\n\"); // Never printed! } This is not limited to return: break , continue and even goto is allowed. macro @goto!($f) { goto $f; } func void test() { @goto!(test) printf(\"Foo!\\n\") return; test: printf(\"Bar!\\n\") } The above code will print \"Bar!\"","title":"Escape macros"},{"location":"macros/#conditional-macros-at-the-top-level","text":"A limitation with the macros is that they are only used within functions. This is deliberate \u2013 macros expanding at the top level are much harder to reason about since they should be able to define new types or change the meaning of the code that follows. Still, the usefulness of top level macros is great, which is why C3 offers four pieces of functionality for the top level: conditional compilation, global compile time varibles, decorators and incremental arrays.","title":"Conditional macros at the top level"},{"location":"macros/#conditional-compilation","text":"Conditional compilation is done with $if and $else, which works just like inside of functions. $if (@defined($os) && $os == 'WIN32') func void doSomethingWin32Specific() { /* .... */ } $endif","title":"Conditional compilation"},{"location":"macros/#global-compile-time-variables","text":"Variables on the top level work like compile time variables in macros \u2013 with the exception that they must always be declared constant. They are always evaluated in order, which has to be taken into account when used in conjunction with @defined. Consider this code: macro @foo() { $if (@defined($a)) return $a + 1; return 1; } const $z = @foo(); // $z = 1 const $a = @foo(); // $a = 1 const $b = @foo(); // $b = 2","title":"Global compile time variables"},{"location":"macros/#decorators","text":"Decorators are attributes placed on functions, types and variables. They may take a type as argument, much like a function. It's possible iterate over all decorated symbols of a particular type. decorator func @myvar(int i = 0); decorator struct, union, enum @foo; func void test() @myvar(2) { /** ... */ } struct Test @foo { int i; } What's useful about decorators is that they can be accessed during compile time: macro @fooCheck($a) { $if (@defined($a.@foo)) { return \"Was fooed\"; } return \"Ok\"; } struct TestA { int i; } struct TestB @Foo { float f; } func void test() { printf(\"Check TestA: \" @fooCheck(TestA) \"\\n\"); printf(\"Check TestB: \" @fooCheck(TestB) \"\\n\"); // Prints: // Check TestA: Ok // Check TestB: Was fooed } It's also possible to get hold of the values: decorator func @myvar(int i = 0); func void test() @myvar(200) { ... } func void test() { printf(\"%d\", test.@myvar.i); // Prints 200 }","title":"Decorators"},{"location":"macros/#incremental-arrays","text":"Incremental arrays allows compile time arrays to be constructed piecemeal within a single source file. An incremental array uses the [+] ending, but will be considered to be a fixed size array for all other purposes. Append to an incremental array using += which done during compile time. int[+] a = { 1 }; a += 1; /* ... other code .. */ a += 2; // Equivalent to the declaration int[3] a = { 1, 1, 2 }; This can be especially useful in conjuction with $each : enum MyEnum { A, B } macro @foo_enum($theEnum) { string[+] arr = {}; $each($theEnum AS $x) { arr += @name($x); } } // allMyEnum will contain { \"A\", \"B\" } const string[] allMyEnum = @foo_enum(MyEnum); Here is a similar example but for decorators: decorator struct @special; struct TestA @special { int i; } struct TestB { float f; } struct TestC @special { float f; } macro @specialStructs() { string[+] res = {}; $each(@special as $x) { res += @name($x); } // The above expands to: // res += \"TestA\"; // res += \"TestC\"; return res; } // SPECIAL_STRUCTS = { \"TestA\", \"TestB\" } const string[] SPECIAL_STRUCTS = @specialStructs();","title":"Incremental arrays"},{"location":"modules/","text":"Modules C3 groups functions, types, variables and macros into namespaces called modules. When doing builds, any C3 file must start with the module keyword, specifying the module. When compiling single files, the module is not needed and the module name is assumed to be the file name, converted to lower case, with any invalid characters replaced by underscore ( _ ). A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module baz; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar . Details Some details about the C3 module system: Modules are not nested, there only a single level to the name. Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters. Importing modules Importing a module uses the import keyword. Imports have file scope, so consequently if file_a.c3 imports the module networking , then file_b.c3 cannot use those symbols unless it also imports networking . file_a.c3 module foo; //import bar and stdio import bar; import stdio; /* ... */ file_b.c3 module foo; //import bar and networking imported, but not storage import bar; import networking; /* ... */ Named imports It is often convenient to alias the module name (affecting the current file only) to a shorter alias. module foo; import extended_filesystems_io as fs; The code in the file can now use the fs instead of the longer name. However, both names remain valid in the file scope. Local imports In many cases prefixes can become cumbersome. It is therefore also possible to use the local keyword to avoid the prefix completely. import networking as net local; import filesystem local; // Equivalent filesystem.doSomething(); doSomething(); // Equivalent net.connect(); networking.connect(); connect(); In the case where a symbol would be ambiguous, for example if both networking and filesystem would have an open() function, then the prefix is still mandatory. Visibility All files in the same module share the same global declaration namespace. However, by default a function is not visible outside the module. To make the symbol visible outside the module, use the keyword public . module foo; public func void init() { .. } func void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it isn't specified as public. Textual includes It's sometimes useful to include an entire file, doing so employs the @include macro. File Foo.c3 module foo; @include(\"Foo.x\"); func void test() { printf(\"%d\", testX(2)); } File Foo.x public func testX(int i) { return i + 1; } The result is as if Foo.c3 contained the following: module foo; public func testX(int i) { return i + 1; } func void test() { printf(\"%d\", testX(2)); } The include may use an absolute or relative path, the relative path is always relative to the source file in which the include appears.","title":"Modules"},{"location":"modules/#modules","text":"C3 groups functions, types, variables and macros into namespaces called modules. When doing builds, any C3 file must start with the module keyword, specifying the module. When compiling single files, the module is not needed and the module name is assumed to be the file name, converted to lower case, with any invalid characters replaced by underscore ( _ ). A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module baz; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar .","title":"Modules"},{"location":"modules/#details","text":"Some details about the C3 module system: Modules are not nested, there only a single level to the name. Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters.","title":"Details"},{"location":"modules/#importing-modules","text":"Importing a module uses the import keyword. Imports have file scope, so consequently if file_a.c3 imports the module networking , then file_b.c3 cannot use those symbols unless it also imports networking . file_a.c3 module foo; //import bar and stdio import bar; import stdio; /* ... */ file_b.c3 module foo; //import bar and networking imported, but not storage import bar; import networking; /* ... */","title":"Importing modules"},{"location":"modules/#named-imports","text":"It is often convenient to alias the module name (affecting the current file only) to a shorter alias. module foo; import extended_filesystems_io as fs; The code in the file can now use the fs instead of the longer name. However, both names remain valid in the file scope.","title":"Named imports"},{"location":"modules/#local-imports","text":"In many cases prefixes can become cumbersome. It is therefore also possible to use the local keyword to avoid the prefix completely. import networking as net local; import filesystem local; // Equivalent filesystem.doSomething(); doSomething(); // Equivalent net.connect(); networking.connect(); connect(); In the case where a symbol would be ambiguous, for example if both networking and filesystem would have an open() function, then the prefix is still mandatory.","title":"Local imports"},{"location":"modules/#visibility","text":"All files in the same module share the same global declaration namespace. However, by default a function is not visible outside the module. To make the symbol visible outside the module, use the keyword public . module foo; public func void init() { .. } func void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it isn't specified as public.","title":"Visibility"},{"location":"modules/#textual-includes","text":"It's sometimes useful to include an entire file, doing so employs the @include macro. File Foo.c3 module foo; @include(\"Foo.x\"); func void test() { printf(\"%d\", testX(2)); } File Foo.x public func testX(int i) { return i + 1; } The result is as if Foo.c3 contained the following: module foo; public func testX(int i) { return i + 1; } func void test() { printf(\"%d\", testX(2)); } The include may use an absolute or relative path, the relative path is always relative to the source file in which the include appears.","title":"Textual includes"},{"location":"moreexamples/","text":"More Examples Hello World import stdio as io; func void main() { printf(\"Hello world!\\n\"); } Fibonacci recursive func long fib(long n) { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); } HTTP Server import http_server local; import net local; func void httpHandler(HttpContext& context) throws HTTPError { context.response.contentType = \"text/plain\"; context.response.printf(\"Hello world!\\n\"); } func void main() { HttpServer server; server.init(); InetAddress addr = try server.bindPort(8080); printf(\"Begin listening to on http://%s\\n\", addr.description()); server.listen(&httpHandler); catch (HTTPError e) { printf(\"Failed to open server.\\n\"); exit(-1); } }","title":"More Examples"},{"location":"moreexamples/#more-examples","text":"","title":"More Examples"},{"location":"moreexamples/#hello-world","text":"import stdio as io; func void main() { printf(\"Hello world!\\n\"); }","title":"Hello World"},{"location":"moreexamples/#fibonacci-recursive","text":"func long fib(long n) { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); }","title":"Fibonacci recursive"},{"location":"moreexamples/#http-server","text":"import http_server local; import net local; func void httpHandler(HttpContext& context) throws HTTPError { context.response.contentType = \"text/plain\"; context.response.printf(\"Hello world!\\n\"); } func void main() { HttpServer server; server.init(); InetAddress addr = try server.bindPort(8080); printf(\"Begin listening to on http://%s\\n\", addr.description()); server.listen(&httpHandler); catch (HTTPError e) { printf(\"Failed to open server.\\n\"); exit(-1); } }","title":"HTTP Server"},{"location":"naming/","text":"Naming rules C3 introduces fairly strict naming rules to reduce ambiguity. As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character. Structs, unions, enums and errors All user defined types must start with A-Z after any optional initial _ and include at least 1 lower case letter. Bar , _T_i12 and TTi are all valid names. _1 , bAR and BAR are not. For C-compatibility it's possible to alias the type to a C name using the attribute \"cname\". struct Foo @(cname = \"foo\") { int x; Bar bar; } union Bar { int i; double d; } enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS } Variables and parameters All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not. int theGlobal = 1; func void foo(int x) { Foo foo = getFoo(x); theGlobal++; } Global constants Global constants must start with A-Z after any optional initial _ . _FOO2 , BAR_FOO , X are all valid global constants, _ , _bar , x are not. const int A_VALUE = 12; Enum / error values Enum and error values follow the same naming standard as global constants. enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS } Struct / union members Struct and union members follow the same naming rules as variables. Modules Module names may contain a-z, 0-9 and _ , no upper case characters are allowed. module foo; Functions and macros Functions and macros must start with a-z after any optional initial _ . func void theMostAmazingFunction() { return; } macro justDoIt(x) { justDo(x); }","title":"Naming rules"},{"location":"naming/#naming-rules","text":"C3 introduces fairly strict naming rules to reduce ambiguity. As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character.","title":"Naming rules"},{"location":"naming/#structs-unions-enums-and-errors","text":"All user defined types must start with A-Z after any optional initial _ and include at least 1 lower case letter. Bar , _T_i12 and TTi are all valid names. _1 , bAR and BAR are not. For C-compatibility it's possible to alias the type to a C name using the attribute \"cname\". struct Foo @(cname = \"foo\") { int x; Bar bar; } union Bar { int i; double d; } enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS }","title":"Structs, unions, enums and errors"},{"location":"naming/#variables-and-parameters","text":"All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not. int theGlobal = 1; func void foo(int x) { Foo foo = getFoo(x); theGlobal++; }","title":"Variables and parameters"},{"location":"naming/#global-constants","text":"Global constants must start with A-Z after any optional initial _ . _FOO2 , BAR_FOO , X are all valid global constants, _ , _bar , x are not. const int A_VALUE = 12;","title":"Global constants"},{"location":"naming/#enum-error-values","text":"Enum and error values follow the same naming standard as global constants. enum Baz { VALUE_1, VALUE_2 } error Err { OOPS, LOTS_OF_OOPS }","title":"Enum / error values"},{"location":"naming/#struct-union-members","text":"Struct and union members follow the same naming rules as variables.","title":"Struct / union members"},{"location":"naming/#modules","text":"Module names may contain a-z, 0-9 and _ , no upper case characters are allowed. module foo;","title":"Modules"},{"location":"naming/#functions-and-macros","text":"Functions and macros must start with a-z after any optional initial _ . func void theMostAmazingFunction() { return; } macro justDoIt(x) { justDo(x); }","title":"Functions and macros"},{"location":"precedence/","text":"Precedence rules Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- prefix - , ~ , prefix * , & , prefix ++ and -- infix * , / , % << , >> ^ , | , infix & + , infix - == , != , >= , <= , > , < && , || ternary ?: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= , The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a || b && c a || (b && c) // C (&& binds tighter than ||) (a || b) && c // C3 (Same precedence, left-to-right evaluation) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 (Same precedence, left-to-right evaluation) a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 (Same precedence, left-to-right evaluation) The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of || and &&, relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence"},{"location":"precedence/#precedence-rules","text":"Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- prefix - , ~ , prefix * , & , prefix ++ and -- infix * , / , % << , >> ^ , | , infix & + , infix - == , != , >= , <= , > , < && , || ternary ?: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= , The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a || b && c a || (b && c) // C (&& binds tighter than ||) (a || b) && c // C3 (Same precedence, left-to-right evaluation) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 (Same precedence, left-to-right evaluation) a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 (Same precedence, left-to-right evaluation) The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of || and &&, relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence rules"},{"location":"preconditions/","text":"Pre and post conditions Pre and post conditions are optional checks that the compiler may use for optimization and runtime checks. Note that compilers are not obliged to process pre and post conditions at all . However, violating either pre or post conditions is considered undefined behaviour, so a compiler may optimize as if they always hold \u2013 even if a potential bug may cause them to be violated. Pre conditions Pre conditions are usually used to validate incoming arguments. Each condition must be an expression that can be evaluated to a boolean. A pre condition use the @require annotation. /** * @require foo > 0, foo < 1000 **/ func int testFoo(int foo) { return foo * 10; } Post conditions Post conditions are evaluated to make checks on the resulting state after passing through the function. There are two special post conditions: const and pure . The post condition uses the @ensure annotation. Where return is used to mark the return value from the function. For const and pure , they can either be given as separate annotations: @pure and @const <parameter>, ... , or inside an @ensure using the format const(<parameter>) and pure(<function name>) . A parameter marked const guarentees that the memory pointed to is not altered within the scope of a function. pure guarantees that the function does not read or write to any global variables. /** * @ensure const(foo), return > foo.x; * @pure **/ func uint checkFoo(Foo& foo) { uint y = abs(foo.x) + 1; // If we had row: foo.x = 0, then this would be a compile time error. return y * abs(foo.x); } Const in detail The const annotation allows a program to make assumtions in regards of how the function treats the parameter. This can then be used by a compiler make optimizations for any caller of the function. However, it should be noted that the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: func void badFunc(int& i) { *i = 2; } /** * @ensure const(i) */ func void lyingFunc(int& i) { badFunc(i); // The compiler might not check this! } func void test() { int a = 1; lyingFunc(&a); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: /** * @ensure const(i) */ func void badFunc(int& i) { *i = 2; // <- Compiler error: violating post condition const(i) } Pure in detail The pure annotation allows a program to make assumtions in regards of how the function treats global variables. Unlike for const , a pure function is not allowed to call a function which is known to be impure. However, just like for const the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: int i = 0; type SecretFunc func void(); func void badFunc() { i = 2; } SecretFunc foo = nil; /** * @pure */ func void lyingFunc() { SecretFunc(); // The compiler cannot reason about this! } func void test() { foo = &badFunc; i = 1; lyingFunc(); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: int i = 0; func void badFunc() { i = 2; } /** * @pure */ func void lyingFunc() { badFunc(); // Error! Calling an impure function } Consequently circumventing \"pure\" annotations is undefined behaviour. Pre conditions for macros Macros have an additional class of pre conditions, that are used to confirm that the values actually will work inside the macro body. This improves the error messages, since otherwise it would be hard to know if the error is in the implementation of the macro, or in the parameters. These are placed under the @reqparse annotation, or together with the @require annotations, surrounded by parse() . /** * @reqparse resource.open() * @require resource != nil, parse(void *x = resource.open()) **/ macro openResource(resource) { return resource.open(); }","title":"Pre and post conditions"},{"location":"preconditions/#pre-and-post-conditions","text":"Pre and post conditions are optional checks that the compiler may use for optimization and runtime checks. Note that compilers are not obliged to process pre and post conditions at all . However, violating either pre or post conditions is considered undefined behaviour, so a compiler may optimize as if they always hold \u2013 even if a potential bug may cause them to be violated.","title":"Pre and post conditions"},{"location":"preconditions/#pre-conditions","text":"Pre conditions are usually used to validate incoming arguments. Each condition must be an expression that can be evaluated to a boolean. A pre condition use the @require annotation. /** * @require foo > 0, foo < 1000 **/ func int testFoo(int foo) { return foo * 10; }","title":"Pre conditions"},{"location":"preconditions/#post-conditions","text":"Post conditions are evaluated to make checks on the resulting state after passing through the function. There are two special post conditions: const and pure . The post condition uses the @ensure annotation. Where return is used to mark the return value from the function. For const and pure , they can either be given as separate annotations: @pure and @const <parameter>, ... , or inside an @ensure using the format const(<parameter>) and pure(<function name>) . A parameter marked const guarentees that the memory pointed to is not altered within the scope of a function. pure guarantees that the function does not read or write to any global variables. /** * @ensure const(foo), return > foo.x; * @pure **/ func uint checkFoo(Foo& foo) { uint y = abs(foo.x) + 1; // If we had row: foo.x = 0, then this would be a compile time error. return y * abs(foo.x); }","title":"Post conditions"},{"location":"preconditions/#const-in-detail","text":"The const annotation allows a program to make assumtions in regards of how the function treats the parameter. This can then be used by a compiler make optimizations for any caller of the function. However, it should be noted that the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: func void badFunc(int& i) { *i = 2; } /** * @ensure const(i) */ func void lyingFunc(int& i) { badFunc(i); // The compiler might not check this! } func void test() { int a = 1; lyingFunc(&a); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: /** * @ensure const(i) */ func void badFunc(int& i) { *i = 2; // <- Compiler error: violating post condition const(i) }","title":"Const in detail"},{"location":"preconditions/#pure-in-detail","text":"The pure annotation allows a program to make assumtions in regards of how the function treats global variables. Unlike for const , a pure function is not allowed to call a function which is known to be impure. However, just like for const the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: int i = 0; type SecretFunc func void(); func void badFunc() { i = 2; } SecretFunc foo = nil; /** * @pure */ func void lyingFunc() { SecretFunc(); // The compiler cannot reason about this! } func void test() { foo = &badFunc; i = 1; lyingFunc(); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: int i = 0; func void badFunc() { i = 2; } /** * @pure */ func void lyingFunc() { badFunc(); // Error! Calling an impure function } Consequently circumventing \"pure\" annotations is undefined behaviour.","title":"Pure in detail"},{"location":"preconditions/#pre-conditions-for-macros","text":"Macros have an additional class of pre conditions, that are used to confirm that the values actually will work inside the macro body. This improves the error messages, since otherwise it would be hard to know if the error is in the implementation of the macro, or in the parameters. These are placed under the @reqparse annotation, or together with the @require annotations, surrounded by parse() . /** * @reqparse resource.open() * @require resource != nil, parse(void *x = resource.open()) **/ macro openResource(resource) { return resource.open(); }","title":"Pre conditions for macros"},{"location":"project/","text":"Customizing A Project A new project is provided with a barebone structure: [[executable]] # name of the target name = \"hello_world\" # version using semantic versioning version = \"0.1.0\" # authors, optionally with email authors = [\"John Doe <john.doe@example.com>\"] # language version of C3 langrev = \"1\" # warnings used warnings = [\"no-unused\"] # sources compliled sources = [\"src/**\"] # libraries to use libs = [\"lib/**\"] Libraries look a little different: [[static-lib]] name = \"graphics\" version = \"0.1.0\" authors = [\"John Doe <john.doe@example.com>\"] langrev = \"1\" warnings = [\"no-unused\"] sources = [\"src/**\"] # exported modules export = [\"api\"] Target options config Under the config you define external constants (\"key = value\") that will be included in compilation as if they were global macro constants. export Define the list of modules to be exported by a library. Not valid for executables. generate C3 defaults to generating C code that is then compiled and remove. Simply compile to C without further compilation by setting generate = \"C\" warnings List of warnings to enable during compilation. lib List of libraries to use when compiling the target. macro-recursion-depth Set the depth for recursion of macros. Typically set to a value around 10,000. Using environment variables In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Project Structure"},{"location":"project/#customizing-a-project","text":"A new project is provided with a barebone structure: [[executable]] # name of the target name = \"hello_world\" # version using semantic versioning version = \"0.1.0\" # authors, optionally with email authors = [\"John Doe <john.doe@example.com>\"] # language version of C3 langrev = \"1\" # warnings used warnings = [\"no-unused\"] # sources compliled sources = [\"src/**\"] # libraries to use libs = [\"lib/**\"] Libraries look a little different: [[static-lib]] name = \"graphics\" version = \"0.1.0\" authors = [\"John Doe <john.doe@example.com>\"] langrev = \"1\" warnings = [\"no-unused\"] sources = [\"src/**\"] # exported modules export = [\"api\"]","title":"Customizing A Project"},{"location":"project/#target-options","text":"","title":"Target options"},{"location":"project/#config","text":"Under the config you define external constants (\"key = value\") that will be included in compilation as if they were global macro constants.","title":"config"},{"location":"project/#export","text":"Define the list of modules to be exported by a library. Not valid for executables.","title":"export"},{"location":"project/#generate","text":"C3 defaults to generating C code that is then compiled and remove. Simply compile to C without further compilation by setting generate = \"C\"","title":"generate"},{"location":"project/#warnings","text":"List of warnings to enable during compilation.","title":"warnings"},{"location":"project/#lib","text":"List of libraries to use when compiling the target.","title":"lib"},{"location":"project/#macro-recursion-depth","text":"Set the depth for recursion of macros. Typically set to a value around 10,000.","title":"macro-recursion-depth"},{"location":"project/#using-environment-variables","text":"In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Using environment variables"},{"location":"sample/","text":"Sample Here is a bit of code manually converted to C3 from C. struct Node { uint hole; uint size; Node* next; Node* prev; } struct Footer { Node &header; } struct Bin { Node& head; } struct Heap { size start; size end; Bin* bins[BIN_COUNT]; } const uint OFFSET = 8; /** * @require start > 0 */ void Heap.init(Heap& heap, usize start) { Node& init_region = @cast(Node&, start); init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - @sizeof(Node) - @sizeof(Footer); init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = @cast(void*, start); heap.end = @cast(void*, start + HEAP_INIT_SIZE); } void* Heap.alloc(Heap& heap, usize size) { uint index = get_bin_index(size); Bin& temp = @cast(Bin&, heap.bins[index]); Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node& split = @cast(Node*, @cast(char&, found) + sizeof(Node) + sizeof(Footer)) + size); split.size = found.size - size - sizeof(Node) - sizeof(Footer); split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node& wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ func void Heap.free(Heap* heap, void *p) { Bin& list; Footer& new_foot, old_foot; Node& head = @cast(Node&, @cast(char&, p) - OFFSET); if (head == @cast(Node&, @cast(heap.start, usize)) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node& next = @cast(Node*, @cast(char*, head.getFoot()) + sizeof(Footer)); Footer& f = @cast(Footer*, @cast(char*, head) - sizeof(Footer)); Node& prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } func uint Heap.expand(Heap& heap, usize sz) { return 0; } func void Heap.contract(Heap& heap, usize sz) { return; } func uint get_bin_index(usize sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } func void Node.createFoot(Node& head) { Footer& foot = head.getFoot(); foot.header = head; } func Foot& Node.getFoot(Node& node) { return @cast(Footer&, @cast(char&, node) + sizeof(Node) + node.size); } func Node* getWilderness(Heap& heap) { Footer& wild_foot = @cast(Footer&, @cast(char&, heap.end) - sizeof(Footer)); return wild_foot.header; }","title":"More code examples"},{"location":"sample/#sample","text":"Here is a bit of code manually converted to C3 from C. struct Node { uint hole; uint size; Node* next; Node* prev; } struct Footer { Node &header; } struct Bin { Node& head; } struct Heap { size start; size end; Bin* bins[BIN_COUNT]; } const uint OFFSET = 8; /** * @require start > 0 */ void Heap.init(Heap& heap, usize start) { Node& init_region = @cast(Node&, start); init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - @sizeof(Node) - @sizeof(Footer); init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = @cast(void*, start); heap.end = @cast(void*, start + HEAP_INIT_SIZE); } void* Heap.alloc(Heap& heap, usize size) { uint index = get_bin_index(size); Bin& temp = @cast(Bin&, heap.bins[index]); Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node& split = @cast(Node*, @cast(char&, found) + sizeof(Node) + sizeof(Footer)) + size); split.size = found.size - size - sizeof(Node) - sizeof(Footer); split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node& wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ func void Heap.free(Heap* heap, void *p) { Bin& list; Footer& new_foot, old_foot; Node& head = @cast(Node&, @cast(char&, p) - OFFSET); if (head == @cast(Node&, @cast(heap.start, usize)) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node& next = @cast(Node*, @cast(char*, head.getFoot()) + sizeof(Footer)); Footer& f = @cast(Footer*, @cast(char*, head) - sizeof(Footer)); Node& prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } func uint Heap.expand(Heap& heap, usize sz) { return 0; } func void Heap.contract(Heap& heap, usize sz) { return; } func uint get_bin_index(usize sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } func void Node.createFoot(Node& head) { Footer& foot = head.getFoot(); foot.header = head; } func Foot& Node.getFoot(Node& node) { return @cast(Footer&, @cast(char&, node) + sizeof(Node) + node.size); } func Node* getWilderness(Heap& heap) { Footer& wild_foot = @cast(Footer&, @cast(char&, heap.end) - sizeof(Footer)); return wild_foot.header; }","title":"Sample"},{"location":"setup/","text":"This is a placeholder page.","title":"Setup"},{"location":"specialfunctions/","text":"Built in functions C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc abs Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long) byteswap Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long) bitreverse Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long) ceil Return the closest integral number, rounded up. float ceilf(float) double ceil(double) clz Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong) cos Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad) ctz Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"Built in functions"},{"location":"specialfunctions/#built-in-functions","text":"C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc","title":"Built in functions"},{"location":"specialfunctions/#abs","text":"Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long)","title":"abs"},{"location":"specialfunctions/#byteswap","text":"Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long)","title":"byteswap"},{"location":"specialfunctions/#bitreverse","text":"Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long)","title":"bitreverse"},{"location":"specialfunctions/#ceil","text":"Return the closest integral number, rounded up. float ceilf(float) double ceil(double)","title":"ceil"},{"location":"specialfunctions/#clz","text":"Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong)","title":"clz"},{"location":"specialfunctions/#cos","text":"Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad)","title":"cos"},{"location":"specialfunctions/#ctz","text":"Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"ctz"},{"location":"statements/","text":"Statements Volatile section Volatile sections replace volatile type qualifiers on variable types. func void test() { v = 0; for (int i = 0; i < 100; i++) { volatile { v = 1; } } } Note that volatile sections may also be used as expressions: // The v = 1 assignment may not be optimized away, // But the assignment to x can be. x = volatile(v = 1);","title":"Statements"},{"location":"statements/#statements","text":"","title":"Statements"},{"location":"statements/#volatile-section","text":"Volatile sections replace volatile type qualifiers on variable types. func void test() { v = 0; for (int i = 0; i < 100; i++) { volatile { v = 1; } } } Note that volatile sections may also be used as expressions: // The v = 1 assignment may not be optimized away, // But the assignment to x can be. x = volatile(v = 1);","title":"Volatile section"},{"location":"syntax/","text":"Syntax Keywords The following are 72 reserved keywords used by C3: as, asm, break, case, cast, catch, const, continue, default, defer, do, else, enum, error, false, for, func, generic, goto, if, import, local, macro, module, nil, public, return, struct, switch, throw, throws, true, try, typedef, union, until, void, volatile, while, f32, f64, float, double, u1, i8, i16, i32, i64, u8, u16, u32, u64, char, bool, byte, short, ushort, int, uint, long, ulong, isize, usize, c_short, c_ushort, c_int, c_uint, c_long, c_ulong, c_longlong, c_ulonglong, c_longdouble In addition to those, the following 12 are reserved but currently not used: f16, f128, f256, half, quad, i128, i256, u128, u256, type, var, alias For macros the the following 9 @ identifiers are reserved as keywords: @param, @throws, @return, @ensure, @require, @pure, @const, @reqparse, @deprecated Railroad grammar The following (broken) grammar can be used with this: https://bottlecaps.de/rr/ui to get a railroad diagram of the grammar. compilation_unit ::= module? import* top_level_decl* module ::= 'module' IDENT ';' import ::= 'import' IDENT ('as' IDENT)? 'local'? ';' top_level_decl ::= func_decl | struct_decl | union_decl | enum_decl | error_decl | macro_decl | const_decl | var_decl | type_decl | macro_var_decl | docs | generic_decl error_decl ::= 'error' IDENT '{' IDENT (',' IDENT)* ','? '}' enum_decl ::= 'enum' IDENT (':' type)? '{' enum_member (',' enum_member)* ','? '}' enum_member ::= IDENT ('=' expr)? const_decl ::= 'const' type IDENT '=' expr ';' var_decl ::= type IDENT '=' expr ';' type_decl ::= 'typedef' type 'as' IDENT ';' | 'typedef' 'func' type IDENT '(' function_args ')' 'as' IDENT ';' func_decl ::= 'func' type IDENT '(' function_args ')' (compound_stmt | ';') generic_decl ::= 'generic' IDENT '(' generic_arg_list ')' compound_stmt generic_arg_list ::= generic_arg (',' generic_arg)* generic_arg ::= type? IDENT base_type ::= built_in_type | IDENT built_in_type ::= bit_types | named_types | c_types bit_types ::= 'u1' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'i8' | 'i16' | 'i32' | 'i64' | 'i128' | 'i256' | 'f16' | 'f32' | 'f64' | 'f128' named_types ::= 'void' | 'bool' | 'byte' | 'ushort' | 'uint' | 'ulong' | 'usize' | 'char' | 'short' | 'int' | 'long' | 'isize' | 'float' | 'double' | 'quad' c_types ::= 'c_char' | 'c_short' | 'c_int' | 'c_long' | 'c_longlong' | 'c_uchar' | 'c_ushort' | 'c_uint' | 'c_ulong' | 'c_ulonglong' | 'c_float' | 'c_double' | 'c_longdouble' type ::= base_type ('[' expr? ']' | '*' | '?' | '@')* macro_decl ::= 'macro' AT_IDENT '(' macro_arg_list? ')' compound_stmt macro_arg_list ::= macro_arg (',' macro_arg)* macro_arg ::= DOLLAR_IDENT | IDENT | HASH_IDENT ---> The rest is todo struct_or_union ::= 'struct' | 'union' enum_def ::= 'enum' TIDENT enum_def type attributes? '{' enum_body? '}' enum_body ::= enum_value (',' enum_value)* ','? enum_value ::= TIDENT ('=' expression)? error_def ::= 'error' TIDENT '{' TIDENT (',' TIDENT)* '}' func_type_def ::= 'func' type attributes? '(' function_args ')' EOS struct_def ::= struct_or_union TIDENT attributes? struct_body struct_body ::= '{' (struct_member (',' struct_member)* )? '}' struct_member ::= (type VIDENT) | (struct_or_union TIDENT? struct_body) compound_stmt ::= '{' (statement | declaration)* '}' statement ::= label_stmt | compound_stmt | expr_stmt | if_stmt | switch_stmt | iter_stmt | jump_stmt jump_stmt ::= ( ('goto' TIDENT) | 'continue' | 'break' | 'next' | ('return' expression?) ) EOS label_stmt ::= TIDENT ':' if_stmt ::= 'if' control_expr statement (ELSE statement)? switch_stmt ::= 'switch' control_expr '{' switch_body '}' switch_body ::= case_stmt | default_stmt case_stmt ::= 'case' expression ':' case_body default_stmt ::= 'default' ':' case_body case_body ::= (statement | declaration)* control_expr ::= '(' var_def_list? expression ')' var_def_list ::= var_def (',' var_def)* EOS iter_stmt ::= while_stmt | do_stmt | for_stmt while_stmt ::= 'while' control_stml statement do_stmt ::= 'do' statement while '(' expression ')' EOS for_stmt ::= 'for' '(' var_def_list? expression? EOS expression ')' statement type ::= base_type (pointer_suffix | array_suffix)* qualified_type ::= qualifier* base_type ((qualifier* pointer_suffix) | array_suffix)* base_type ::= built_in_type | TIDENT built_in_type ::= bit_types | named_types | c_types bit_types ::= unsigned_bit_types | signed_bit_types | float_bit_types unsigned_bit_types ::= 'u8' | 'u16' | 'u32' | 'u64' | 'u1' signed_bit_types ::= 'i8' | 'i16' | 'i32' | 'i64' float_bit_types ::= 'f16' | 'f32' | 'f64' | 'f128' named_types ::= signed_named_types | unsigned_named_types | float_named_types | 'void' signed_named_types ::= 'char' | 'short' | 'int' | 'long' | 'isize' unsigned_named_types ::= 'bool' | 'byte' | 'ushort' | 'uint' | 'ulong' | 'usize' float_named_types ::= 'float' | 'double' | 'quad' c_types ::= signed_c_types | unsigned_c_types | float_c_types signed_c_types ::= 'c_ichar' | 'c_ushort' | 'c_int' | 'c_long' | 'c_longlong' unsigned_c_types ::= 'c_uchar' | 'c_ushort' | 'c_uint' | 'c_ulong' | 'c_ulonglong' float_c_types ::= 'c_float' | 'c_double' | 'c_longdouble' pointer_suffix ::= '*' | '&' array_suffix ::= '[' expression? ']' expr_stmt ::= expression EOS primary_expr ::= IDENT | CONSTANT | STRING_LITERL | '(' expression ')' postfix_expr ::= primary_expr postfix_op* postfix_op ::= array_op | call_op | dot_op | inc_dec_op array_op ::= '[' expression ']' call_op ::= '(' arg_expr_list? ')' dot_op ::= '.' VIDENT inc_dec_op ::= '++' | '--' arg_expr_list ::= assign_expr (',' assign_expr)* unary_op ::= inc_dec_op | '&' | '*' | '+' | '-' | '~' | '!' unary_expr ::= inc_dec_op* postfix_expr binary_op ::= mult_op | arith_op | assign_op | rel_op | bit_op | bool_op assign_op ::= '=' | mult_assign_op | arith_assign_op | bit_assign_op mult_assign_op ::= '*=' | '/=' | '%=' arith_assign_op ::= '+=' | '-=' bit_assign_op ::= '>>=' | '<<=' | '>>>=' | '|=' | '&=' | '^=' arith_op ::= '+' | '-' mult_op ::= '*' | '/' | '%' bit_op ::= '|' | '&' | '^' | '>>' | '<<' | '>>>' bool_op ::= '&&' | '||' rel_op ::= '==' | '!=' | '<' | '>' | '<=' | '>=' binary_expr ::= unary_expr (binary_op unary_expr)* expression ::= binary_expr ('?' expression ':' cond_expr)? declaration ::= qualified_type VIDENT ('=' init_expr)? EOS init_expr ::= expression | struct_init struct_init ::= '{' stuct_init_list? '}' struct_init_list ::= strict_init_decl (',' struct_init_decl)* struct_init_decl ::= member_init | init_expr member_init ::=_ '.' VIDENT '=' init_expr","title":"Grammar"},{"location":"syntax/#syntax","text":"","title":"Syntax"},{"location":"syntax/#keywords","text":"The following are 72 reserved keywords used by C3: as, asm, break, case, cast, catch, const, continue, default, defer, do, else, enum, error, false, for, func, generic, goto, if, import, local, macro, module, nil, public, return, struct, switch, throw, throws, true, try, typedef, union, until, void, volatile, while, f32, f64, float, double, u1, i8, i16, i32, i64, u8, u16, u32, u64, char, bool, byte, short, ushort, int, uint, long, ulong, isize, usize, c_short, c_ushort, c_int, c_uint, c_long, c_ulong, c_longlong, c_ulonglong, c_longdouble In addition to those, the following 12 are reserved but currently not used: f16, f128, f256, half, quad, i128, i256, u128, u256, type, var, alias For macros the the following 9 @ identifiers are reserved as keywords: @param, @throws, @return, @ensure, @require, @pure, @const, @reqparse, @deprecated","title":"Keywords"},{"location":"syntax/#railroad-grammar","text":"The following (broken) grammar can be used with this: https://bottlecaps.de/rr/ui to get a railroad diagram of the grammar. compilation_unit ::= module? import* top_level_decl* module ::= 'module' IDENT ';' import ::= 'import' IDENT ('as' IDENT)? 'local'? ';' top_level_decl ::= func_decl | struct_decl | union_decl | enum_decl | error_decl | macro_decl | const_decl | var_decl | type_decl | macro_var_decl | docs | generic_decl error_decl ::= 'error' IDENT '{' IDENT (',' IDENT)* ','? '}' enum_decl ::= 'enum' IDENT (':' type)? '{' enum_member (',' enum_member)* ','? '}' enum_member ::= IDENT ('=' expr)? const_decl ::= 'const' type IDENT '=' expr ';' var_decl ::= type IDENT '=' expr ';' type_decl ::= 'typedef' type 'as' IDENT ';' | 'typedef' 'func' type IDENT '(' function_args ')' 'as' IDENT ';' func_decl ::= 'func' type IDENT '(' function_args ')' (compound_stmt | ';') generic_decl ::= 'generic' IDENT '(' generic_arg_list ')' compound_stmt generic_arg_list ::= generic_arg (',' generic_arg)* generic_arg ::= type? IDENT base_type ::= built_in_type | IDENT built_in_type ::= bit_types | named_types | c_types bit_types ::= 'u1' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'i8' | 'i16' | 'i32' | 'i64' | 'i128' | 'i256' | 'f16' | 'f32' | 'f64' | 'f128' named_types ::= 'void' | 'bool' | 'byte' | 'ushort' | 'uint' | 'ulong' | 'usize' | 'char' | 'short' | 'int' | 'long' | 'isize' | 'float' | 'double' | 'quad' c_types ::= 'c_char' | 'c_short' | 'c_int' | 'c_long' | 'c_longlong' | 'c_uchar' | 'c_ushort' | 'c_uint' | 'c_ulong' | 'c_ulonglong' | 'c_float' | 'c_double' | 'c_longdouble' type ::= base_type ('[' expr? ']' | '*' | '?' | '@')* macro_decl ::= 'macro' AT_IDENT '(' macro_arg_list? ')' compound_stmt macro_arg_list ::= macro_arg (',' macro_arg)* macro_arg ::= DOLLAR_IDENT | IDENT | HASH_IDENT ---> The rest is todo struct_or_union ::= 'struct' | 'union' enum_def ::= 'enum' TIDENT enum_def type attributes? '{' enum_body? '}' enum_body ::= enum_value (',' enum_value)* ','? enum_value ::= TIDENT ('=' expression)? error_def ::= 'error' TIDENT '{' TIDENT (',' TIDENT)* '}' func_type_def ::= 'func' type attributes? '(' function_args ')' EOS struct_def ::= struct_or_union TIDENT attributes? struct_body struct_body ::= '{' (struct_member (',' struct_member)* )? '}' struct_member ::= (type VIDENT) | (struct_or_union TIDENT? struct_body) compound_stmt ::= '{' (statement | declaration)* '}' statement ::= label_stmt | compound_stmt | expr_stmt | if_stmt | switch_stmt | iter_stmt | jump_stmt jump_stmt ::= ( ('goto' TIDENT) | 'continue' | 'break' | 'next' | ('return' expression?) ) EOS label_stmt ::= TIDENT ':' if_stmt ::= 'if' control_expr statement (ELSE statement)? switch_stmt ::= 'switch' control_expr '{' switch_body '}' switch_body ::= case_stmt | default_stmt case_stmt ::= 'case' expression ':' case_body default_stmt ::= 'default' ':' case_body case_body ::= (statement | declaration)* control_expr ::= '(' var_def_list? expression ')' var_def_list ::= var_def (',' var_def)* EOS iter_stmt ::= while_stmt | do_stmt | for_stmt while_stmt ::= 'while' control_stml statement do_stmt ::= 'do' statement while '(' expression ')' EOS for_stmt ::= 'for' '(' var_def_list? expression? EOS expression ')' statement type ::= base_type (pointer_suffix | array_suffix)* qualified_type ::= qualifier* base_type ((qualifier* pointer_suffix) | array_suffix)* base_type ::= built_in_type | TIDENT built_in_type ::= bit_types | named_types | c_types bit_types ::= unsigned_bit_types | signed_bit_types | float_bit_types unsigned_bit_types ::= 'u8' | 'u16' | 'u32' | 'u64' | 'u1' signed_bit_types ::= 'i8' | 'i16' | 'i32' | 'i64' float_bit_types ::= 'f16' | 'f32' | 'f64' | 'f128' named_types ::= signed_named_types | unsigned_named_types | float_named_types | 'void' signed_named_types ::= 'char' | 'short' | 'int' | 'long' | 'isize' unsigned_named_types ::= 'bool' | 'byte' | 'ushort' | 'uint' | 'ulong' | 'usize' float_named_types ::= 'float' | 'double' | 'quad' c_types ::= signed_c_types | unsigned_c_types | float_c_types signed_c_types ::= 'c_ichar' | 'c_ushort' | 'c_int' | 'c_long' | 'c_longlong' unsigned_c_types ::= 'c_uchar' | 'c_ushort' | 'c_uint' | 'c_ulong' | 'c_ulonglong' float_c_types ::= 'c_float' | 'c_double' | 'c_longdouble' pointer_suffix ::= '*' | '&' array_suffix ::= '[' expression? ']' expr_stmt ::= expression EOS primary_expr ::= IDENT | CONSTANT | STRING_LITERL | '(' expression ')' postfix_expr ::= primary_expr postfix_op* postfix_op ::= array_op | call_op | dot_op | inc_dec_op array_op ::= '[' expression ']' call_op ::= '(' arg_expr_list? ')' dot_op ::= '.' VIDENT inc_dec_op ::= '++' | '--' arg_expr_list ::= assign_expr (',' assign_expr)* unary_op ::= inc_dec_op | '&' | '*' | '+' | '-' | '~' | '!' unary_expr ::= inc_dec_op* postfix_expr binary_op ::= mult_op | arith_op | assign_op | rel_op | bit_op | bool_op assign_op ::= '=' | mult_assign_op | arith_assign_op | bit_assign_op mult_assign_op ::= '*=' | '/=' | '%=' arith_assign_op ::= '+=' | '-=' bit_assign_op ::= '>>=' | '<<=' | '>>>=' | '|=' | '&=' | '^=' arith_op ::= '+' | '-' mult_op ::= '*' | '/' | '%' bit_op ::= '|' | '&' | '^' | '>>' | '<<' | '>>>' bool_op ::= '&&' | '||' rel_op ::= '==' | '!=' | '<' | '>' | '<=' | '>=' binary_expr ::= unary_expr (binary_op unary_expr)* expression ::= binary_expr ('?' expression ':' cond_expr)? declaration ::= qualified_type VIDENT ('=' init_expr)? EOS init_expr ::= expression | struct_init struct_init ::= '{' stuct_init_list? '}' struct_init_list ::= strict_init_decl (',' struct_init_decl)* struct_init_decl ::= member_init | init_expr member_init ::=_ '.' VIDENT '=' init_expr","title":"Railroad grammar"},{"location":"types/","text":"Types As usual, types are divided into basic types and user defined types (enum, union, struct, error, aliases). All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module. Naming All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. Since this runs into probles with C compatibility, it is possible to use attributes to change the c name of a type, as well as control whether a C typedef should be emitted for the type. struct Stat @(cname=\"stat\", no_typedef) { // ... } func c_int stat(const c_char* pathname, Stat* buf); Differences from C Unlike C, C3 does not use type qualifiers. const exists, but is a storage class modifier, not a type qualifier. Instead of volatile , volatile blocks are used. In order to signal restrictions on variable usage, like const-ness preconditions are used. Basic types Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned. Integer types Name alias bit size signed bool u1 1 no char i8 8 yes byte u8 8 no short i16 16 yes ushort u16 16 no int i32 32 yes uint u32 32 no long i64 64 yes ulong u64 64 no isize* - varies yes usize* - varies no * isize and usize are pointer sized. Integer arithmetics All signed integer arithmetics uses 2's complement. Integer constants Integer constants are 1293832 or -918212. Unlike C the \"type\" of an integer constant is a special compile time int. All constant operations, for example 9283 << 2 will be resolved at compile time. An compile time error will result if the constant is too large to fit whatever variable it is assigned or compared to. Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100 Floating point types Name alias bit size float f32 32 double f64 64 quad* f128 128 *support will depend on platform Floating point constants Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediagely before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10 C compatibility For C compatibility the following types are also defined: Name c type c_char char c_short short int c_ushort unsigned short int c_int int c_uint unsigned int c_long long int c_ulong unsigned long int c_longlong long long c_ulonglong unsigned long long c_float float c_double double c_longdouble long double Pointer types Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo. Array types Arrays are indicated by [] after the type. Unlike C, the [] . Foo[] would be an array of unspecified length containing Foo structs. Enum Enum (enumerated) types use the following syntax: enum State : int { PENDING = 0, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING . Alias and function types Alias types are used to give an alias to a different type, like: type CharPtr char*; type Numbers int[10]; Function pointers must be aliased in C3. The syntax is simpler than that of C: public type Callback func void(int a, bool b); This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback cb(10, false); Struct types Structs are always named: struct Person { char age; char* name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; io.printf(\"%s is %d years old.\", p.age, p.name); Person& pPtr = &p; pPtr.age = 20; // Ok! io.printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person&& and use dot access. \u2013 It's not, only one level of deref is done) Struct subtyping C3 allows creating struct subtypes: struct ImportantPerson { inline Person person; char* title; } func printPerson(Person p) { io.printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied. inline is not strictly needed. It allows a struct or union to be both addressed by name and directly as an anonymous struct/union. (See below) Union types Union types are defined just like structs. union Integral { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. io.printf(\"%d\", i.as_byte); Note that unions only take up as much space as their largest member, so sizeof(Integral) is equivalent to sizeof(long) . Anonymous sub-structs / unions Just like in later versions of C, anonymous sub-structs / unions are allowed. struct Person { char age; char* name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } }","title":"Types"},{"location":"types/#types","text":"As usual, types are divided into basic types and user defined types (enum, union, struct, error, aliases). All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module.","title":"Types"},{"location":"types/#naming","text":"All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. Since this runs into probles with C compatibility, it is possible to use attributes to change the c name of a type, as well as control whether a C typedef should be emitted for the type. struct Stat @(cname=\"stat\", no_typedef) { // ... } func c_int stat(const c_char* pathname, Stat* buf);","title":"Naming"},{"location":"types/#differences-from-c","text":"Unlike C, C3 does not use type qualifiers. const exists, but is a storage class modifier, not a type qualifier. Instead of volatile , volatile blocks are used. In order to signal restrictions on variable usage, like const-ness preconditions are used.","title":"Differences from C"},{"location":"types/#basic-types","text":"Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned.","title":"Basic types"},{"location":"types/#integer-types","text":"Name alias bit size signed bool u1 1 no char i8 8 yes byte u8 8 no short i16 16 yes ushort u16 16 no int i32 32 yes uint u32 32 no long i64 64 yes ulong u64 64 no isize* - varies yes usize* - varies no * isize and usize are pointer sized.","title":"Integer types"},{"location":"types/#integer-arithmetics","text":"All signed integer arithmetics uses 2's complement.","title":"Integer arithmetics"},{"location":"types/#integer-constants","text":"Integer constants are 1293832 or -918212. Unlike C the \"type\" of an integer constant is a special compile time int. All constant operations, for example 9283 << 2 will be resolved at compile time. An compile time error will result if the constant is too large to fit whatever variable it is assigned or compared to. Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100","title":"Integer constants"},{"location":"types/#floating-point-types","text":"Name alias bit size float f32 32 double f64 64 quad* f128 128 *support will depend on platform","title":"Floating point types"},{"location":"types/#floating-point-constants","text":"Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediagely before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10","title":"Floating point constants"},{"location":"types/#c-compatibility","text":"For C compatibility the following types are also defined: Name c type c_char char c_short short int c_ushort unsigned short int c_int int c_uint unsigned int c_long long int c_ulong unsigned long int c_longlong long long c_ulonglong unsigned long long c_float float c_double double c_longdouble long double","title":"C compatibility"},{"location":"types/#pointer-types","text":"Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo.","title":"Pointer types"},{"location":"types/#array-types","text":"Arrays are indicated by [] after the type. Unlike C, the [] . Foo[] would be an array of unspecified length containing Foo structs.","title":"Array types"},{"location":"types/#enum","text":"Enum (enumerated) types use the following syntax: enum State : int { PENDING = 0, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING .","title":"Enum"},{"location":"types/#alias-and-function-types","text":"Alias types are used to give an alias to a different type, like: type CharPtr char*; type Numbers int[10]; Function pointers must be aliased in C3. The syntax is simpler than that of C: public type Callback func void(int a, bool b); This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback cb(10, false);","title":"Alias and function types"},{"location":"types/#struct-types","text":"Structs are always named: struct Person { char age; char* name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; io.printf(\"%s is %d years old.\", p.age, p.name); Person& pPtr = &p; pPtr.age = 20; // Ok! io.printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person&& and use dot access. \u2013 It's not, only one level of deref is done)","title":"Struct types"},{"location":"types/#struct-subtyping","text":"C3 allows creating struct subtypes: struct ImportantPerson { inline Person person; char* title; } func printPerson(Person p) { io.printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied. inline is not strictly needed. It allows a struct or union to be both addressed by name and directly as an anonymous struct/union. (See below)","title":"Struct subtyping"},{"location":"types/#union-types","text":"Union types are defined just like structs. union Integral { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. io.printf(\"%d\", i.as_byte); Note that unions only take up as much space as their largest member, so sizeof(Integral) is equivalent to sizeof(long) .","title":"Union types"},{"location":"types/#anonymous-sub-structs-unions","text":"Just like in later versions of C, anonymous sub-structs / unions are allowed. struct Person { char age; char* name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } }","title":"Anonymous sub-structs / unions"}]}
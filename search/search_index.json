{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is C3? C3 is a system programming language based on C. It is an evolution of C enabling the same paradigms and retaining the same syntax as far as possible. C3 started as an extension of the C2 language by Bas van den Berg . It has evolved significantly, not just in syntax but also in regard to error handling, macros, generics and strings. The C3 compiler can be found on github: https://github.com/c3lang/c3c . Binaries are directly downloadable for the following platforms: - Windows x64 download , install instructions . - Debian x64 download , install instructions . - MacOS x64 download , install instructions . Last updated: Revision 2023-01-07 . Features Full C ABI compatibility Module system Generic modules Zero overhead errors Struct subtyping Semantic macro system Safe array access using sub arrays Zero cost simple gradual & opt-in pre/post conditions High level containers and string handling C to C3 conversion (for a subset of C) TODO LLVM backend Design principles Procedural \"get things done\"-type of language. Stay close to C - only change where there is a significant need. Flawless C integration. Learning C3 should be easy for a C programmer. Dare add conveniences if the value is great. Data is inert and zero is initialization. Avoid \"big ideas\". Avoid the kitchen sink language trap. Thank yous Special thank yous to: Bas van der Berg (Author of C2 ), Jon Goodwin (Author of Cone ) and Andrey Penechko (Author of Vox ).","title":"About C3"},{"location":"#what-is-c3","text":"C3 is a system programming language based on C. It is an evolution of C enabling the same paradigms and retaining the same syntax as far as possible. C3 started as an extension of the C2 language by Bas van den Berg . It has evolved significantly, not just in syntax but also in regard to error handling, macros, generics and strings. The C3 compiler can be found on github: https://github.com/c3lang/c3c . Binaries are directly downloadable for the following platforms: - Windows x64 download , install instructions . - Debian x64 download , install instructions . - MacOS x64 download , install instructions . Last updated: Revision 2023-01-07 .","title":"What is C3?"},{"location":"#features","text":"Full C ABI compatibility Module system Generic modules Zero overhead errors Struct subtyping Semantic macro system Safe array access using sub arrays Zero cost simple gradual & opt-in pre/post conditions High level containers and string handling C to C3 conversion (for a subset of C) TODO LLVM backend","title":"Features"},{"location":"#design-principles","text":"Procedural \"get things done\"-type of language. Stay close to C - only change where there is a significant need. Flawless C integration. Learning C3 should be easy for a C programmer. Dare add conveniences if the value is great. Data is inert and zero is initialization. Avoid \"big ideas\". Avoid the kitchen sink language trap.","title":"Design principles"},{"location":"#thank-yous","text":"Special thank yous to: Bas van der Berg (Author of C2 ), Jon Goodwin (Author of Cone ) and Andrey Penechko (Author of Vox ).","title":"Thank yous"},{"location":"arrays/","text":"Arrays Arrays has a central role in programming. C3 offers 2 built-in types of arrays: Fixed arrays <type>[<size>] e.g. int[4] . These are treated as values and will be copied if given as parameter. Unlike C, the number is part of its type. Taking a pointer to a fixed array will create a pointer to a fixed array, e.g. int[4]* . Unlike C, fixed arrays do not decay into pointers, instead an int[4]* may be implicitly converted into an int* . // C int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(x); // C3 fn int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(&x); When you want to initialize a fixed array without specififying the size, use the [*] array syntax: int[3] a = { 1, 2, 3 }; int[*] b = { 4, 5, 6 }; // Type inferred to be int[3] Subarray The final type is the subarray <type>[] e.g. int[] . A subarray is a view into either a fixed or variable array. Internally it is represented as a struct containing a pointer and a size. Both fixed and variable arrays may be converted into slices, and slices may be implicitly converted to pointers: int[4] a = { 1, 2, 3, 4}; int[] b = &a; // Implicit conversion is always ok. int[4] c = (int[4])b; // Will copy the value of b into c. int[4]* d = (int[4])a; // Equivalent to d = &a b.size; // Returns 4 e += 1; int* f = b; // Equivalent to e = &a f = d; // implicit conversion ok. Slicing arrays It's possible to use a range syntax to create subarrays from pointers, arrays, vararrays and other subarrays. The either use range syntax: arr[<start index>..<end index>] (the end index is included in the final result) or start + len syntax: arr[<start index> : len] int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; // The whole array as a slice. int[] b2 = a[0:5]; // Same as above. int[] c = a[2..3]; // { 50, 100 } int[] c2 = a[2:2]; // Same as above. It's possible to omit the first and last index in ranges, and the start index for start + len. Omitting the start index will default it to 0, omitting the end index will set it to the last valid index (this is not allowed on pointers). Length cannot be omitted in start + len syntax. The following are all equivalent: int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; int[] c = a[..4]; int[] d = a[0..]; int[] e = a[..]; int[] f = a[0:5]; int[] g = a[:5]; One may also slice from the end. Again this is not allowed for pointers. int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[1..^2]; // { 20, 50, 100 } int[] c = a[^3..]; // { 50, 100, 200 } int[] d = a[^3:2]; // { 50, 100 } One may also use assign to slices: int[3] a = { 1, 20, 50 }; a[1..2] = 0; // a = { 1, 0, 0} Or copy slices to slices: int[3] a = { 1, 20, 50 }; int[3] b = { 2, 4, 5 } a[1..2] = b[0..1]; // a = { 1, 2, 4} Copying overlapping ranges, e.g. a[1..2] = a[0..1] is undefined behaviour. Conversion list int[4] int[] int[4]* int* int[4] copy - - - int[] - assign assign - int[4]* - cast assign cast int* - assign assign assign Note that all casts above are inherently unsafe and will only work if the type cast is indeed compatible. For example: int[4] a; int[4]* b = &a; int* c = b; // Safe cast: int[4]* d = (int[4]*)c; int e = 12; int* f = &e; // Incorrect, but not checked int[4]* g = (int[4]*)f; // Also incorrect but not checked. int[] h = f[0..2]; Internals Internally the layout of a slice is guaranteed to be struct { <type>* ptrToArray; usz arraySize; } . There is a built in struct std::runtime::SubArrayContainer which has the exact data layout of the fat array pointers. It is defined to be struct SubArrayContainer { void* ptr; usz len; } Iteration over arrays Slices, fixed and variable arrays may all be iterated over using foreach (Type x : array) : int[4] a = { 1, 2, 3, 5 }; foreach (int x : a) { ... } Using & it is possible to get an element by reference rather than by copy. Furthermore, by providing two variable name, the first is assumed to be the index: Foo[4] a = { ... } foreach (int idx, Foo* &f : a) { f.abc = idx; // Mutates the array element } It is possible to enable foreach on any type by implementing \"len\" and \"[]\" methods and annotating them using the @operator attribute: struct Vector { usz size; int* elements; } macro int Vector.get(Vector* vector, usz element) @operator([]]) { return vector.elements[element]; } macro usz Vector.size(Vector* vector) @operator(len) { return vector.size; } Vector v; v.add(3); v.add(7); // Will print 3 and 7 foreach (int i : v) { printf(\"%d\\n\"); } For more information, see operator overloading","title":"Arrays"},{"location":"arrays/#arrays","text":"Arrays has a central role in programming. C3 offers 2 built-in types of arrays:","title":"Arrays"},{"location":"arrays/#fixed-arrays","text":"<type>[<size>] e.g. int[4] . These are treated as values and will be copied if given as parameter. Unlike C, the number is part of its type. Taking a pointer to a fixed array will create a pointer to a fixed array, e.g. int[4]* . Unlike C, fixed arrays do not decay into pointers, instead an int[4]* may be implicitly converted into an int* . // C int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(x); // C3 fn int foo(int *a) { ... } int x[3] = { 1, 2, 3 }; foo(&x); When you want to initialize a fixed array without specififying the size, use the [*] array syntax: int[3] a = { 1, 2, 3 }; int[*] b = { 4, 5, 6 }; // Type inferred to be int[3]","title":"Fixed arrays"},{"location":"arrays/#subarray","text":"The final type is the subarray <type>[] e.g. int[] . A subarray is a view into either a fixed or variable array. Internally it is represented as a struct containing a pointer and a size. Both fixed and variable arrays may be converted into slices, and slices may be implicitly converted to pointers: int[4] a = { 1, 2, 3, 4}; int[] b = &a; // Implicit conversion is always ok. int[4] c = (int[4])b; // Will copy the value of b into c. int[4]* d = (int[4])a; // Equivalent to d = &a b.size; // Returns 4 e += 1; int* f = b; // Equivalent to e = &a f = d; // implicit conversion ok.","title":"Subarray"},{"location":"arrays/#slicing-arrays","text":"It's possible to use a range syntax to create subarrays from pointers, arrays, vararrays and other subarrays. The either use range syntax: arr[<start index>..<end index>] (the end index is included in the final result) or start + len syntax: arr[<start index> : len] int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; // The whole array as a slice. int[] b2 = a[0:5]; // Same as above. int[] c = a[2..3]; // { 50, 100 } int[] c2 = a[2:2]; // Same as above. It's possible to omit the first and last index in ranges, and the start index for start + len. Omitting the start index will default it to 0, omitting the end index will set it to the last valid index (this is not allowed on pointers). Length cannot be omitted in start + len syntax. The following are all equivalent: int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[0..4]; int[] c = a[..4]; int[] d = a[0..]; int[] e = a[..]; int[] f = a[0:5]; int[] g = a[:5]; One may also slice from the end. Again this is not allowed for pointers. int[5] a = { 1, 20, 50, 100, 200 }; int[] b = a[1..^2]; // { 20, 50, 100 } int[] c = a[^3..]; // { 50, 100, 200 } int[] d = a[^3:2]; // { 50, 100 } One may also use assign to slices: int[3] a = { 1, 20, 50 }; a[1..2] = 0; // a = { 1, 0, 0} Or copy slices to slices: int[3] a = { 1, 20, 50 }; int[3] b = { 2, 4, 5 } a[1..2] = b[0..1]; // a = { 1, 2, 4} Copying overlapping ranges, e.g. a[1..2] = a[0..1] is undefined behaviour.","title":"Slicing arrays"},{"location":"arrays/#conversion-list","text":"int[4] int[] int[4]* int* int[4] copy - - - int[] - assign assign - int[4]* - cast assign cast int* - assign assign assign Note that all casts above are inherently unsafe and will only work if the type cast is indeed compatible. For example: int[4] a; int[4]* b = &a; int* c = b; // Safe cast: int[4]* d = (int[4]*)c; int e = 12; int* f = &e; // Incorrect, but not checked int[4]* g = (int[4]*)f; // Also incorrect but not checked. int[] h = f[0..2];","title":"Conversion list"},{"location":"arrays/#internals","text":"Internally the layout of a slice is guaranteed to be struct { <type>* ptrToArray; usz arraySize; } . There is a built in struct std::runtime::SubArrayContainer which has the exact data layout of the fat array pointers. It is defined to be struct SubArrayContainer { void* ptr; usz len; }","title":"Internals"},{"location":"arrays/#iteration-over-arrays","text":"Slices, fixed and variable arrays may all be iterated over using foreach (Type x : array) : int[4] a = { 1, 2, 3, 5 }; foreach (int x : a) { ... } Using & it is possible to get an element by reference rather than by copy. Furthermore, by providing two variable name, the first is assumed to be the index: Foo[4] a = { ... } foreach (int idx, Foo* &f : a) { f.abc = idx; // Mutates the array element } It is possible to enable foreach on any type by implementing \"len\" and \"[]\" methods and annotating them using the @operator attribute: struct Vector { usz size; int* elements; } macro int Vector.get(Vector* vector, usz element) @operator([]]) { return vector.elements[element]; } macro usz Vector.size(Vector* vector) @operator(len) { return vector.size; } Vector v; v.add(3); v.add(7); // Will print 3 and 7 foreach (int i : v) { printf(\"%d\\n\"); } For more information, see operator overloading","title":"Iteration over arrays"},{"location":"asm/","text":"Inline assembly C3 provides two ways to insert inline assembly: asm strings and asm blocks. Asm strings This form takes a single compile time string and passes it directly to the underlying backend without any changes. int x = 0; asm(\"nop\"); int y = x; Asm block Asm blocks uses a common grammar for all types of processors. It assumes that all assembly statements can be reduced to the format: instruction (arg (',' arg)*)?; Where an arg is: An identifier, e.g. FOO , x . A numeric constant 1 0xFF etc. A register name (always lower case with a '$' prefix) e.g. $eax $r7 . The address of a variable e.g. &x . An indirect address: [addr] or [addr + index * <const> + offset] . Any expression inside of \"()\" (will be evaluated before entering the asm block). An example: int aa = 3; int g; int* gp = &g; int* xa = &a; usz asf = 1; asm { movl x, 4; // Move 4 into the variable x movl [gp], x; // Move the value of x into the address in gp movl x, 1; // Move 1 into x movl [xa + asf * 4 + 4], x; // Move x into the address at xa[asf + 1] movl $eax, (23 + x); // Move 23 + x into EAX movl x, $eax; // Move EAX into x movq [&z], 33; // Move 33 into the memory address of z } The asm block will infer register clobbers and in/out parameters. *Please note that the current state of inline asm is a work in progress , only a subset of x86 and aarch64 instructions are available, other platforms have no support at all. It is likely that the grammar will be extended as more architectures are supported. More instructions can be added as they are needed, so please file issues when you encounter missing instructions you need.","title":"Inline asm"},{"location":"asm/#inline-assembly","text":"C3 provides two ways to insert inline assembly: asm strings and asm blocks.","title":"Inline assembly"},{"location":"asm/#asm-strings","text":"This form takes a single compile time string and passes it directly to the underlying backend without any changes. int x = 0; asm(\"nop\"); int y = x;","title":"Asm strings"},{"location":"asm/#asm-block","text":"Asm blocks uses a common grammar for all types of processors. It assumes that all assembly statements can be reduced to the format: instruction (arg (',' arg)*)?; Where an arg is: An identifier, e.g. FOO , x . A numeric constant 1 0xFF etc. A register name (always lower case with a '$' prefix) e.g. $eax $r7 . The address of a variable e.g. &x . An indirect address: [addr] or [addr + index * <const> + offset] . Any expression inside of \"()\" (will be evaluated before entering the asm block). An example: int aa = 3; int g; int* gp = &g; int* xa = &a; usz asf = 1; asm { movl x, 4; // Move 4 into the variable x movl [gp], x; // Move the value of x into the address in gp movl x, 1; // Move 1 into x movl [xa + asf * 4 + 4], x; // Move x into the address at xa[asf + 1] movl $eax, (23 + x); // Move 23 + x into EAX movl x, $eax; // Move EAX into x movq [&z], 33; // Move 33 into the memory address of z } The asm block will infer register clobbers and in/out parameters. *Please note that the current state of inline asm is a work in progress , only a subset of x86 and aarch64 instructions are available, other platforms have no support at all. It is likely that the grammar will be extended as more architectures are supported. More instructions can be added as they are needed, so please file issues when you encounter missing instructions you need.","title":"Asm block"},{"location":"attributes/","text":"Attributes Attributes are compile time annotations on functions, types, global constants and variables. Similar to Java annotations, a decoration may also take arguments. A attribute can also represent a bundle of attributes. Built in attributes pure (call) Used to annotate a non pure function as \"pure\" when checking for conformance to @pure on functions. packed (struct, union, enum) If used on a struct or enum: packs the type, including any components to minimum size. On an enum, it uses the smallest representation containing all its values. section(name) (var, fn) Declares that a global variable or function should appear in a specific section. inline (fn) Declares a function to always be inlined. aligned(alignment) (struct, union, var, fn) This attribute sets the minimum alignment for a field or a variable. noreturn (fn) Declares that the function will never return. weak (fn, var) Emits a weak symbol rather than a global. User defined attributes User defined attributes are intended for conditional application of built-in attributes. define @MyAttribute = @noreturn @inline; // The following two are equivalent: fn void foo() @MyAttribute { ... } fn void foo() @noreturn @inline { ... } A user defined attribute may also be completely empty: define @MyAttributeEmpty = void;","title":"Attributes"},{"location":"attributes/#attributes","text":"Attributes are compile time annotations on functions, types, global constants and variables. Similar to Java annotations, a decoration may also take arguments. A attribute can also represent a bundle of attributes.","title":"Attributes"},{"location":"attributes/#built-in-attributes","text":"","title":"Built in attributes"},{"location":"attributes/#pure-call","text":"Used to annotate a non pure function as \"pure\" when checking for conformance to @pure on functions.","title":"pure (call)"},{"location":"attributes/#packed-struct-union-enum","text":"If used on a struct or enum: packs the type, including any components to minimum size. On an enum, it uses the smallest representation containing all its values.","title":"packed (struct, union, enum)"},{"location":"attributes/#sectionname-var-fn","text":"Declares that a global variable or function should appear in a specific section.","title":"section(name) (var, fn)"},{"location":"attributes/#inline-fn","text":"Declares a function to always be inlined.","title":"inline (fn)"},{"location":"attributes/#alignedalignment-struct-union-var-fn","text":"This attribute sets the minimum alignment for a field or a variable.","title":"aligned(alignment) (struct, union, var, fn)"},{"location":"attributes/#noreturn-fn","text":"Declares that the function will never return.","title":"noreturn (fn)"},{"location":"attributes/#weak-fn-var","text":"Emits a weak symbol rather than a global.","title":"weak (fn, var)"},{"location":"attributes/#user-defined-attributes","text":"User defined attributes are intended for conditional application of built-in attributes. define @MyAttribute = @noreturn @inline; // The following two are equivalent: fn void foo() @MyAttribute { ... } fn void foo() @noreturn @inline { ... } A user defined attribute may also be completely empty: define @MyAttributeEmpty = void;","title":"User defined attributes"},{"location":"buildcommands/","text":"Build Commands When starting out, with C3 it's natural to use run to try things out. For larger projects, the built-in build system is instead recommended. By default the compiler is compiling stand-alone files to output an executable binary. c3c <file1> <file2> <file3> run The run command works same as compilation, but also immediately runs the resulting executable. c3c run <file1> <file2> <file3> Common additional parameters Additional parameters: - --lib <path> add a library to search. - --output <path> override the output directory. - --path <path> execute as if standing at init c3c init <project_name> [optional path] . Create a new project structure in the current directory. Use the --template to select a template. The following are built in: default - the default template, produces an executable. lib - template for producing a library. staticlib - template for producing a static library. It is also possible to give the path to a custom template. Additional parameters: - --template <path> indicate an alternative template to use. c3c init hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.c3p \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world build build [target] Build the project in the current path. It doesn't matter where in the project structure you are. The built in templates define two targets: debug (which is the default) and release . clean clean build-run build-run [target] Build the target (if needed) and run the executable. clean-run clean-run [target] Clean, build and run the target. dist dist [target] Clean, build and package the target. docs docs [target] Rebuilds the documentation. bench bench [target] Runs benchmarks on a target.","title":"Commands"},{"location":"buildcommands/#build-commands","text":"When starting out, with C3 it's natural to use run to try things out. For larger projects, the built-in build system is instead recommended. By default the compiler is compiling stand-alone files to output an executable binary. c3c <file1> <file2> <file3>","title":"Build Commands"},{"location":"buildcommands/#run","text":"The run command works same as compilation, but also immediately runs the resulting executable. c3c run <file1> <file2> <file3>","title":"run"},{"location":"buildcommands/#common-additional-parameters","text":"Additional parameters: - --lib <path> add a library to search. - --output <path> override the output directory. - --path <path> execute as if standing at","title":"Common additional parameters"},{"location":"buildcommands/#init","text":"c3c init <project_name> [optional path] . Create a new project structure in the current directory. Use the --template to select a template. The following are built in: default - the default template, produces an executable. lib - template for producing a library. staticlib - template for producing a static library. It is also possible to give the path to a custom template. Additional parameters: - --template <path> indicate an alternative template to use. c3c init hello_world will create the following structure: $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 lib \u251c\u2500\u2500 project.c3p \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 hello_world \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test \u2514\u2500\u2500 hello_world","title":"init"},{"location":"buildcommands/#build","text":"build [target] Build the project in the current path. It doesn't matter where in the project structure you are. The built in templates define two targets: debug (which is the default) and release .","title":"build"},{"location":"buildcommands/#clean","text":"clean","title":"clean"},{"location":"buildcommands/#build-run","text":"build-run [target] Build the target (if needed) and run the executable.","title":"build-run"},{"location":"buildcommands/#clean-run","text":"clean-run [target] Clean, build and run the target.","title":"clean-run"},{"location":"buildcommands/#dist","text":"dist [target] Clean, build and package the target.","title":"dist"},{"location":"buildcommands/#docs","text":"docs [target] Rebuilds the documentation.","title":"docs"},{"location":"buildcommands/#bench","text":"bench [target] Runs benchmarks on a target.","title":"bench"},{"location":"buildintro/","text":"Build System Building a project is done by invoking the C3 compiler with the build or run command inside of the project structure. The compiler will search upwards in the file hierachy until a project.c3p file is found.","title":"Introduction"},{"location":"buildintro/#build-system","text":"Building a project is done by invoking the C3 compiler with the build or run command inside of the project structure. The compiler will search upwards in the file hierachy until a project.c3p file is found.","title":"Build System"},{"location":"builtins/","text":"Builtins The compiler offers builtin constants and functions. Some are only available on certain targets. All builtins use the $$ name prefix. Builtin constants These can all safely be used by the user. $$DATE The current date. $$FILE The current file name. $$FILEPATH The current file with path. $$FUNC The current function name, will return \" \" on the global level. $$FUNCTION The current function as an expression. $$LINE The current line as an integer. $$LINE_RAW Usually the same as $$LINE, but in case of a macro inclusion it returns the line in the macro rather than the line where the macro was included. $$MODULE The current module name. $$TEST_NAMES An array of names of the test functions. $$TEST_FNS An array of addresses to the test functions. $$TIME The current time. Builtin functions These functions are not guaranteed to exist on all platforms. They are intended for standard library internal use, and typically the standard library has macros that wrap these builtins, so they should not be used on its own. $$trap Emits a trap instruction. $$unreachable Inserts an \"unreachable\" annotation. $$stacktrace Returns the current \"callstack\" reference if available. Compiler dependent. $$volatile_store Takes a variable and a value and stores the value as a volatile store. $$volatile_load Takes a variable and returns the value using a volatile load. $$memcpy Builtin memcpy instruction. $$memset Builtin memset instruction. $$prefetch Prefetch a memory location. $$sysclock Access to the cycle counter register (or similar low latency clock) on supported architectures (e.g. RDTSC on x86), otherwise $$sysclock will yield 0. $$syscall Makes a syscall according to the platform convention on platforms where it is supported. Math functions Functions $$ceil , $$trunc , $$sin , $$cos , $$log , $$log2 , $$log10 , $$rint , $$round $$sqrt , $$roundeven , $$floor , $$sqrt , $$pow , $$exp , $$fma and $$fabs , $$copysign , $$round , $$nearbyint . Can be applied to float vectors or numbers. Returns the same type. Functions $$min , $$abs and $$max can be applied to any integer or float number or vector. Function $pow_int takes a float or floating vector + an integer and returns the same type as the first parameter. Saturated addition, subtraction and left shift for integers and integer vectors: $$sat_add , $$sat_shl , $$sat_sub . Bit functions $$fshl and $$fshr Funnel shift left and right, takes either two integers or two integer vectors. $$ctz, $$clz, $$bitreverse, $$bswap, $$popcount Bit functions work on an integer or an integer vector. Vector functions $$reduce_add , $$reduce_mul , $$reduce_and , $$reduce_or , $$reduce_xor work on integer vectors. $$reduce_fadd , $$reduce_fmul works on float vectors. $$reduce_max , $$reduce_min works on any vector. $$reverse reverses the values in any vector. $$shufflevector rearranges the values of two vectors using a fixed mask into a resulting vector.","title":"Builtins"},{"location":"builtins/#builtins","text":"The compiler offers builtin constants and functions. Some are only available on certain targets. All builtins use the $$ name prefix.","title":"Builtins"},{"location":"builtins/#builtin-constants","text":"These can all safely be used by the user.","title":"Builtin constants"},{"location":"builtins/#date","text":"The current date.","title":"$$DATE"},{"location":"builtins/#file","text":"The current file name.","title":"$$FILE"},{"location":"builtins/#filepath","text":"The current file with path.","title":"$$FILEPATH"},{"location":"builtins/#func","text":"The current function name, will return \" \" on the global level.","title":"$$FUNC"},{"location":"builtins/#function","text":"The current function as an expression.","title":"$$FUNCTION"},{"location":"builtins/#line","text":"The current line as an integer.","title":"$$LINE"},{"location":"builtins/#line_raw","text":"Usually the same as $$LINE, but in case of a macro inclusion it returns the line in the macro rather than the line where the macro was included.","title":"$$LINE_RAW"},{"location":"builtins/#module","text":"The current module name.","title":"$$MODULE"},{"location":"builtins/#test_names","text":"An array of names of the test functions.","title":"$$TEST_NAMES"},{"location":"builtins/#test_fns","text":"An array of addresses to the test functions.","title":"$$TEST_FNS"},{"location":"builtins/#time","text":"The current time.","title":"$$TIME"},{"location":"builtins/#builtin-functions","text":"These functions are not guaranteed to exist on all platforms. They are intended for standard library internal use, and typically the standard library has macros that wrap these builtins, so they should not be used on its own.","title":"Builtin functions"},{"location":"builtins/#trap","text":"Emits a trap instruction.","title":"$$trap"},{"location":"builtins/#unreachable","text":"Inserts an \"unreachable\" annotation.","title":"$$unreachable"},{"location":"builtins/#stacktrace","text":"Returns the current \"callstack\" reference if available. Compiler dependent.","title":"$$stacktrace"},{"location":"builtins/#volatile_store","text":"Takes a variable and a value and stores the value as a volatile store.","title":"$$volatile_store"},{"location":"builtins/#volatile_load","text":"Takes a variable and returns the value using a volatile load.","title":"$$volatile_load"},{"location":"builtins/#memcpy","text":"Builtin memcpy instruction.","title":"$$memcpy"},{"location":"builtins/#memset","text":"Builtin memset instruction.","title":"$$memset"},{"location":"builtins/#prefetch","text":"Prefetch a memory location.","title":"$$prefetch"},{"location":"builtins/#sysclock","text":"Access to the cycle counter register (or similar low latency clock) on supported architectures (e.g. RDTSC on x86), otherwise $$sysclock will yield 0.","title":"$$sysclock"},{"location":"builtins/#syscall","text":"Makes a syscall according to the platform convention on platforms where it is supported.","title":"$$syscall"},{"location":"builtins/#math-functions","text":"Functions $$ceil , $$trunc , $$sin , $$cos , $$log , $$log2 , $$log10 , $$rint , $$round $$sqrt , $$roundeven , $$floor , $$sqrt , $$pow , $$exp , $$fma and $$fabs , $$copysign , $$round , $$nearbyint . Can be applied to float vectors or numbers. Returns the same type. Functions $$min , $$abs and $$max can be applied to any integer or float number or vector. Function $pow_int takes a float or floating vector + an integer and returns the same type as the first parameter. Saturated addition, subtraction and left shift for integers and integer vectors: $$sat_add , $$sat_shl , $$sat_sub .","title":"Math functions"},{"location":"builtins/#bit-functions","text":"","title":"Bit functions"},{"location":"builtins/#fshl-and-fshr","text":"Funnel shift left and right, takes either two integers or two integer vectors.","title":"$$fshl and $$fshr"},{"location":"builtins/#ctz-clz-bitreverse-bswap-popcount","text":"Bit functions work on an integer or an integer vector.","title":"$$ctz, $$clz, $$bitreverse, $$bswap, $$popcount"},{"location":"builtins/#vector-functions","text":"$$reduce_add , $$reduce_mul , $$reduce_and , $$reduce_or , $$reduce_xor work on integer vectors. $$reduce_fadd , $$reduce_fmul works on float vectors. $$reduce_max , $$reduce_min works on any vector. $$reverse reverses the values in any vector. $$shufflevector rearranges the values of two vectors using a fixed mask into a resulting vector.","title":"Vector functions"},{"location":"changes/","text":"Change log Revision 2023-01-24 Consistently use printfn rather than printfln Added short function syntax. Added lambdas . Revision 2023-01-07 Direct download links added. Prefer \"String\" over char[] Revision 2022-12-28 Bitstruct documented. Revision 2022-11-18 Documented inline asm. Revision 2022-11-16 Move description of static initialize. Info on operator overload. More details on function pointers. Updated project tree. Revision 2022-11-07 Added information on enum associated values. Revision 2022-10-31 Updated project.json description. Added information about static initializers and finalizers. Revision 2022-10-14 libc::printf replaced with io::printf Revision 2022-10-01 Expanded and updated types . Revision 2022-07-20 Added start + len syntax Revision 2022-07-15 Added \"builtins\" Revision 2022-06-30 Updates to module system Revision 2022-04-05 Removal of @opaque . Revision 2022-03-26 Remove escape macros. Adding stringify and first class names. Removing \"?? jump\" Revision 2022-03-15 Removal of multi-line strings Revision 2022-03-04 Updates to $sizeof. Addition of $eval / $evaltype. Removal of $unreachable. Revision 2022-02-16 Updates to imports. Updates to project files. Revision 2022-02-09 Major revision to bring everything up to date. Revision 2021-10-20 func replaced by fn Compound literal now Type { ... } like C++. Update of conversion rules New error syntax Revision 2021-08-27 Updated reflection functionality. Added documentation for multi-line strings. Added documentation for base64 and hex array literals. Revision 2021-08-12 Updated error type and error handling with try/catch Revision 2021-07-13 Added nesting to / ... / removed /+ ... +/ Added primer. Revision 2021-06-20 Updated array layout. Revised macros for foreach. Removed old generic functions. Added new ideas around generic, macros Changed macro body definition syntax. Introduced both $for and $foreach. Revision 2021-05-31 Removal of vararray type. Updated user defined attributes. Removed incremental arrays. Added information on define . Added private modules and import. Revision 2021-05-18 Change cast to (type)(expression) Revision 2021-05-08 Added rationale for some changes from C. Updated undefined and undefined behaviour . Removed many of the fine grained module features. Removed \"local\" visibility in modules . All modules are now distinct, parent modules do not have any special access to sub modules. Added as module imports. Revision 2021-04-05 \"next\" is now \"nextcase\". Added link to the C3 discord. The conversions page updated with new conversion rules. Updated compound literal syntax. Removed undefined behaviour behaviour on integer overflow and added a list of unspecified behaviour. Revision 2020-12-23 Updated slice behaviour. Updated expression block syntax. Added link to specification-in-progress. Revision 2020-12-04 Local variables are implicitly zero. Removed in-block declarations. Changed struct member initialization syntax. Changed named parameter syntax. Updated on macro syntax. Removed built in c types. Revision 2020-08-22 Added slice operations. Changed cast syntax to cast(<expr> as <type>) . Revision 2020-07-08 Additions to error handling . Introduction of labelled nextcase , break and continue . Removal of goto . Revision 2020-06-17 Alternate casts in idea . Method functions simply renamed to \"method\". Completely revised error handling . Revision 2020-04-23 Updated error handling, adding try-else-jump and changed how errors are passed. Included reflection page Revision 2020-03-30 Added Odin and D to comparisons. Updated text on how to contribute. Updated the example on undefined behaviour. Updated text on conversions. Moved double -> float conversion to \"ideas\" Fixed some typos. Revision 2020-03-29 Type inference for enums. Included macro page. Corrected precedence rules with try and @ . Type functions. Managed variables back to ideas. Volatile moved back to ideas. Removed implicit lossy signed conversions. Introducing safe signed-unsigned comparisons. \"Function block\" renamed \"expression block\". @ sigil removed from macros and is only used with macro invocations. Changed cast syntax from @cast(Type, var) to cast(var, Type) Revision 2019-12-26 Added module versioning system idea . Fleshed out polymorphic functions. Unsigned to signed promotion mentioned in \"changes from C\" Revision 2019-12-25 Changes how generic modules work. Switched so that vararrays use Type[*] and sub arrays use Type[] . Added sub module granularity, partial imports (only importing selected functions and types), removal of local , extended aliasing. See modules . Updated \"changes from C\" with removal of multiple declarations. Revision 2019-12-11 Updated the setup page. Revision 2019-12-03 Added page on conversions . Added page on undefined behaviour . Revision 2019-11-01 Updated \"changes from C\" with the lack of array decays. Added FourCC to the language Added name alias to ideas Added align asserts to ideas Added built in tests to ideas Added arrays page Added function blocks to statements page . Added expressions page . Added variables page . Moved managed pointers from idea to the variables page . Revision 2019-09-30 Removed references (non nullable pointers) Removed idea with aliasing in import Revision 2019-08-14 Compile time run-include and include ideas. New module system idea. Revision 2019-08-14 Namespace separator changed to :: instead of . to simplify parsing. Added FourCC, Macro text interpolation to ideas. Added Yacc grammar (incomplete) Added \"attribute\" keyword. Changed type alias declaration to use typedef ... as ... . Introduced type operator. Added section about attributes. Revision 2019-08-02 Added error example. Added generics example. Added method function example. Added idea implicit method functions Expanded the types page somewhat. Revision 2019-07-30 Added default and named arguments to the functions page . Added varargs to the functions page . Added idea about hierarchal memory. Added idea of raw dynamic safe arrays & strings. Volatile sections are no longer prefixed by '@' Added idea regarding c3 interop Added page about c interop . Removed c_ichar and c_uchar types as they are redundant. Updates to keywords on the grammar page ../syntax). Revision 2019-07-27 Updated grammar with keywords. Added the docs & comments page. Updated the pre and post conditions . Revision 2019-07-24 Idea: typed varargs. Added \"pure\" post condition Updated c3c commands. Removed the type keyword for defining union/struct/enum/error. Revision 2019-07-23 Added to generic functions examples for [] and []= Developed ideas about vectors in the idea section . Defined 2's complement for signed integers. Idea: Managed pointers. Updated naming rules for types. Added more naming rules + examples of them. Removed \"defer on function signatures\" from ideas. Removed \"managed qualifier\" from ideas. Removed \"defer sugar\" from ideas. Removed \"built in dynamic arrays\" from ideas. Added standard_library section. Added more about pre and post conditions . Revision 2019-07-22 Added \"Design Principles\" to the index page. Revision 2019-07-21 \"return\" rather than function name is used in post conditions. See Functions Added \"@include\" macro for textual includes. See Modules . Files to without module for single file compilations is now ok as a special case. See Modules Added cone style array idea to the idea section . Added idea about defer on error to the idea section . Added idea for aliasing generic structs in the import to the idea section . Added idea for changing automatic signed <-> unsigned conversion to the idea section . Added Changes from C and Statements sections. Removal of volatile . See Changes from C and Statements Removal of const See Changes from C","title":"Changes"},{"location":"changes/#change-log","text":"","title":"Change log"},{"location":"changes/#revision-2023-01-24","text":"Consistently use printfn rather than printfln Added short function syntax. Added lambdas .","title":"Revision 2023-01-24"},{"location":"changes/#revision-2023-01-07","text":"Direct download links added. Prefer \"String\" over char[]","title":"Revision 2023-01-07"},{"location":"changes/#revision-2022-12-28","text":"Bitstruct documented.","title":"Revision 2022-12-28"},{"location":"changes/#revision-2022-11-18","text":"Documented inline asm.","title":"Revision 2022-11-18"},{"location":"changes/#revision-2022-11-16","text":"Move description of static initialize. Info on operator overload. More details on function pointers. Updated project tree.","title":"Revision 2022-11-16"},{"location":"changes/#revision-2022-11-07","text":"Added information on enum associated values.","title":"Revision 2022-11-07"},{"location":"changes/#revision-2022-10-31","text":"Updated project.json description. Added information about static initializers and finalizers.","title":"Revision 2022-10-31"},{"location":"changes/#revision-2022-10-14","text":"libc::printf replaced with io::printf","title":"Revision 2022-10-14"},{"location":"changes/#revision-2022-10-01","text":"Expanded and updated types .","title":"Revision 2022-10-01"},{"location":"changes/#revision-2022-07-20","text":"Added start + len syntax","title":"Revision 2022-07-20"},{"location":"changes/#revision-2022-07-15","text":"Added \"builtins\"","title":"Revision 2022-07-15"},{"location":"changes/#revision-2022-06-30","text":"Updates to module system","title":"Revision 2022-06-30"},{"location":"changes/#revision-2022-04-05","text":"Removal of @opaque .","title":"Revision 2022-04-05"},{"location":"changes/#revision-2022-03-26","text":"Remove escape macros. Adding stringify and first class names. Removing \"?? jump\"","title":"Revision 2022-03-26"},{"location":"changes/#revision-2022-03-15","text":"Removal of multi-line strings","title":"Revision 2022-03-15"},{"location":"changes/#revision-2022-03-04","text":"Updates to $sizeof. Addition of $eval / $evaltype. Removal of $unreachable.","title":"Revision 2022-03-04"},{"location":"changes/#revision-2022-02-16","text":"Updates to imports. Updates to project files.","title":"Revision 2022-02-16"},{"location":"changes/#revision-2022-02-09","text":"Major revision to bring everything up to date.","title":"Revision 2022-02-09"},{"location":"changes/#revision-2021-10-20","text":"func replaced by fn Compound literal now Type { ... } like C++. Update of conversion rules New error syntax","title":"Revision 2021-10-20"},{"location":"changes/#revision-2021-08-27","text":"Updated reflection functionality. Added documentation for multi-line strings. Added documentation for base64 and hex array literals.","title":"Revision 2021-08-27"},{"location":"changes/#revision-2021-08-12","text":"Updated error type and error handling with try/catch","title":"Revision 2021-08-12"},{"location":"changes/#revision-2021-07-13","text":"Added nesting to / ... / removed /+ ... +/ Added primer.","title":"Revision 2021-07-13"},{"location":"changes/#revision-2021-06-20","text":"Updated array layout. Revised macros for foreach. Removed old generic functions. Added new ideas around generic, macros Changed macro body definition syntax. Introduced both $for and $foreach.","title":"Revision 2021-06-20"},{"location":"changes/#revision-2021-05-31","text":"Removal of vararray type. Updated user defined attributes. Removed incremental arrays. Added information on define . Added private modules and import.","title":"Revision 2021-05-31"},{"location":"changes/#revision-2021-05-18","text":"Change cast to (type)(expression)","title":"Revision 2021-05-18"},{"location":"changes/#revision-2021-05-08","text":"Added rationale for some changes from C. Updated undefined and undefined behaviour . Removed many of the fine grained module features. Removed \"local\" visibility in modules . All modules are now distinct, parent modules do not have any special access to sub modules. Added as module imports.","title":"Revision 2021-05-08"},{"location":"changes/#revision-2021-04-05","text":"\"next\" is now \"nextcase\". Added link to the C3 discord. The conversions page updated with new conversion rules. Updated compound literal syntax. Removed undefined behaviour behaviour on integer overflow and added a list of unspecified behaviour.","title":"Revision 2021-04-05"},{"location":"changes/#revision-2020-12-23","text":"Updated slice behaviour. Updated expression block syntax. Added link to specification-in-progress.","title":"Revision 2020-12-23"},{"location":"changes/#revision-2020-12-04","text":"Local variables are implicitly zero. Removed in-block declarations. Changed struct member initialization syntax. Changed named parameter syntax. Updated on macro syntax. Removed built in c types.","title":"Revision 2020-12-04"},{"location":"changes/#revision-2020-08-22","text":"Added slice operations. Changed cast syntax to cast(<expr> as <type>) .","title":"Revision 2020-08-22"},{"location":"changes/#revision-2020-07-08","text":"Additions to error handling . Introduction of labelled nextcase , break and continue . Removal of goto .","title":"Revision 2020-07-08"},{"location":"changes/#revision-2020-06-17","text":"Alternate casts in idea . Method functions simply renamed to \"method\". Completely revised error handling .","title":"Revision 2020-06-17"},{"location":"changes/#revision-2020-04-23","text":"Updated error handling, adding try-else-jump and changed how errors are passed. Included reflection page","title":"Revision 2020-04-23"},{"location":"changes/#revision-2020-03-30","text":"Added Odin and D to comparisons. Updated text on how to contribute. Updated the example on undefined behaviour. Updated text on conversions. Moved double -> float conversion to \"ideas\" Fixed some typos.","title":"Revision 2020-03-30"},{"location":"changes/#revision-2020-03-29","text":"Type inference for enums. Included macro page. Corrected precedence rules with try and @ . Type functions. Managed variables back to ideas. Volatile moved back to ideas. Removed implicit lossy signed conversions. Introducing safe signed-unsigned comparisons. \"Function block\" renamed \"expression block\". @ sigil removed from macros and is only used with macro invocations. Changed cast syntax from @cast(Type, var) to cast(var, Type)","title":"Revision 2020-03-29"},{"location":"changes/#revision-2019-12-26","text":"Added module versioning system idea . Fleshed out polymorphic functions. Unsigned to signed promotion mentioned in \"changes from C\"","title":"Revision 2019-12-26"},{"location":"changes/#revision-2019-12-25","text":"Changes how generic modules work. Switched so that vararrays use Type[*] and sub arrays use Type[] . Added sub module granularity, partial imports (only importing selected functions and types), removal of local , extended aliasing. See modules . Updated \"changes from C\" with removal of multiple declarations.","title":"Revision 2019-12-25"},{"location":"changes/#revision-2019-12-11","text":"Updated the setup page.","title":"Revision 2019-12-11"},{"location":"changes/#revision-2019-12-03","text":"Added page on conversions . Added page on undefined behaviour .","title":"Revision 2019-12-03"},{"location":"changes/#revision-2019-11-01","text":"Updated \"changes from C\" with the lack of array decays. Added FourCC to the language Added name alias to ideas Added align asserts to ideas Added built in tests to ideas Added arrays page Added function blocks to statements page . Added expressions page . Added variables page . Moved managed pointers from idea to the variables page .","title":"Revision 2019-11-01"},{"location":"changes/#revision-2019-09-30","text":"Removed references (non nullable pointers) Removed idea with aliasing in import","title":"Revision 2019-09-30"},{"location":"changes/#revision-2019-08-14","text":"Compile time run-include and include ideas. New module system idea.","title":"Revision 2019-08-14"},{"location":"changes/#revision-2019-08-14_1","text":"Namespace separator changed to :: instead of . to simplify parsing. Added FourCC, Macro text interpolation to ideas. Added Yacc grammar (incomplete) Added \"attribute\" keyword. Changed type alias declaration to use typedef ... as ... . Introduced type operator. Added section about attributes.","title":"Revision 2019-08-14"},{"location":"changes/#revision-2019-08-02","text":"Added error example. Added generics example. Added method function example. Added idea implicit method functions Expanded the types page somewhat.","title":"Revision 2019-08-02"},{"location":"changes/#revision-2019-07-30","text":"Added default and named arguments to the functions page . Added varargs to the functions page . Added idea about hierarchal memory. Added idea of raw dynamic safe arrays & strings. Volatile sections are no longer prefixed by '@' Added idea regarding c3 interop Added page about c interop . Removed c_ichar and c_uchar types as they are redundant. Updates to keywords on the grammar page ../syntax).","title":"Revision 2019-07-30"},{"location":"changes/#revision-2019-07-27","text":"Updated grammar with keywords. Added the docs & comments page. Updated the pre and post conditions .","title":"Revision 2019-07-27"},{"location":"changes/#revision-2019-07-24","text":"Idea: typed varargs. Added \"pure\" post condition Updated c3c commands. Removed the type keyword for defining union/struct/enum/error.","title":"Revision 2019-07-24"},{"location":"changes/#revision-2019-07-23","text":"Added to generic functions examples for [] and []= Developed ideas about vectors in the idea section . Defined 2's complement for signed integers. Idea: Managed pointers. Updated naming rules for types. Added more naming rules + examples of them. Removed \"defer on function signatures\" from ideas. Removed \"managed qualifier\" from ideas. Removed \"defer sugar\" from ideas. Removed \"built in dynamic arrays\" from ideas. Added standard_library section. Added more about pre and post conditions .","title":"Revision 2019-07-23"},{"location":"changes/#revision-2019-07-22","text":"Added \"Design Principles\" to the index page.","title":"Revision 2019-07-22"},{"location":"changes/#revision-2019-07-21","text":"\"return\" rather than function name is used in post conditions. See Functions Added \"@include\" macro for textual includes. See Modules . Files to without module for single file compilations is now ok as a special case. See Modules Added cone style array idea to the idea section . Added idea about defer on error to the idea section . Added idea for aliasing generic structs in the import to the idea section . Added idea for changing automatic signed <-> unsigned conversion to the idea section . Added Changes from C and Statements sections. Removal of volatile . See Changes from C and Statements Removal of const See Changes from C","title":"Revision 2019-07-21"},{"location":"changesfromc/","text":"Changes from C Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes: No mandatory header files There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications. Removal of the old C macro system The old C macro system is replaced by a new C3 macro system. Import and modules C3 uses module imports instead of header includes to link modules together. Member access using . even for pointers The -> operator is removed, access uses dot for both direct and pointer access. Note that this is just single access: to access a pointer of a pointer (e.g. int** ) an explicit dereference would be needed. Different operator precedence Notably bit operations have higher precedence than +/-, making code like this: a & b == c evaluate like (a & b) == c instead of C's a & (b == c) . See the page about precedence rules . Removal of the const type qualifier The const qualifier is only retained for actual constant variables. C3 uses a special type of post condition for functions to indicate that they do not alter in parameters. /** * This function ensures that foo is not changed in the function. * @param [in] foo * @param [out] bar **/ fn void test(Foo* foo, Bar* bar) { bar.y = foo.x; // foo.x = foo.x + 1 - compile time error, can't write to 'in' param. // int x = bar.y - compile time error, can't read from an 'out' param. } Rationale: const correctness requires littering const across the code base. Although const is useful, it provides weaker guarantees that it appears. Fixed arrays do not decay and have copy semantics C3 has three different array types. Variable arrays and slices decay to pointers, but fixed arrays are value objects and do not decay. int[3] a = { 1, 2, 3 }; int[4]* b = &a; // No conversion int* c = a; // ERROR int* d = &a; // Valid implicit conversion int* e = b; // Valid implicit conversion int[3] f = a; // Copy by value! Removal of multiple declaration syntax Only a single declaration is allowed per statement in C3: int i, j; // ERROR int a; // Fine In conditionals, a special form of multiple declarations are allowed but each must then provide its type: for (int i = 0, int j = 1; i < 10; i++, j++) { ... } Integer promotions rules and safe signed-unsigned comparisons Promotion rules for integer types are different from C. Most prominently, C3 does left side widening in the case of long x = intValue1 + intValue2 . In C this becomes: long x = (long)(intValue1 + intValue2) , whereas in C3 it would behaves as long x = (long)intValue1 + (long)intValue2 to minimize chance of overflow. (read more on the conversion page . C3 also adds safe signed-unsigned comparisons : this means that comparing signed and unsigned values will always yield the correct result: // The code below will print \"Hello C3!\" on C3 and \"Hello C!\" in C. int i = -1; uint j = 1; // int z = i + j; <- Error, explicit cast needed. if (i < j) { printf(\"Hello C3!\\n\"); } else { printf(\"Hello C!\\n\"); } Goto removed goto is removed and replaced with labelled break and continue together with the nextcase statement that allows you to jump between cases in a switch statement. Rationale: It is very difficult to make goto work well with defer and implicit unwrapping of optional results. It is not just making the compiler harder to write, but the code is harder to understand as well. The replacements together with defer cover many if not all usages of goto in regular code. Implicit break in switches Empty case statements have implicit fall through in C3, otherwise the nextcase statement is needed nextcase can also be used to jump to any other case statement in the switch. switch (h) { case 1: a = 1; nextcase; // Fall through case 2: b = 123; case 3: a = 2; nextcase 2; // Jump to case 2 default: a = 111; } Locals variables are implictly zeroed In C global variables are implicitly zeroed out, but local variables aren't. In C3 local variables are zeroed out by default, but may be explicitly undefined to get the C behaviour. Rationale: In the \"zero-is-initialization\" paradigm, zeroing variables, in particular structs, is very common. By offering zero initialization by default this avoids a whole class of vulnerabilites. Another alternative that was considered for C3 was mandatory initialization, but this adds a lot of extra boilerplate. C3 also offers a way to opt out of zero-initialization, so the change comes at no performance loss. Compound literal syntax changed // C style: callFoo((Foo) { 1, 2, 3 }); // C++ style (1): callFoo(Foo(1, 2, 3)); // C++ style (2): callFoo(Foo { 1, 2, 3 }); // C3: callFoo(Foo { 1, 2, 3 } );","title":"Changes from C"},{"location":"changesfromc/#changes-from-c","text":"Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes:","title":"Changes from C"},{"location":"changesfromc/#no-mandatory-header-files","text":"There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications.","title":"No mandatory header files"},{"location":"changesfromc/#removal-of-the-old-c-macro-system","text":"The old C macro system is replaced by a new C3 macro system.","title":"Removal of the old C macro system"},{"location":"changesfromc/#import-and-modules","text":"C3 uses module imports instead of header includes to link modules together.","title":"Import and modules"},{"location":"changesfromc/#member-access-using-even-for-pointers","text":"The -> operator is removed, access uses dot for both direct and pointer access. Note that this is just single access: to access a pointer of a pointer (e.g. int** ) an explicit dereference would be needed.","title":"Member access using . even for pointers"},{"location":"changesfromc/#different-operator-precedence","text":"Notably bit operations have higher precedence than +/-, making code like this: a & b == c evaluate like (a & b) == c instead of C's a & (b == c) . See the page about precedence rules .","title":"Different operator precedence"},{"location":"changesfromc/#removal-of-the-const-type-qualifier","text":"The const qualifier is only retained for actual constant variables. C3 uses a special type of post condition for functions to indicate that they do not alter in parameters. /** * This function ensures that foo is not changed in the function. * @param [in] foo * @param [out] bar **/ fn void test(Foo* foo, Bar* bar) { bar.y = foo.x; // foo.x = foo.x + 1 - compile time error, can't write to 'in' param. // int x = bar.y - compile time error, can't read from an 'out' param. } Rationale: const correctness requires littering const across the code base. Although const is useful, it provides weaker guarantees that it appears.","title":"Removal of the const type qualifier"},{"location":"changesfromc/#fixed-arrays-do-not-decay-and-have-copy-semantics","text":"C3 has three different array types. Variable arrays and slices decay to pointers, but fixed arrays are value objects and do not decay. int[3] a = { 1, 2, 3 }; int[4]* b = &a; // No conversion int* c = a; // ERROR int* d = &a; // Valid implicit conversion int* e = b; // Valid implicit conversion int[3] f = a; // Copy by value!","title":"Fixed arrays do not decay and have copy semantics"},{"location":"changesfromc/#removal-of-multiple-declaration-syntax","text":"Only a single declaration is allowed per statement in C3: int i, j; // ERROR int a; // Fine In conditionals, a special form of multiple declarations are allowed but each must then provide its type: for (int i = 0, int j = 1; i < 10; i++, j++) { ... }","title":"Removal of multiple declaration syntax"},{"location":"changesfromc/#integer-promotions-rules-and-safe-signed-unsigned-comparisons","text":"Promotion rules for integer types are different from C. Most prominently, C3 does left side widening in the case of long x = intValue1 + intValue2 . In C this becomes: long x = (long)(intValue1 + intValue2) , whereas in C3 it would behaves as long x = (long)intValue1 + (long)intValue2 to minimize chance of overflow. (read more on the conversion page . C3 also adds safe signed-unsigned comparisons : this means that comparing signed and unsigned values will always yield the correct result: // The code below will print \"Hello C3!\" on C3 and \"Hello C!\" in C. int i = -1; uint j = 1; // int z = i + j; <- Error, explicit cast needed. if (i < j) { printf(\"Hello C3!\\n\"); } else { printf(\"Hello C!\\n\"); }","title":"Integer promotions rules and safe signed-unsigned comparisons"},{"location":"changesfromc/#goto-removed","text":"goto is removed and replaced with labelled break and continue together with the nextcase statement that allows you to jump between cases in a switch statement. Rationale: It is very difficult to make goto work well with defer and implicit unwrapping of optional results. It is not just making the compiler harder to write, but the code is harder to understand as well. The replacements together with defer cover many if not all usages of goto in regular code.","title":"Goto removed"},{"location":"changesfromc/#implicit-break-in-switches","text":"Empty case statements have implicit fall through in C3, otherwise the nextcase statement is needed nextcase can also be used to jump to any other case statement in the switch. switch (h) { case 1: a = 1; nextcase; // Fall through case 2: b = 123; case 3: a = 2; nextcase 2; // Jump to case 2 default: a = 111; }","title":"Implicit break in switches"},{"location":"changesfromc/#locals-variables-are-implictly-zeroed","text":"In C global variables are implicitly zeroed out, but local variables aren't. In C3 local variables are zeroed out by default, but may be explicitly undefined to get the C behaviour. Rationale: In the \"zero-is-initialization\" paradigm, zeroing variables, in particular structs, is very common. By offering zero initialization by default this avoids a whole class of vulnerabilites. Another alternative that was considered for C3 was mandatory initialization, but this adds a lot of extra boilerplate. C3 also offers a way to opt out of zero-initialization, so the change comes at no performance loss.","title":"Locals variables are implictly zeroed"},{"location":"changesfromc/#compound-literal-syntax-changed","text":"// C style: callFoo((Foo) { 1, 2, 3 }); // C++ style (1): callFoo(Foo(1, 2, 3)); // C++ style (2): callFoo(Foo { 1, 2, 3 }); // C3: callFoo(Foo { 1, 2, 3 } );","title":"Compound literal syntax changed"},{"location":"cinterop/","text":"C Interoperability C3 is C ABI compatible. That means you can call C from C3, and call C3 from C without having to do anything special. As a quick way to call C, you can simply declare the function as a C3 function but with extern in front of it. As long as the function is linked, it will work: extern fn void puts(char*); // C \"puts\" fn void main() { // This will call the \"puts\" // function in the standard c lib. puts(\"Hello, world!\"); } While C3 functions are available from C using their external name, it's often useful to define an external name using @extname to match C usage. module foo; fn int square(int x) { return x * x; } fn int square2(int x) @extname(\"square\") { return x * x; } Calling from C: extern int square(int); int foo_square(int) __attribute__ ((weak, alias (\"foo.square\"))); void test() { // This would call square2 printf(\"%d\\n\", square(11)); // This would call square printf(\"%d\\n\", foo_square(11)); } Gotchas Bitstructs will be seen as its underlying type from C. C3 cannot use C bit fields C assumes the enum size is CInt C3 uses fixed integer sizes, this means that int and CInt does not need to be the same. Passing arrays by value like in C3 must be represented as passing a struct containing the array. Atomic types are not supported by C3. Volatile and const have no representation in C3.","title":"C Interop"},{"location":"cinterop/#c-interoperability","text":"C3 is C ABI compatible. That means you can call C from C3, and call C3 from C without having to do anything special. As a quick way to call C, you can simply declare the function as a C3 function but with extern in front of it. As long as the function is linked, it will work: extern fn void puts(char*); // C \"puts\" fn void main() { // This will call the \"puts\" // function in the standard c lib. puts(\"Hello, world!\"); } While C3 functions are available from C using their external name, it's often useful to define an external name using @extname to match C usage. module foo; fn int square(int x) { return x * x; } fn int square2(int x) @extname(\"square\") { return x * x; } Calling from C: extern int square(int); int foo_square(int) __attribute__ ((weak, alias (\"foo.square\"))); void test() { // This would call square2 printf(\"%d\\n\", square(11)); // This would call square printf(\"%d\\n\", foo_square(11)); }","title":"C Interoperability"},{"location":"cinterop/#gotchas","text":"Bitstructs will be seen as its underlying type from C. C3 cannot use C bit fields C assumes the enum size is CInt C3 uses fixed integer sizes, this means that int and CInt does not need to be the same. Passing arrays by value like in C3 must be represented as passing a struct containing the array. Atomic types are not supported by C3. Volatile and const have no representation in C3.","title":"Gotchas"},{"location":"comments/","text":"Comments and docs C3 uses three distinct comment types: The normal // line comment, which is terminated at the end of the line. The classic /* ... */ C style comment, but unlike in C they are allowed to nest. Documentation comments /** ... **/ the text within these comments will be parsed as documentation and optional contracts on the following code. Documentation Documentation comments start with /** and must be terminated using */ . Note that any number of * may follow /** and any number of stars may preceed */ . Any space and * in the beginning of each line will be ignored. Here is an example: /** * Here are som docs. * @param foo The number of foos. * @required foo > 4 * @deprecated * @mycustom 2 **/ void bar(int foo) { printf(\"%d\", foo); } In the example above, the following is parsed as description: \"Here are the docs.\" , then there is a description associated with the foo parameter: \"The number of foos\" . On top of that there are two annotations for the compiler: @required foo > 4 which tells the compiler and a user of the function that a precondition is that foo must be greater than 4. It is also marked as @deprecated, which can be used to display warnings. Finally a custom annotation, \"@mycustom\" is added. The compiler is free to silently ignore such annotations, but can optionally emit warnings for them, it is otherwise ignored. Available annotations Name format @param @param <param> <description> @return @return <description> @fails @fails <description> @deprecated @deprecated <optional description> @require @require <expr1>, <expr2>, ... @ensure @ensure <expre1>, <expr2>, ... @pure @pure @checked @checked <expr1>, <expr2>, ... See contracts for information regarding @require , @ensure , @const , @pure , @checked .","title":"Comments & Docs"},{"location":"comments/#comments-and-docs","text":"C3 uses three distinct comment types: The normal // line comment, which is terminated at the end of the line. The classic /* ... */ C style comment, but unlike in C they are allowed to nest. Documentation comments /** ... **/ the text within these comments will be parsed as documentation and optional contracts on the following code.","title":"Comments and docs"},{"location":"comments/#documentation","text":"Documentation comments start with /** and must be terminated using */ . Note that any number of * may follow /** and any number of stars may preceed */ . Any space and * in the beginning of each line will be ignored. Here is an example: /** * Here are som docs. * @param foo The number of foos. * @required foo > 4 * @deprecated * @mycustom 2 **/ void bar(int foo) { printf(\"%d\", foo); } In the example above, the following is parsed as description: \"Here are the docs.\" , then there is a description associated with the foo parameter: \"The number of foos\" . On top of that there are two annotations for the compiler: @required foo > 4 which tells the compiler and a user of the function that a precondition is that foo must be greater than 4. It is also marked as @deprecated, which can be used to display warnings. Finally a custom annotation, \"@mycustom\" is added. The compiler is free to silently ignore such annotations, but can optionally emit warnings for them, it is otherwise ignored.","title":"Documentation"},{"location":"comments/#available-annotations","text":"Name format @param @param <param> <description> @return @return <description> @fails @fails <description> @deprecated @deprecated <optional description> @require @require <expr1>, <expr2>, ... @ensure @ensure <expre1>, <expr2>, ... @pure @pure @checked @checked <expr1>, <expr2>, ... See contracts for information regarding @require , @ensure , @const , @pure , @checked .","title":"Available annotations"},{"location":"compare/","text":"Language comparisons An important question to answer is \"How does C3 compare to other similar programming languages?\". Here is an extremely brief (and not yet complete) overview. C As C3 is an evolution of C, the languages are quite similar. C3 adds features, but also removes a few. In C3 but not in C Module system Integrated build system Generics Semantic Macros Error handling Defer Value methods Associated enum data Distinct types and subtypes Optional contracts Built-in subarrays Foreach for iteration over arrays and types In C but not in C3 Qualified types ( const , volatile etc) Unsafe implicit conversions C++ C++ is a complex object oriented \"almost superset\" of C. It tries to be everything to everyone, while squeezing this into a C syntax. The language is well known for its many pitfalls and quirky corners \u2013 as well as its long compile times. C3 is in many ways different from C++ in the same way that C is different from C++, but the semantic macro system and the generics close the gap in terms of writing reusable generic code. The C3 module system and error handling is also very different from how C++ does things. In C++ but not in C3 Objects and classes RAII Exceptions In C3 but not in C++ Module system (yet) Integrated build system Semantic macros Error handling Defer Associated enum data Built-in subarrays Rust Rust is a safe systems programming language. While not quite as complex as C++, it is still a feature rich programming language with semantic macros, traits and pattern matching to mention a few. Error handling is handled using Result and Optional which is similar to how C3 works. C3 compares to Rust much like C, although the presence of built-in subarrays and strings reduces the places where C3 is unsafe. Rust provides arrays and strings, but they are not built in. Subarrays are the same as Rust's slices. In Rust but not in C3 RAII Memory safety Safe union types with functions Different syntax from C Pattern matching Async built in In C3 but not in Rust Same ease of programming as C Optional contracts Familiar C syntax and behaviour Zig Zig is a systems programming language with extensive compile time execution to enable polymorphic functions and parameterized types. It aims to be a C replacement. Compared to C3, Zig tries to be a completely new language in terms of syntax and feel. C3 uses macros to a modest degree where it is more pervasive in Zig, and does not depart from C to the same degree. Like Rust, it features slices as a first class type. The standard library uses an explicit allocator to allow it to work with many different allocation strategies. Zig is a very ambitious project, aiming to support as many types of platforms as possible. In Zig but not in C3 Pervasive compile time execution. Memory allocation failure is an error. Toolchain uses build files written in native Zig. Different syntax and behaviour compared to C. Structs define namespace. Async primitives built in. Built in unit tests. Arbitrarily integer sizes. In C3 but not in Zig Module system. Integrated build system. C ABI compatibility by default. Optional contracts. Familiar C syntax and behaviour. Jai Jai is a programming language aimed at high performance game programming. It has an extensive compile time meta programming functionality, even to the point of being able to run programs at compile time. It also has compile time polymorphism, a powerful macro system and uses an implicit context system to switch allocation schemes. In Jai but not in C3 Pervasive compile time execution. Jai's compile time execution is the build system. Different syntax and behaviour compared to C. More powerful macro system than C3. Implicit constructors In C3 but not in Jai Module system Integrated build system Optional contracts Familiar C syntax and behaviour Fairly small language Odin Odin is a language built for high performance but tries to remain a simple language to learn. Superficially the syntax shares much with Jai, and some of Jai's features things \u2013 like an implicit context \u2013 also shows up in Odin. In contrast with both Jai and Zig, Odin uses only minimal compile time evaluation and instead only relies on parametric polymorphism to ensure reuse. It also contains conveniences, like maps and arrays built into the language. For error handling it relies on Go style tuple returns. In Odin but not in C3 Different syntax and behaviour compared to C Ad hoc parametric polymorphism Tuple returns A rich built in set of types In C3 but not in Odin Familiar C syntax and behaviour Semantic macros Value methods Optional contracts Error handling support D D is a huge language. Where C++ is big, D provides all that C++ does and adds anything else you might think of. There is very little you can't do in D that isn't supported one way or the other. The most impressive thing is that D does this with fewer syntactic quirks than C++. In D but not in C3 Objects and classes RAII Exceptions ... and a huge amount of features ... In C3 but not in D Small language that provides what you need and not more","title":"Comparisons with other languages"},{"location":"compare/#language-comparisons","text":"An important question to answer is \"How does C3 compare to other similar programming languages?\". Here is an extremely brief (and not yet complete) overview.","title":"Language comparisons"},{"location":"compare/#c","text":"As C3 is an evolution of C, the languages are quite similar. C3 adds features, but also removes a few.","title":"C"},{"location":"compare/#in-c3-but-not-in-c","text":"Module system Integrated build system Generics Semantic Macros Error handling Defer Value methods Associated enum data Distinct types and subtypes Optional contracts Built-in subarrays Foreach for iteration over arrays and types","title":"In C3 but not in C"},{"location":"compare/#in-c-but-not-in-c3","text":"Qualified types ( const , volatile etc) Unsafe implicit conversions","title":"In C but not in C3"},{"location":"compare/#c_1","text":"C++ is a complex object oriented \"almost superset\" of C. It tries to be everything to everyone, while squeezing this into a C syntax. The language is well known for its many pitfalls and quirky corners \u2013 as well as its long compile times. C3 is in many ways different from C++ in the same way that C is different from C++, but the semantic macro system and the generics close the gap in terms of writing reusable generic code. The C3 module system and error handling is also very different from how C++ does things.","title":"C++"},{"location":"compare/#in-c-but-not-in-c3_1","text":"Objects and classes RAII Exceptions","title":"In C++ but not in C3"},{"location":"compare/#in-c3-but-not-in-c_1","text":"Module system (yet) Integrated build system Semantic macros Error handling Defer Associated enum data Built-in subarrays","title":"In C3 but not in C++"},{"location":"compare/#rust","text":"Rust is a safe systems programming language. While not quite as complex as C++, it is still a feature rich programming language with semantic macros, traits and pattern matching to mention a few. Error handling is handled using Result and Optional which is similar to how C3 works. C3 compares to Rust much like C, although the presence of built-in subarrays and strings reduces the places where C3 is unsafe. Rust provides arrays and strings, but they are not built in. Subarrays are the same as Rust's slices.","title":"Rust"},{"location":"compare/#in-rust-but-not-in-c3","text":"RAII Memory safety Safe union types with functions Different syntax from C Pattern matching Async built in","title":"In Rust but not in C3"},{"location":"compare/#in-c3-but-not-in-rust","text":"Same ease of programming as C Optional contracts Familiar C syntax and behaviour","title":"In C3 but not in Rust"},{"location":"compare/#zig","text":"Zig is a systems programming language with extensive compile time execution to enable polymorphic functions and parameterized types. It aims to be a C replacement. Compared to C3, Zig tries to be a completely new language in terms of syntax and feel. C3 uses macros to a modest degree where it is more pervasive in Zig, and does not depart from C to the same degree. Like Rust, it features slices as a first class type. The standard library uses an explicit allocator to allow it to work with many different allocation strategies. Zig is a very ambitious project, aiming to support as many types of platforms as possible.","title":"Zig"},{"location":"compare/#in-zig-but-not-in-c3","text":"Pervasive compile time execution. Memory allocation failure is an error. Toolchain uses build files written in native Zig. Different syntax and behaviour compared to C. Structs define namespace. Async primitives built in. Built in unit tests. Arbitrarily integer sizes.","title":"In Zig but not in C3"},{"location":"compare/#in-c3-but-not-in-zig","text":"Module system. Integrated build system. C ABI compatibility by default. Optional contracts. Familiar C syntax and behaviour.","title":"In C3 but not in Zig"},{"location":"compare/#jai","text":"Jai is a programming language aimed at high performance game programming. It has an extensive compile time meta programming functionality, even to the point of being able to run programs at compile time. It also has compile time polymorphism, a powerful macro system and uses an implicit context system to switch allocation schemes.","title":"Jai"},{"location":"compare/#in-jai-but-not-in-c3","text":"Pervasive compile time execution. Jai's compile time execution is the build system. Different syntax and behaviour compared to C. More powerful macro system than C3. Implicit constructors","title":"In Jai but not in C3"},{"location":"compare/#in-c3-but-not-in-jai","text":"Module system Integrated build system Optional contracts Familiar C syntax and behaviour Fairly small language","title":"In C3 but not in Jai"},{"location":"compare/#odin","text":"Odin is a language built for high performance but tries to remain a simple language to learn. Superficially the syntax shares much with Jai, and some of Jai's features things \u2013 like an implicit context \u2013 also shows up in Odin. In contrast with both Jai and Zig, Odin uses only minimal compile time evaluation and instead only relies on parametric polymorphism to ensure reuse. It also contains conveniences, like maps and arrays built into the language. For error handling it relies on Go style tuple returns.","title":"Odin"},{"location":"compare/#in-odin-but-not-in-c3","text":"Different syntax and behaviour compared to C Ad hoc parametric polymorphism Tuple returns A rich built in set of types","title":"In Odin but not in C3"},{"location":"compare/#in-c3-but-not-in-odin","text":"Familiar C syntax and behaviour Semantic macros Value methods Optional contracts Error handling support","title":"In C3 but not in Odin"},{"location":"compare/#d","text":"D is a huge language. Where C++ is big, D provides all that C++ does and adds anything else you might think of. There is very little you can't do in D that isn't supported one way or the other. The most impressive thing is that D does this with fewer syntactic quirks than C++.","title":"D"},{"location":"compare/#in-d-but-not-in-c3","text":"Objects and classes RAII Exceptions ... and a huge amount of features ...","title":"In D but not in C3"},{"location":"compare/#in-c3-but-not-in-d","text":"Small language that provides what you need and not more","title":"In C3 but not in D"},{"location":"contracts/","text":"Contracts Contracts are optional pre and post conditions checks that the compiler may use for optimization and runtime checks. Note that compilers are not obliged to process pre and post conditions at all . However, violating either pre or post conditions is considered undefined behaviour, so a compiler may optimize as if they always hold \u2013 even if a potential bug may cause them to be violated. Pre conditions Pre conditions are usually used to validate incoming arguments. Each condition must be an expression that can be evaluated to a boolean. A pre condition use the @require annotation. /** * @require foo > 0, foo < 1000 **/ fn int testFoo(int foo) { return foo * 10; } Post conditions Post conditions are evaluated to make checks on the resulting state after passing through the function. The post condition uses the @ensure annotation. Where return is used to represent the return value from the function. /** * @require foo != null * @ensure return > foo.x **/ fn uint checkFoo(Foo* foo) { uint y = abs(foo.x) + 1; // If we had row: foo.x = 0, then this would be a compile time error. return y * abs(foo.x); } Parameter annotations @param supports [in] [out] and [inout] . These are only applicable for pointer arguments. [in] disallows writing to the variable, [out] disallows reading from the variable. Without an annotation, pointers may both be read from and written to without checks. Type readable? writable? use as \"in\"? use as \"out\"? use as \"inout\" no annotation Yes Yes Yes Yes Yes in Yes No Yes No No out No Yes No Yes No inout Yes Yes Yes Yes Yes However, it should be noted that the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: fn void badFunc(int* i) { *i = 2; } /** * @param [in] i */ fn void lyingFunc(int* i) { badFunc(i); // The compiler might not check this! } fn void test() { int a = 1; lyingFunc(&a); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: /** * @param [in] i */ fn void badFunc(int* i) { *i = 2; // <- Compiler error: cannot write to \"in\" parameter } Pure in detail The pure annotation allows a program to make assumtions in regards of how the function treats global variables. Unlike for const , a pure function is not allowed to call a function which is known to be impure. However, just like for const the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: int i = 0; type Secretfn fn void(); fn void badFunc() { i = 2; } Secretfn foo = nil; /** * @pure */ fn void lyingFunc() { SecretFunc(); // The compiler cannot reason about this! } fn void test() { foo = &badFunc; i = 1; lyingFunc(); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: int i = 0; fn void badFunc() { i = 2; } /** * @pure */ fn void lyingFunc() { badFunc(); // Error! Calling an impure function } Consequently circumventing \"pure\" annotations is undefined behaviour. Pre conditions for macros In order to check macros, it's often useful to use the builtin $checks function which returns true if the code inside would pass semantic checking. /** * @require $checks(resource.open()) `Expected resource to have an \"open\" function` * @require resource != nil * @require $checks(void *x = resource.open()) **/ macro openResource(resource) { return resource.open(); }","title":"Contracts"},{"location":"contracts/#contracts","text":"Contracts are optional pre and post conditions checks that the compiler may use for optimization and runtime checks. Note that compilers are not obliged to process pre and post conditions at all . However, violating either pre or post conditions is considered undefined behaviour, so a compiler may optimize as if they always hold \u2013 even if a potential bug may cause them to be violated.","title":"Contracts"},{"location":"contracts/#pre-conditions","text":"Pre conditions are usually used to validate incoming arguments. Each condition must be an expression that can be evaluated to a boolean. A pre condition use the @require annotation. /** * @require foo > 0, foo < 1000 **/ fn int testFoo(int foo) { return foo * 10; }","title":"Pre conditions"},{"location":"contracts/#post-conditions","text":"Post conditions are evaluated to make checks on the resulting state after passing through the function. The post condition uses the @ensure annotation. Where return is used to represent the return value from the function. /** * @require foo != null * @ensure return > foo.x **/ fn uint checkFoo(Foo* foo) { uint y = abs(foo.x) + 1; // If we had row: foo.x = 0, then this would be a compile time error. return y * abs(foo.x); }","title":"Post conditions"},{"location":"contracts/#parameter-annotations","text":"@param supports [in] [out] and [inout] . These are only applicable for pointer arguments. [in] disallows writing to the variable, [out] disallows reading from the variable. Without an annotation, pointers may both be read from and written to without checks. Type readable? writable? use as \"in\"? use as \"out\"? use as \"inout\" no annotation Yes Yes Yes Yes Yes in Yes No Yes No No out No Yes No Yes No inout Yes Yes Yes Yes Yes However, it should be noted that the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: fn void badFunc(int* i) { *i = 2; } /** * @param [in] i */ fn void lyingFunc(int* i) { badFunc(i); // The compiler might not check this! } fn void test() { int a = 1; lyingFunc(&a); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: /** * @param [in] i */ fn void badFunc(int* i) { *i = 2; // <- Compiler error: cannot write to \"in\" parameter }","title":"Parameter annotations"},{"location":"contracts/#pure-in-detail","text":"The pure annotation allows a program to make assumtions in regards of how the function treats global variables. Unlike for const , a pure function is not allowed to call a function which is known to be impure. However, just like for const the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely: int i = 0; type Secretfn fn void(); fn void badFunc() { i = 2; } Secretfn foo = nil; /** * @pure */ fn void lyingFunc() { SecretFunc(); // The compiler cannot reason about this! } fn void test() { foo = &badFunc; i = 1; lyingFunc(); printf(\"%d\", a); // Might print 1! } However, compilers will usually detect this: int i = 0; fn void badFunc() { i = 2; } /** * @pure */ fn void lyingFunc() { badFunc(); // Error! Calling an impure function } Consequently circumventing \"pure\" annotations is undefined behaviour.","title":"Pure in detail"},{"location":"contracts/#pre-conditions-for-macros","text":"In order to check macros, it's often useful to use the builtin $checks function which returns true if the code inside would pass semantic checking. /** * @require $checks(resource.open()) `Expected resource to have an \"open\" function` * @require resource != nil * @require $checks(void *x = resource.open()) **/ macro openResource(resource) { return resource.open(); }","title":"Pre conditions for macros"},{"location":"contribute/","text":"The C3 language is still in its design phase , which means functionality and specification are subject to change. That also means that any contribution right now will have a big impact on the language. So if you find the project interesting, here's what you can do to help: Discuss the language on the C3 Discord https://discord.gg/qN76R87 Suggest improvements by filing an issue: https://github.com/c3lang/c3docs/issues/new Offer to work on the compiler being written here: https://github.com/c3lang/c3c","title":"Contribute"},{"location":"conversion/","text":"Conversions and promotions C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 widening float conversions are only conditionally allowed(*) narrowing conversions require a cast(*) widening int conversions are only conditionally allowed(*) signed <-> unsigned conversions of the same type do not require a cast. In conditionals float to bool do not require a cast, any non zero float value considered true Implicit conversion to bool only occurs in conditionals or when the value is enclosed in () e.g. bool x = (1.0) or if (1.0) { ... } C3 uses two's complement arithmetic for all integer math. Target type The left hand side of an assignment, or the parameter type in a call is known as the target type the target type is used for implicit widening and inferring struct initialization. Common arithmetic promotion Like C, C3 uses implicit arithmetic promotion of integer and floating point variables before arithmetic operations: For any floating point type with a bit width smaller than 32 bits, widen to float . E.g. f16 -> float For an integer type smaller than the minimum arithmetic width promote the value to a same signed integer of the minimum arithmetic width (this usually corresponds to a c int/uint). E.g. ushort -> uint Implicit narrowing An expression with an integer type, may implicitly narrow to smaller integer type, and similarly a float type may implicitly narrow to less wide floating point type is determined from the following algorithm. Look at the expression. If this expression's type is determined by its subexpression(s), recursively visit to find the leaves that determine the type of the expression. For each leaf, determine that the type before arithmetic promotion had a width equal or less than the type to convert to. In the case of an integer literal, instead of looking at the type, check that the integer would fit the type to narrow to. Basically, if all the sub expressions originally are small enough it's ok to implicitly convert the result. Examples float16 h = 12.0; float f = 13.0; double d = 22.0; char x = 1; short y = -3; int z = 0xFFFFF; ulong w = -0xFFFFFFF; x = x + x; // => calculated as x = (char)((int)x + (int)x); x = y + x; // => Error, narrowing not allowed as y > char h = x * h; // => calculated as h = (float16)((float)x * (float)h); h = f + x; // => Error, narrowing not allowed since f > f16 Implicit widening Unlike C, implicit widening will only happen on \"simple expressions\": if the expression is a primary expression, or a unary operation on a primary expression. For assignment, special rules hold. For an assignment to a binary expression, if its two subexpressions are \"simple expressions\" and the binary expression is + , - , / , * , allow an implicit promotion of the two sub expressions. int a = ... short b = ... char c = ... long d = ~a; // Valid - simple expression. int e = (int)(d + (a + b)); // Error int f = (int)(d + ~b); // Valid long g = a + b; // Valid long h = a + (b + c); // Error As a rule of thumb, if there are more than one possible conversion an explicit cast is needed. Example: long h = a + (b + c); // Possible intention 1 long h = (long)(a + (b + c)); // Possible intention 2 long h = (long)a + (long)(b + c); // Possible intention 3 long h = (long)a + ((long)b + (long)c); Maximum type The maximum type is a concept used when unifying two or more types. The algorithm follows: First perform implicit promotion. If both types are the same, the maximum type is this type. If one type is a floating point type, and the other is an integer type, the maximum type is the floating point type. E.g. int + float -> float . If both types are floating point types, the maximum type is the widest floating point type. E.g. float + double -> double . If both types are integer types with the same signedness, the maximum type is the widest integer type of the two. E.g. uint + ulong -> ulong . If both types are integer types with different signedness, the maximum type is a signed integer with the same bit width as the maximum integer type. ulong + int -> long If at least one side is a struct or a pointer to a struct with an inline directive on a member, check recursively check if the type of the inline member can be used to find a maximum type (see below under sub struct conversions) All other cases are errors. Substruct conversions Substructs may be used in place of its parent structs in many cases. The rule is as follows: A substruct pointer may implicitly convert to a parent struct. A substruct value may be implicitly assigned to a variable with the parent struct type, This will truncate the value, copying only the parent part of the substruct. However, a substruct value cannot be assigned its parent struct. Substruct subarrays, vararrays and arrays can not be cast (implicitly or explicitly) to an array of the parent struct type. Pointer conversions Pointer conversion between types usually need explicit casts. The exception is void * which any type may implicitly convert to or from . Conversion rules from and to arrays are detailed under arrays Binary conversions 1. Multiplication, division, remainder, subtraction / addition with both operands being numbers These operations are only valid for integer and float types. Resolve the operands. Find the maximum type of the two operands. Promote both operands to the resulting type if both are simple expressions The resulting type of the expression is the resulting type. 2. Addition with left side being a pointer Resolve the operands. If the rhs is not an integer, this is an error. If the rhs has a bit width that exceeds isz, this is an error. The result of the expression is the lhs type. 3. Subtraction with lhs pointer and rhs integer Resolve the operands. If the right hand type has a bit width that exceeds isz, this is an error. The result of the expression is the left hand type. 4. Subtraction with both sides pointers Resolve the operands. If the either side is a void * , it is cast to the other type. If the types of the sides are different, this is an error. The result of the expression is isz. If this result exceeds the target width, this is an error. 6. Bit operations ^ & | These operations are only valid for integers and booleans. Resolve the operands. Find the maximum type of the two operands. Promote both operands to the maximum type if they are simple expressions. The result of the expression is the maximum type. 6. Shift operations << >> These operations are only valid for integers. Resolve the operands. In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. 3The result of the expression is the lhs type. 7. Assignment operations += -= *= *= /= %= ^= |= &= Resolve the lhs. Resolve the right operand as an assignment rhs. The result of the expression is the lhs type. 8. Assignment shift >>= <<= Resolve both operands In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. The result of the expression is the lhs type. 9. && and || Resolve both operands. Insert bool cast of both operands. The type is bool. 10. <= == >= != Resolve the operands, left to right. Find the maximum type of the two operands. Promote both operands to the maximum type. The type is bool. Unary conversions 1. Bit negate Resolve the inner operand. If the inner type is not an integer this is an error. The type is the inner type. 2. Boolean not Resolve the inner operand. The type is bool. 3. Negation Resolve the inner operand. If the type inner type is not a number this is an error. If the inner type is an unsigned integer, cast it to the same signed type. The type is the type of the result from (3) 4. & and && Resolve the inner operand. The type is a pointer to the type of the inner operand. 5. * Resolve the inner operand. If the operand is not a pointer, or is a void * pointer, this is an error. The type is the pointee of the inner operand's type. Dereferencing 0 is implementation defined. 6. ++ and -- Resolve the inner operand. If the type is not a number, this is an error. The type is the same as the inner operand. Base expressions 1. Typed identifiers The type is that of the declaration. If the width of the type is less than that of the target type, widen to the target type. If the width of the type is greater than that of the target type, it is an error. 2. Constants and literals If the constant is an integer, it is assumed to be the arithmetic promotion width and signed. If the suffix u is added, it is assumed to be an unsigned number. If a suffix ixx or uxx is given then it is considered a an integer of that type width and signedness. It cannot be implicitly narrowed. If the constant is a floating point value, it is assumed to be a double unless suffixed with f which is then assumed to be a float . If a bitwidth is given after f , it is instead a floating point type of that width.","title":"Conversions"},{"location":"conversion/#conversions-and-promotions","text":"C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3: float to int conversions require a cast int to float conversions do not require a cast bool to float converts to 0.0 / 1.0 widening float conversions are only conditionally allowed(*) narrowing conversions require a cast(*) widening int conversions are only conditionally allowed(*) signed <-> unsigned conversions of the same type do not require a cast. In conditionals float to bool do not require a cast, any non zero float value considered true Implicit conversion to bool only occurs in conditionals or when the value is enclosed in () e.g. bool x = (1.0) or if (1.0) { ... } C3 uses two's complement arithmetic for all integer math.","title":"Conversions and promotions"},{"location":"conversion/#target-type","text":"The left hand side of an assignment, or the parameter type in a call is known as the target type the target type is used for implicit widening and inferring struct initialization.","title":"Target type"},{"location":"conversion/#common-arithmetic-promotion","text":"Like C, C3 uses implicit arithmetic promotion of integer and floating point variables before arithmetic operations: For any floating point type with a bit width smaller than 32 bits, widen to float . E.g. f16 -> float For an integer type smaller than the minimum arithmetic width promote the value to a same signed integer of the minimum arithmetic width (this usually corresponds to a c int/uint). E.g. ushort -> uint","title":"Common arithmetic promotion"},{"location":"conversion/#implicit-narrowing","text":"An expression with an integer type, may implicitly narrow to smaller integer type, and similarly a float type may implicitly narrow to less wide floating point type is determined from the following algorithm. Look at the expression. If this expression's type is determined by its subexpression(s), recursively visit to find the leaves that determine the type of the expression. For each leaf, determine that the type before arithmetic promotion had a width equal or less than the type to convert to. In the case of an integer literal, instead of looking at the type, check that the integer would fit the type to narrow to. Basically, if all the sub expressions originally are small enough it's ok to implicitly convert the result. Examples float16 h = 12.0; float f = 13.0; double d = 22.0; char x = 1; short y = -3; int z = 0xFFFFF; ulong w = -0xFFFFFFF; x = x + x; // => calculated as x = (char)((int)x + (int)x); x = y + x; // => Error, narrowing not allowed as y > char h = x * h; // => calculated as h = (float16)((float)x * (float)h); h = f + x; // => Error, narrowing not allowed since f > f16","title":"Implicit narrowing"},{"location":"conversion/#implicit-widening","text":"Unlike C, implicit widening will only happen on \"simple expressions\": if the expression is a primary expression, or a unary operation on a primary expression. For assignment, special rules hold. For an assignment to a binary expression, if its two subexpressions are \"simple expressions\" and the binary expression is + , - , / , * , allow an implicit promotion of the two sub expressions. int a = ... short b = ... char c = ... long d = ~a; // Valid - simple expression. int e = (int)(d + (a + b)); // Error int f = (int)(d + ~b); // Valid long g = a + b; // Valid long h = a + (b + c); // Error As a rule of thumb, if there are more than one possible conversion an explicit cast is needed. Example: long h = a + (b + c); // Possible intention 1 long h = (long)(a + (b + c)); // Possible intention 2 long h = (long)a + (long)(b + c); // Possible intention 3 long h = (long)a + ((long)b + (long)c);","title":"Implicit widening"},{"location":"conversion/#maximum-type","text":"The maximum type is a concept used when unifying two or more types. The algorithm follows: First perform implicit promotion. If both types are the same, the maximum type is this type. If one type is a floating point type, and the other is an integer type, the maximum type is the floating point type. E.g. int + float -> float . If both types are floating point types, the maximum type is the widest floating point type. E.g. float + double -> double . If both types are integer types with the same signedness, the maximum type is the widest integer type of the two. E.g. uint + ulong -> ulong . If both types are integer types with different signedness, the maximum type is a signed integer with the same bit width as the maximum integer type. ulong + int -> long If at least one side is a struct or a pointer to a struct with an inline directive on a member, check recursively check if the type of the inline member can be used to find a maximum type (see below under sub struct conversions) All other cases are errors.","title":"Maximum type"},{"location":"conversion/#substruct-conversions","text":"Substructs may be used in place of its parent structs in many cases. The rule is as follows: A substruct pointer may implicitly convert to a parent struct. A substruct value may be implicitly assigned to a variable with the parent struct type, This will truncate the value, copying only the parent part of the substruct. However, a substruct value cannot be assigned its parent struct. Substruct subarrays, vararrays and arrays can not be cast (implicitly or explicitly) to an array of the parent struct type.","title":"Substruct conversions"},{"location":"conversion/#pointer-conversions","text":"Pointer conversion between types usually need explicit casts. The exception is void * which any type may implicitly convert to or from . Conversion rules from and to arrays are detailed under arrays","title":"Pointer conversions"},{"location":"conversion/#binary-conversions","text":"","title":"Binary conversions"},{"location":"conversion/#1-multiplication-division-remainder-subtraction-addition-with-both-operands-being-numbers","text":"These operations are only valid for integer and float types. Resolve the operands. Find the maximum type of the two operands. Promote both operands to the resulting type if both are simple expressions The resulting type of the expression is the resulting type.","title":"1. Multiplication, division, remainder, subtraction / addition with both operands being numbers"},{"location":"conversion/#2-addition-with-left-side-being-a-pointer","text":"Resolve the operands. If the rhs is not an integer, this is an error. If the rhs has a bit width that exceeds isz, this is an error. The result of the expression is the lhs type.","title":"2. Addition with left side being a pointer"},{"location":"conversion/#3-subtraction-with-lhs-pointer-and-rhs-integer","text":"Resolve the operands. If the right hand type has a bit width that exceeds isz, this is an error. The result of the expression is the left hand type.","title":"3. Subtraction with lhs pointer and rhs integer"},{"location":"conversion/#4-subtraction-with-both-sides-pointers","text":"Resolve the operands. If the either side is a void * , it is cast to the other type. If the types of the sides are different, this is an error. The result of the expression is isz. If this result exceeds the target width, this is an error.","title":"4. Subtraction with both sides pointers"},{"location":"conversion/#6-bit-operations","text":"These operations are only valid for integers and booleans. Resolve the operands. Find the maximum type of the two operands. Promote both operands to the maximum type if they are simple expressions. The result of the expression is the maximum type.","title":"6. Bit operations ^ &amp; |"},{"location":"conversion/#6-shift-operations","text":"These operations are only valid for integers. Resolve the operands. In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. 3The result of the expression is the lhs type.","title":"6. Shift operations &lt;&lt; &gt;&gt;"},{"location":"conversion/#7-assignment-operations-","text":"Resolve the lhs. Resolve the right operand as an assignment rhs. The result of the expression is the lhs type.","title":"7. Assignment operations += -= *= *= /= %= ^= |= &amp;="},{"location":"conversion/#8-assignment-shift","text":"Resolve both operands In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side. The result of the expression is the lhs type.","title":"8. Assignment shift &gt;&gt;= &lt;&lt;="},{"location":"conversion/#9-and","text":"Resolve both operands. Insert bool cast of both operands. The type is bool.","title":"9. &amp;&amp; and ||"},{"location":"conversion/#10","text":"Resolve the operands, left to right. Find the maximum type of the two operands. Promote both operands to the maximum type. The type is bool.","title":"10. &lt;= == &gt;= !="},{"location":"conversion/#unary-conversions","text":"","title":"Unary conversions"},{"location":"conversion/#1-bit-negate","text":"Resolve the inner operand. If the inner type is not an integer this is an error. The type is the inner type.","title":"1. Bit negate"},{"location":"conversion/#2-boolean-not","text":"Resolve the inner operand. The type is bool.","title":"2. Boolean not"},{"location":"conversion/#3-negation","text":"Resolve the inner operand. If the type inner type is not a number this is an error. If the inner type is an unsigned integer, cast it to the same signed type. The type is the type of the result from (3)","title":"3. Negation"},{"location":"conversion/#4-and","text":"Resolve the inner operand. The type is a pointer to the type of the inner operand.","title":"4. &amp; and &amp;&amp;"},{"location":"conversion/#5","text":"Resolve the inner operand. If the operand is not a pointer, or is a void * pointer, this is an error. The type is the pointee of the inner operand's type. Dereferencing 0 is implementation defined.","title":"5. *"},{"location":"conversion/#6-and-","text":"Resolve the inner operand. If the type is not a number, this is an error. The type is the same as the inner operand.","title":"6. ++ and --"},{"location":"conversion/#base-expressions","text":"","title":"Base expressions"},{"location":"conversion/#1-typed-identifiers","text":"The type is that of the declaration. If the width of the type is less than that of the target type, widen to the target type. If the width of the type is greater than that of the target type, it is an error.","title":"1. Typed identifiers"},{"location":"conversion/#2-constants-and-literals","text":"If the constant is an integer, it is assumed to be the arithmetic promotion width and signed. If the suffix u is added, it is assumed to be an unsigned number. If a suffix ixx or uxx is given then it is considered a an integer of that type width and signedness. It cannot be implicitly narrowed. If the constant is a floating point value, it is assumed to be a double unless suffixed with f which is then assumed to be a float . If a bitwidth is given after f , it is instead a floating point type of that width.","title":"2. Constants and literals"},{"location":"define/","text":"The \"define\" statement The define statement in C3 encompasses the typedef of C, as well as aliasing using #define . Defining a type alias define <type alias> = <type> creates a type alias, just as if one had used typedef in C. Type aliases need to follow the name convention of user defined types (i.e. capitalized names with at least one lower case letter). define CharPtr = char*; define Numbers = int[10]; Function pointers must be aliased in C3. The syntax is somewhat different from C: define Callback = fn void(int a, bool b); This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback; cb(10, false); Distinct types define may also be used to create distinct new types. Unlike type aliases, they do not implicitly convert to any other type. define Foo = distinct int; Foo f = 0; f = f + 1; int i = 1; // f = f + i Error! f = f + (Foo)i; // Valid Function and variable aliases It's possible to use define to create aliases for functions and variables. The syntax is define <alias> = <original identifier> . fn void foo() { ... } int foo_var; define bar = foo; define bar_var = foo_var; fn void test() { // These are the same: foo(); bar(); // These access the same variable: int x = foo_var; int y = bar_var; } Using define to create generic types, functions and variables Generic modules uses define to create aliases to parameterized types, functions and variables: import generic_foo; // Parameterized function aliases define int_foo_call = generic_foo::foo_call<int>; define double_foo_call = generic_foo::foo_call<double>; // Parameterized type aliases define IntFoo = Foo<int>; define DoubleFoo = Foo<double>; // Parameterized global aliases define int_max_foo = generic_foo::max_foo<int>; define double_max_foo = generic_foo::max_foo<double>; For more information, see the chapter on generics . Function pointer default arguments and named parameters It is possible to attach default arguments to function pointer aliases. There is no requirement that the function has the same default arguments. In fact, the function pointer may have default arguments where the function doesn't have it and vice-versa. Calling the function directly will then use the function's default arguments, and calling through the function pointer will yield the function pointer alias' default argument. Similarly, named parameter arguments follow the alias definition when calling through the function pointer: define TestFn = fn void(int y = 123); fn void test(int x = 5) { io::printfn(\"X = %d\"); } fn void main() { TestFn test2 = &test; test(); // Prints X = 5 test2(); // Prints X = 123 test(.x = 3); // Prints X = 3 test2(.y = 4); // Prints X = 4 }","title":"Define"},{"location":"define/#the-define-statement","text":"The define statement in C3 encompasses the typedef of C, as well as aliasing using #define .","title":"The \"define\" statement"},{"location":"define/#defining-a-type-alias","text":"define <type alias> = <type> creates a type alias, just as if one had used typedef in C. Type aliases need to follow the name convention of user defined types (i.e. capitalized names with at least one lower case letter). define CharPtr = char*; define Numbers = int[10]; Function pointers must be aliased in C3. The syntax is somewhat different from C: define Callback = fn void(int a, bool b); This defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage: Callback cb = my_callback; cb(10, false);","title":"Defining a type alias"},{"location":"define/#distinct-types","text":"define may also be used to create distinct new types. Unlike type aliases, they do not implicitly convert to any other type. define Foo = distinct int; Foo f = 0; f = f + 1; int i = 1; // f = f + i Error! f = f + (Foo)i; // Valid","title":"Distinct types"},{"location":"define/#function-and-variable-aliases","text":"It's possible to use define to create aliases for functions and variables. The syntax is define <alias> = <original identifier> . fn void foo() { ... } int foo_var; define bar = foo; define bar_var = foo_var; fn void test() { // These are the same: foo(); bar(); // These access the same variable: int x = foo_var; int y = bar_var; }","title":"Function and variable aliases"},{"location":"define/#using-define-to-create-generic-types-functions-and-variables","text":"Generic modules uses define to create aliases to parameterized types, functions and variables: import generic_foo; // Parameterized function aliases define int_foo_call = generic_foo::foo_call<int>; define double_foo_call = generic_foo::foo_call<double>; // Parameterized type aliases define IntFoo = Foo<int>; define DoubleFoo = Foo<double>; // Parameterized global aliases define int_max_foo = generic_foo::max_foo<int>; define double_max_foo = generic_foo::max_foo<double>; For more information, see the chapter on generics .","title":"Using define to create generic types, functions and variables"},{"location":"define/#function-pointer-default-arguments-and-named-parameters","text":"It is possible to attach default arguments to function pointer aliases. There is no requirement that the function has the same default arguments. In fact, the function pointer may have default arguments where the function doesn't have it and vice-versa. Calling the function directly will then use the function's default arguments, and calling through the function pointer will yield the function pointer alias' default argument. Similarly, named parameter arguments follow the alias definition when calling through the function pointer: define TestFn = fn void(int y = 123); fn void test(int x = 5) { io::printfn(\"X = %d\"); } fn void main() { TestFn test2 = &test; test(); // Prints X = 5 test2(); // Prints X = 123 test(.x = 3); // Prints X = 3 test2(.y = 4); // Prints X = 4 }","title":"Function pointer default arguments and named parameters"},{"location":"errorhandling/","text":"Error Handling Unlike usual exception handling, errors in C3 build on optional returns. An optional result works as a union containing either the expected result or an optional result value . Error returns For C the interface to C3, the fault is returned as the regular value, while the return value is instead returned as an out parameter. C3 code: fn int! getValue(); Corresponding C code: OptEnum getValue(int *value); The int! here is the optional result type, which either contains an optional result value or an int. Note: reflection methods on optionals are not complete yet. // Open a file, we will get an optional result: // Either a File* or an error. File*! file = openFile(\"foo.txt\"); // We can extract the optional result value using \"catch\" if (catch err = file) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.name()); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.fullName()); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", (ulong)err); return; } // We can also just execute of success: File*! file2 = openFile(\"bar.txt\"); // Only true if there is an expected result. if (try file2) { // Inside here file2 is a regular File* } A function, method or macro call with one or more parameters will only execute if the optional result has the expected result . This makes optional result returns composable. fn int! fooMayError() { ... } fn int mult(int i) { ... } fn int! save(int i) { ... } fn void test() ( int! i = fooMayError(); // \"mult\" is only called if \"fooMayError()\" // returns a non optional result. int! j = mult(fooMayError()); int! k = save(mult(fooMAyError())); if (catch err = k) { // The optional result value may be from fooMayError // or save! } ) Implicit unwrapping If a if-catch returns or jumps out of the current scope in some way, then the variable becomes unwrapped to it's non-optional type in that scope: int! i = fooMayError(); if (catch i) { return; } // i is now considered an int: if (i > 10) doSomething(); Some simple examples. Defining an optional result value An result if effectively an enum, and is defined in the same way: fault IoError { FILE_NOT_FOUND, FILE_NOT_READABLE, } Returning an optional value result Returning an optional result looks like a normal return but with the ! fn void! findFile() { if (File.doesFileExist(\"foo.txt\")) return IoError.FILE_NOT_FOUND!; /* ... */ } Calling a function automatically returning any optional result The ? suffix will create an implicit return if the expected result is missing. fn void! findFileAndTest() { findFile()?; // Implictly: // catch (err = findFile()) return err!; } Panic on error The !! will issue a panic if the expected value is missing. fn void findFileAndTest() { findFile()!!; // Implictly: // catch (err = findFile()) panic(\"Unexpected error\"); } Catching optionals Catching an optional and returning will implicitly unwrap the checked variable. fn void findFileAndNoErr() { File*! res = findFile(); if (catch res) { printf(\"An error occurred!\\n\"); return; } // res is implicitly unwrapped here. // and have an effective type of File* here. } Only do if no optional value return fn void doSomethingToFile() { void! res = findFile(); if (try res) { printf(\"I found the file\\n\"); } } Catching some optional value results fn void! findFileAndParse2() { if (catch err = findFileAndParse()) { case IOError.FILE_NOT_FOUND: printf(\"Error loading the file!\\n\"); default: return err; } } Default values A function returning an optional type may be followed by an ?? and an expression. The expression on the right hand side will be returned if the left hand side returns an optional result value. fn int testDefault() { return getIntNumberOrFail() ?? -1; } // The above is equivalent to: fn int testDefault() { int! i = getIntNumberOrFail(); catch (i) return -1; return i; }","title":"Errors"},{"location":"errorhandling/#error-handling","text":"Unlike usual exception handling, errors in C3 build on optional returns. An optional result works as a union containing either the expected result or an optional result value .","title":"Error Handling"},{"location":"errorhandling/#error-returns","text":"For C the interface to C3, the fault is returned as the regular value, while the return value is instead returned as an out parameter. C3 code: fn int! getValue(); Corresponding C code: OptEnum getValue(int *value); The int! here is the optional result type, which either contains an optional result value or an int. Note: reflection methods on optionals are not complete yet. // Open a file, we will get an optional result: // Either a File* or an error. File*! file = openFile(\"foo.txt\"); // We can extract the optional result value using \"catch\" if (catch err = file) { // Might print \"Error was FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.name()); // Might print \"Error was FileError.FILE_NOT_FOUND\" printf(\"Error was %s\\n\", err.fullName()); // Might print \"Error code: 931938210\" printf(\"Error code: %ull\\n\", (ulong)err); return; } // We can also just execute of success: File*! file2 = openFile(\"bar.txt\"); // Only true if there is an expected result. if (try file2) { // Inside here file2 is a regular File* } A function, method or macro call with one or more parameters will only execute if the optional result has the expected result . This makes optional result returns composable. fn int! fooMayError() { ... } fn int mult(int i) { ... } fn int! save(int i) { ... } fn void test() ( int! i = fooMayError(); // \"mult\" is only called if \"fooMayError()\" // returns a non optional result. int! j = mult(fooMayError()); int! k = save(mult(fooMAyError())); if (catch err = k) { // The optional result value may be from fooMayError // or save! } )","title":"Error returns"},{"location":"errorhandling/#implicit-unwrapping","text":"If a if-catch returns or jumps out of the current scope in some way, then the variable becomes unwrapped to it's non-optional type in that scope: int! i = fooMayError(); if (catch i) { return; } // i is now considered an int: if (i > 10) doSomething();","title":"Implicit unwrapping"},{"location":"errorhandling/#some-simple-examples","text":"","title":"Some simple examples."},{"location":"errorhandling/#defining-an-optional-result-value","text":"An result if effectively an enum, and is defined in the same way: fault IoError { FILE_NOT_FOUND, FILE_NOT_READABLE, }","title":"Defining an optional result value"},{"location":"errorhandling/#returning-an-optional-value-result","text":"Returning an optional result looks like a normal return but with the ! fn void! findFile() { if (File.doesFileExist(\"foo.txt\")) return IoError.FILE_NOT_FOUND!; /* ... */ }","title":"Returning an optional value result"},{"location":"errorhandling/#calling-a-function-automatically-returning-any-optional-result","text":"The ? suffix will create an implicit return if the expected result is missing. fn void! findFileAndTest() { findFile()?; // Implictly: // catch (err = findFile()) return err!; }","title":"Calling a function automatically returning any optional result"},{"location":"errorhandling/#panic-on-error","text":"The !! will issue a panic if the expected value is missing. fn void findFileAndTest() { findFile()!!; // Implictly: // catch (err = findFile()) panic(\"Unexpected error\"); }","title":"Panic on error"},{"location":"errorhandling/#catching-optionals","text":"Catching an optional and returning will implicitly unwrap the checked variable. fn void findFileAndNoErr() { File*! res = findFile(); if (catch res) { printf(\"An error occurred!\\n\"); return; } // res is implicitly unwrapped here. // and have an effective type of File* here. }","title":"Catching optionals"},{"location":"errorhandling/#only-do-if-no-optional-value-return","text":"fn void doSomethingToFile() { void! res = findFile(); if (try res) { printf(\"I found the file\\n\"); } }","title":"Only do if no optional value return"},{"location":"errorhandling/#catching-some-optional-value-results","text":"fn void! findFileAndParse2() { if (catch err = findFileAndParse()) { case IOError.FILE_NOT_FOUND: printf(\"Error loading the file!\\n\"); default: return err; } }","title":"Catching some optional value results"},{"location":"errorhandling/#default-values","text":"A function returning an optional type may be followed by an ?? and an expression. The expression on the right hand side will be returned if the left hand side returns an optional result value. fn int testDefault() { return getIntNumberOrFail() ?? -1; } // The above is equivalent to: fn int testDefault() { int! i = getIntNumberOrFail(); catch (i) return -1; return i; }","title":"Default values"},{"location":"examples/","text":"if-statement fn void if_example(int a) { if (a > 0) { // .. } else { // .. } } for-loop fn void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io::printfn(\"%d\", i); } // also equal for (;;) { // .. } } foreach-loop fn void example_foreach(float[] values) { foreach (index, value : values) { io::printfn(\"%d: %f\", index, value); } } while-loop fn void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } } enum + switch Switches have implicit break and scope. Use \"nextcase\" to implicitly fallthrough or use comma: enum Height : uint { LOW, MEDIUM, HIGH, } fn void demo_enum(Height h) { switch (h) { case LOW: case MEDIUM: io::println(\"Not high\"); // Implicit break. case HIGH: io::println(\"High\"); } // This also works switch (h) { case LOW: case MEDIUM: io::println(\"Not high\"); // Implicit break. case Height.HIGH: io::println(\"High\"); } // Completely empty cases are not allowed. switch (h) { case LOW: break; // Explicit break required, since switches can't be empty. case MEDIUM: io::println(\"Medium\"); case HIGH: break; } // special checking of switching on enum types switch (h) { case LOW: case MEDIUM: case HIGH: break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"nextcase\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case LOW: int a = 1; io::println(\"A\"); nextcase; case MEDIUM: int a = 2; io::println(\"B\"); nextcase; case HIGH: // a is not defined here io::println(\"C\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .values returns an array with all enums. enum State : uint { START, STOP, } const uint LOWEST = State.min; const uint HIGHEST = State.max; State start = State.values[0]; defer Defer will be invoked on scope exit. fn void test(int x) { defer io::println(); defer io::print(\"A\"); if (x == 1) return; { defer io::print(\"B\"); if (x == 0) return; } io::print(\"!\"); } fn void main() { test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"B!A\" } Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. Note that this is currently not implemented. fn void! test(int x) { defer io::println(\"\"); defer io::println(\"A\"); defer catch io::println(\"B\") defer catch (err) io::printfn(\"%s\", err.message); if (x == 1) return FooError!; print(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and returns a FooError struct types define Callback = fn int(char c); enum Status : int { IDLE, BUSY, DONE, } struct MyData { char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } } Function pointers module demo; define Callback = fn int(char* text, int value); fn int my_callback(char* text, int value) { return 0; } Callback cb = &my_callback; fn void example_cb() { int result = cb(\"demo\", 123); // .. } Error handling Errors are handled using optional results, denoted with a '!' suffix. A variable of an optional result type may either contain the regular value or a fault enum value. fault MathError { DIVISION_BY_ZERO } fn double! divide(int a, int b) { // We return an optional result of type DIVISION_BY_ZERO // when b is zero. if (b == 0) return MathError.DIVISION_BY_ZERO!; return (double)a / (double)b; } // Re-returning an optional result uses \"?\" suffix fn void! testMayError() { divide(foo(), bar())?; } fn void main() { // ratio is an optional result. double! ratio = divide(foo(), bar()); // Handle the optional result value if it exists. if (catch err = ratio) { case MathError.DIVISION_BY_ZERO: io::println(\"Division by zero\\n\"); return; default: io::println(\"Unexpected error!\"); return; } // Flow typing makes \"ratio\" // have the plain type 'double' here. io::printfn(\"Ratio was %f\", ratio); } fn void printFile(String filename) { String! file = io::load_file(filename); // The following function is not executed on error. io::printfn(\"Loaded %s and got:\\n%s\", filename, file); if (catch err = file) { case IoError.FILE_NOT_FOUND: io::printfn(\"I could not find the file %s\", filename); default: io::printfn(\"Could not load %s.\", filename); } } Contracts Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo \"the number of foos\" * @require foo > 0, foo < 1000 * @return \"number of foos x 10\" * @ensure return < 10000, return > 0 **/ fn int testFoo(int foo) { return foo * 10; } /** * @param array \"the array to test\" * @param length \"length of the array\" * @require length > 0 **/ fn int getLastElement(int* array, int length) { return array[length - 1]; } Macros Macro arguments may be immediately evaluated. macro foo(a, b) { return a(b); } fn int square(int x) { return x * x; } fn int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion using #var syntax. macro foo(#a, b, #c) { c = a(b) * b; } macro foo2(#a) { return a * a; } fn int square(int x) { return x * x; } fn int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } fn int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x \"value to square\" * @require $checks(x * x >= 0) \"cannot multiply\" **/ macro square(x) { return x * x; } fn void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' } Methods It's possible to namespace functions with a union, struct or enum type to enable \"dot syntax\" calls: struct Foo { int i; } fn void Foo.next(Foo* this) { if (this) this.i++; } fn void test() { Foo foo = { 2 }; foo.next(); foo.next(); // Prints 4 printf(\"%d\", foo.i); } Generic modules Generic modules implements a generic system. module stack <Type>; struct Stack { usz capacity; usz size; Type* elems; } fn void Stack.push(Stack* this, Type element) { if (this.capacity == this.size) { this.capacity *= 2; this.elems = mem::realloc(this.elems, Type.sizeof * this.capacity); } this.elems[this.size++] = element; } fn Type Stack.pop(Stack* this) { assert(this.size > 0); return this.elems[--this.size]; } fn bool Stack.empty(Stack* this) { return !this.size; } Testing it out: define IntStack = Stack<int>; define DoubleStack = Stack<double>; fn void test() { IntStack stack; stack.push(1); stack.push(2); // Prints pop: 2 printf(\"pop: %d\\n\", stack.pop()); // Prints pop: 1 printf(\"pop: %d\\n\", stack.pop()); DoubleStack dstack; dstack.push(2.3); dstack.push(3.141); dstack.push(1.1235); // Prints pop: 1.1235 printf(\"pop: %f\\n\", dstack.pop()); }","title":"Examples"},{"location":"examples/#if-statement","text":"fn void if_example(int a) { if (a > 0) { // .. } else { // .. } }","title":"if-statement"},{"location":"examples/#for-loop","text":"fn void example_for() { // the for-loop is the same as C99. for (int i = 0; i < 10; i++) { io::printfn(\"%d\", i); } // also equal for (;;) { // .. } }","title":"for-loop"},{"location":"examples/#foreach-loop","text":"fn void example_foreach(float[] values) { foreach (index, value : values) { io::printfn(\"%d: %f\", index, value); } }","title":"foreach-loop"},{"location":"examples/#while-loop","text":"fn void example_while() { // again exactly the same as C int a = 10; while (a > 0) { a--; } // Declaration while (Point* p = getPoint()) { // .. } }","title":"while-loop"},{"location":"examples/#enum-switch","text":"Switches have implicit break and scope. Use \"nextcase\" to implicitly fallthrough or use comma: enum Height : uint { LOW, MEDIUM, HIGH, } fn void demo_enum(Height h) { switch (h) { case LOW: case MEDIUM: io::println(\"Not high\"); // Implicit break. case HIGH: io::println(\"High\"); } // This also works switch (h) { case LOW: case MEDIUM: io::println(\"Not high\"); // Implicit break. case Height.HIGH: io::println(\"High\"); } // Completely empty cases are not allowed. switch (h) { case LOW: break; // Explicit break required, since switches can't be empty. case MEDIUM: io::println(\"Medium\"); case HIGH: break; } // special checking of switching on enum types switch (h) { case LOW: case MEDIUM: case HIGH: break; default: // warning: default label in switch which covers all enumeration value break; } // Using \"nextcase\" will fallthrough to the next case statement, // and each case statement starts its own scope. switch (h) { case LOW: int a = 1; io::println(\"A\"); nextcase; case MEDIUM: int a = 2; io::println(\"B\"); nextcase; case HIGH: // a is not defined here io::println(\"C\"); } } Enums are always namespaced. Enums also define .min and .max , returning the minimum and maximum value for the enum values. .values returns an array with all enums. enum State : uint { START, STOP, } const uint LOWEST = State.min; const uint HIGHEST = State.max; State start = State.values[0];","title":"enum + switch"},{"location":"examples/#defer","text":"Defer will be invoked on scope exit. fn void test(int x) { defer io::println(); defer io::print(\"A\"); if (x == 1) return; { defer io::print(\"B\"); if (x == 0) return; } io::print(\"!\"); } fn void main() { test(1); // Prints \"A\" test(0); // Prints \"BA\" test(10); // Prints \"B!A\" } Because it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the catch keyword directly after the defer. Note that this is currently not implemented. fn void! test(int x) { defer io::println(\"\"); defer io::println(\"A\"); defer catch io::println(\"B\") defer catch (err) io::printfn(\"%s\", err.message); if (x == 1) return FooError!; print(\"!\") } test(0); // Prints \"!A\" test(1); // Prints \"FOOBA\" and returns a FooError","title":"defer"},{"location":"examples/#struct-types","text":"define Callback = fn int(char c); enum Status : int { IDLE, BUSY, DONE, } struct MyData { char* name; Callback open; Callback close; State status; // named sub-structs (x.other.value) struct other { int value; int status; // ok, no name clash with other status } // anonymous sub-structs (x.value) struct { int value; int status; // error, name clash with other status in MyData } // anonymous union (x.person) union { Person* person; Company* company; } // named sub-unions (x.either.this) union either { int this; bool or; char* that; } }","title":"struct types"},{"location":"examples/#function-pointers","text":"module demo; define Callback = fn int(char* text, int value); fn int my_callback(char* text, int value) { return 0; } Callback cb = &my_callback; fn void example_cb() { int result = cb(\"demo\", 123); // .. }","title":"Function pointers"},{"location":"examples/#error-handling","text":"Errors are handled using optional results, denoted with a '!' suffix. A variable of an optional result type may either contain the regular value or a fault enum value. fault MathError { DIVISION_BY_ZERO } fn double! divide(int a, int b) { // We return an optional result of type DIVISION_BY_ZERO // when b is zero. if (b == 0) return MathError.DIVISION_BY_ZERO!; return (double)a / (double)b; } // Re-returning an optional result uses \"?\" suffix fn void! testMayError() { divide(foo(), bar())?; } fn void main() { // ratio is an optional result. double! ratio = divide(foo(), bar()); // Handle the optional result value if it exists. if (catch err = ratio) { case MathError.DIVISION_BY_ZERO: io::println(\"Division by zero\\n\"); return; default: io::println(\"Unexpected error!\"); return; } // Flow typing makes \"ratio\" // have the plain type 'double' here. io::printfn(\"Ratio was %f\", ratio); } fn void printFile(String filename) { String! file = io::load_file(filename); // The following function is not executed on error. io::printfn(\"Loaded %s and got:\\n%s\", filename, file); if (catch err = file) { case IoError.FILE_NOT_FOUND: io::printfn(\"I could not find the file %s\", filename); default: io::printfn(\"Could not load %s.\", filename); } }","title":"Error handling"},{"location":"examples/#contracts","text":"Pre- and postconditions are optionally compiled into asserts helping to optimize the code. /** * @param foo \"the number of foos\" * @require foo > 0, foo < 1000 * @return \"number of foos x 10\" * @ensure return < 10000, return > 0 **/ fn int testFoo(int foo) { return foo * 10; } /** * @param array \"the array to test\" * @param length \"length of the array\" * @require length > 0 **/ fn int getLastElement(int* array, int length) { return array[length - 1]; }","title":"Contracts"},{"location":"examples/#macros","text":"Macro arguments may be immediately evaluated. macro foo(a, b) { return a(b); } fn int square(int x) { return x * x; } fn int test() { int a = 2; int b = 3; return @foo(&square, 2) + a + b; // 9 // return @foo(square, 2) + a + b; // Error the symbol \"square\" cannot be used as an argument. } Macro arguments may have deferred evaluation, which is basically text expansion using #var syntax. macro foo(#a, b, #c) { c = a(b) * b; } macro foo2(#a) { return a * a; } fn int square(int x) { return x * x; } fn int test1() { int a = 2; int b = 3; foo(square, a + 1, b); return b; // 27 } fn int test2() { return foo2(1 + 1); // 1 + 1 * 1 + 1 = 3 } Improve macro errors with preconditions: /** * @param x \"value to square\" * @require $checks(x * x >= 0) \"cannot multiply\" **/ macro square(x) { return x * x; } fn void test() { square(\"hello\"); // Error: cannot multiply \"hello\" int a = 1; square(&a); // Error: cannot multiply '&a' }","title":"Macros"},{"location":"examples/#methods","text":"It's possible to namespace functions with a union, struct or enum type to enable \"dot syntax\" calls: struct Foo { int i; } fn void Foo.next(Foo* this) { if (this) this.i++; } fn void test() { Foo foo = { 2 }; foo.next(); foo.next(); // Prints 4 printf(\"%d\", foo.i); }","title":"Methods"},{"location":"examples/#generic-modules","text":"Generic modules implements a generic system. module stack <Type>; struct Stack { usz capacity; usz size; Type* elems; } fn void Stack.push(Stack* this, Type element) { if (this.capacity == this.size) { this.capacity *= 2; this.elems = mem::realloc(this.elems, Type.sizeof * this.capacity); } this.elems[this.size++] = element; } fn Type Stack.pop(Stack* this) { assert(this.size > 0); return this.elems[--this.size]; } fn bool Stack.empty(Stack* this) { return !this.size; } Testing it out: define IntStack = Stack<int>; define DoubleStack = Stack<double>; fn void test() { IntStack stack; stack.push(1); stack.push(2); // Prints pop: 2 printf(\"pop: %d\\n\", stack.pop()); // Prints pop: 1 printf(\"pop: %d\\n\", stack.pop()); DoubleStack dstack; dstack.push(2.3); dstack.push(3.141); dstack.push(1.1235); // Prints pop: 1.1235 printf(\"pop: %f\\n\", dstack.pop()); }","title":"Generic modules"},{"location":"expressions/","text":"Expressions Expressions work like in C, with one exception: it is possible to take the address of a temporary. This uses the operator && rather than & . Consequently this is valid: fn void test(int* x) { ... } test(&&1); // In C: // int x = 1; // test(&x); Compound literals C3 has C's compound literals, but unlike C's cast style syntax (MyStruct) { 1, 2 } , it uses C++ syntax: MyStruct { 1, 2 } . struct Foo { int a; double b; } fn void test(Foo x) { ... } ... test(Foo { 1, 2.0 }); Arrays follow the same syntax: fn void test(int[3] x) { ... } ... test(int[3] { 1, 2, 3 }); One may take the address of temporaries, using && (rather than & for normal variables). This allows the following: Passing a slice fn void test(int[] y) { ... } // Using && test(&&int[3]{ 1, 2, 3 }); // Explicitly slicing: test(int[3]{ 1, 2, 3 }[..])); // Using a slice directly as a temporary: test(int[]{ 1, 2, 3 })); Passing the pointer to an array fn void test1(int[3]* z) { ... } fn void test2(int* z) { ... } test1(&&int[3]{ 1, 2, 3 })); test2(&&int[3]{ 1, 2, 3 })); Constant expressions In C3 all constant expressions are guaranteed to be calculated at compile time. The following are considered constant expressions: The null literal. Boolean, floating point and integer literals. The result of arithmetics on constant expressions. Compile time variables (prefixed with $ ) Global constant variables with initializers that are constant expressions. The result of macros that does not generate code and only uses constant expressions. The result of a cast if the value is cast to a boolean, floating point or integer type and the value that is converted is a constant expression. String literals. Initializer lists containing constant values. Some things that are not constant expressions: Any pointer that isn't the null literal, even if it's derived from a constant expression. The result of a cast except for casts of constant expressions to a numeric type. Compound literals - even when values are constant expressions.","title":"Expressions"},{"location":"expressions/#expressions","text":"Expressions work like in C, with one exception: it is possible to take the address of a temporary. This uses the operator && rather than & . Consequently this is valid: fn void test(int* x) { ... } test(&&1); // In C: // int x = 1; // test(&x);","title":"Expressions"},{"location":"expressions/#compound-literals","text":"C3 has C's compound literals, but unlike C's cast style syntax (MyStruct) { 1, 2 } , it uses C++ syntax: MyStruct { 1, 2 } . struct Foo { int a; double b; } fn void test(Foo x) { ... } ... test(Foo { 1, 2.0 }); Arrays follow the same syntax: fn void test(int[3] x) { ... } ... test(int[3] { 1, 2, 3 }); One may take the address of temporaries, using && (rather than & for normal variables). This allows the following: Passing a slice fn void test(int[] y) { ... } // Using && test(&&int[3]{ 1, 2, 3 }); // Explicitly slicing: test(int[3]{ 1, 2, 3 }[..])); // Using a slice directly as a temporary: test(int[]{ 1, 2, 3 })); Passing the pointer to an array fn void test1(int[3]* z) { ... } fn void test2(int* z) { ... } test1(&&int[3]{ 1, 2, 3 })); test2(&&int[3]{ 1, 2, 3 }));","title":"Compound literals"},{"location":"expressions/#constant-expressions","text":"In C3 all constant expressions are guaranteed to be calculated at compile time. The following are considered constant expressions: The null literal. Boolean, floating point and integer literals. The result of arithmetics on constant expressions. Compile time variables (prefixed with $ ) Global constant variables with initializers that are constant expressions. The result of macros that does not generate code and only uses constant expressions. The result of a cast if the value is cast to a boolean, floating point or integer type and the value that is converted is a constant expression. String literals. Initializer lists containing constant values. Some things that are not constant expressions: Any pointer that isn't the null literal, even if it's derived from a constant expression. The result of a cast except for casts of constant expressions to a numeric type. Compound literals - even when values are constant expressions.","title":"Constant expressions"},{"location":"firstproject/","text":"Your First Project Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import std::io; fn int main(String[] argv) { io::println(\"Hello World!\"); return 0; } Now in the terminal type: $ c3c compile hello_world.c3 $ ./hello_world Hello World $ A real project Once you go beyond simple files, you want to create a real project. Do so by entering c3c init hello_world . You will get the following structure: $ c3c init hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 project.json \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u251c\u2500\u2500 lib \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"Your first project"},{"location":"firstproject/#your-first-project","text":"Starting out with C3, you probably want to get a feel for the language, without using the integrated build system. Open a text editor and enter the following in a file you call hello_world.c3 : module hello_world; import std::io; fn int main(String[] argv) { io::println(\"Hello World!\"); return 0; } Now in the terminal type: $ c3c compile hello_world.c3 $ ./hello_world Hello World $","title":"Your First Project"},{"location":"firstproject/#a-real-project","text":"Once you go beyond simple files, you want to create a real project. Do so by entering c3c init hello_world . You will get the following structure: $ c3c init hello_world $ tree . . \u2514\u2500\u2500 hello_world \u251c\u2500\u2500 project.json \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 build \u251c\u2500\u2500 docs \u251c\u2500\u2500 lib \u251c\u2500\u2500 resources \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.c3 \u2514\u2500\u2500 test Enter main.c3 and write the same code as above, then anywhere in the project structure: $ c3c run Hello World $","title":"A real project"},{"location":"functions/","text":"Functions C3 has both regular functions and member functions. Member functions are functions namespaced using type names, and allows invocations using the dot syntax. Regular functions Regular functions are the same as C aside from the keyword fn , which is followed by the conventional C declaration of <return type> <name>(<parameter list>) . fn void test(int times) { for (int i = 0; i < times; i++) { io::printfn(\"Hello %d\", i); } } Function arguments C3 allows use of default arguments as well as named arguments. Note that any unnamed arguments must appear before any named arguments. fn int test_with_default(int foo = 1) { return foo; } fn void test() { test_with_default(); test_with_default(100); } Named arguments fn void test_named(int times, double data) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } fn void test() { // Named only test_named(.data = 3.0, .times = 1); // Unnamed only test_named(3, 4.0); // Mixing named and unnamed test_named(15, .data = 3.141592); } Named arguments with defaults: fn void test_named_default(int times = 1, double data = 3.0, bool dummy = false) { for (int i = 0; i < times; i++) { printfn(\"Hello %f\", i + data); } } fn void test() { // Named only test_named_default(.data = 3.5, .times = 10); // Unnamed and named test_named_default(3, .dummy = false); // Overwriting an unnamed argument with named is an error: // test_named_default(2, .times = 3); ERROR! // Unnamed may not follow named arguments. // test_named_default(.times = 3, 4.0); ERROR! } Varargs There are four types of varargs: single typed explicitly typed variants: pass non-variant arguments as references implicitly typed variants: arguments are implicitly converted to references (use with care) untyped C-style Examples: fn void va_singletyped(int... args) { /* args has type int[] */ } fn void va_variants_explicit(variant... args) { /* args has type variant[] */ } fn void va_variants_implicit(args...) { /* args has type variant[] */ } extern fn void va_untyped(...); // only used for extern C functions fn void test() { va_singletyped(1, 2, 3); int x = 1; variant v = &x; va_variants_explicit(&&1, &x, v); // pass references for non-variant arguments va_variants_implicit(1, x, \"foo\"); // arguments are implicitly converted to variants va_untyped(1, x, \"foo\"); // extern C-function } Functions and optional returns The return parameter may be an optional result type \u2013 a type suffixed by ! indicating that this function might either return a regular value or an optional result value . The below example might return optional values from both the SomeError optional enum as well as the OtherResult type. fn double! testError() { double val = random_value(); if (val >= 0.2) return SomeError.BAD_JOSS_ERROR!; if (val > 0.5) return OtherError.BAD_LUCK_ERROR!; return val; } A function call which is passed one or more optional result type arguments will only execute if all optional values contain expected results , otherwise the first optional result value is returned. fn void test() { // The following line is either prints a value less than 0.2 // or does not print at all: printf(\"%d\\n\", testError()); double x = (testError() + testError()) else 100; // This prints either a value less than 0.4 or 100: printf(\"%d\\n\", x); } This allows us to chain functions: fn void printInputWithExplicitChecks() { string! line = readLine(); if (try line) { // line is a regular \"string\" here. int! val = atoi(line); if (try val) { printf(\"You typed the number %d\\n\", val); return; } } printf(\"You didn't type an integer :(\\n\"); } fn void printInputWithChaining() { if (try int val = atoi(readLine())) { printf(\"You typed the number %d\\n\", val); return; } printf(\"You didn't type an integer :(\\n\"); } Methods Methods look exactly like functions, but are prefixed with the type name and is (usually) invoked using dot syntax: struct Point { int x; int y; } fn void Point.add(Point* p, int x) { p.x = x; } fn void example() { Point p = { 1, 2 } // with struct-functions p.add(10); // Also callable as: Point.add(&p, 10); } Struct and unions will always take pointer, whereas enums take the enum value. enum State { STOPPED, RUNNING } fn bool State.mayOpen(State state) { switch (state) { case STOPPED: return true; case RUNNING: return false; } } Restrictions on methods Methods on a struct/union may not have the same name as a member. Methods only works on distinct, struct, union and enum types. When taking a function pointer of a method, use the full name. Using sub types, overlapping function names will be shadowed. Contracts C3's error handling is not intended to use errors to signal invalid data or to check invariants and post conditions. Instead C3's approach is to add annotations to the function, that conditionally will be compiled into asserts. As an example, the following code: /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure return < 10000, return > 0 **/ fn int testFoo(int foo) { return foo * 10; } Will in debug builds be compiled into something like this: fn int testFoo(int foo) { assert(foo > 0); assert(foo < 1000); int _return = foo * 10; assert(_return < 10000); assert(_return > 0); return _return; } The compiler is allowed to use the contracts for optimizations. For example this: fn int testExample(int bar) { if (testFoo(bar) == 0) return -1; return 1; } May be optimized to: fn int testExample(int bar) { return 1; } In this case the compiler can look at the post condition of result > 0 to determine that testFoo(foo) == 0 must always be false. Looking closely at this code, we not that nothing guarantees that bar is not violating the preconditions. In Safe builds this will usually be checked in runtime, but a sufficiently smart compiler will warn about the lack of checks on bar . Execution of code violating pre and post conditions has unspecified behaviour. Short function declaration syntax For very short functions, C3 offers a \"short declaration\" syntax using => : // Regular fn int square(int x) { return x * x; } // Short fn int square_short(int x) => x * x; Lambdas It's possible to create anonymous functions using the regular fn syntax. Anonymous functions are identical to regular functions and do not capture variables from the surrounding scope: define IntTransform = fn int(int); fn void apply(int[] arr, IntTransform t) { foreach (&i : arr) *i = t(*i); } fn void main() { int[] x = { 1, 2, 5 }; // Short syntax with inference: apply(x, fn (i) => i * i); // Regular syntax without inference: // apply(x, fn int(int i) { return i * i; }); // Prints [1, 4, 25] io::printfln(\"%s\", x); } Static initializer and finalizers It is sometimes useful to run code at startup and shutdown. Static initializers and finalizers are special functions that are run at startup and shutdown respectively: static initialize { // Run at startup some_function.init(512); } static finalize { some_thing.shutdown(); } Note that invoking static finalize is an best effort attempt by the OS and may not be called during abnormal shutdown. Changing priority of static initializers and finalizers It is possible to use the attribute @priority(<priority>) to set the actual priority. It is recommended that programs use a priority of 1024 or higher. The higher the value, the later it will be called. The lowest priority is 65535. // Print \"Hello World\" at startup. static initialize @priority(3000) { io::println(\"World\"); } static initialize @priority(2000) { io::print(\"Hello \"); }","title":"Functions"},{"location":"functions/#functions","text":"C3 has both regular functions and member functions. Member functions are functions namespaced using type names, and allows invocations using the dot syntax.","title":"Functions"},{"location":"functions/#regular-functions","text":"Regular functions are the same as C aside from the keyword fn , which is followed by the conventional C declaration of <return type> <name>(<parameter list>) . fn void test(int times) { for (int i = 0; i < times; i++) { io::printfn(\"Hello %d\", i); } }","title":"Regular functions"},{"location":"functions/#function-arguments","text":"C3 allows use of default arguments as well as named arguments. Note that any unnamed arguments must appear before any named arguments. fn int test_with_default(int foo = 1) { return foo; } fn void test() { test_with_default(); test_with_default(100); } Named arguments fn void test_named(int times, double data) { for (int i = 0; i < times; i++) { printf(\"Hello %d\\n\", i + data); } } fn void test() { // Named only test_named(.data = 3.0, .times = 1); // Unnamed only test_named(3, 4.0); // Mixing named and unnamed test_named(15, .data = 3.141592); } Named arguments with defaults: fn void test_named_default(int times = 1, double data = 3.0, bool dummy = false) { for (int i = 0; i < times; i++) { printfn(\"Hello %f\", i + data); } } fn void test() { // Named only test_named_default(.data = 3.5, .times = 10); // Unnamed and named test_named_default(3, .dummy = false); // Overwriting an unnamed argument with named is an error: // test_named_default(2, .times = 3); ERROR! // Unnamed may not follow named arguments. // test_named_default(.times = 3, 4.0); ERROR! }","title":"Function arguments"},{"location":"functions/#varargs","text":"There are four types of varargs: single typed explicitly typed variants: pass non-variant arguments as references implicitly typed variants: arguments are implicitly converted to references (use with care) untyped C-style Examples: fn void va_singletyped(int... args) { /* args has type int[] */ } fn void va_variants_explicit(variant... args) { /* args has type variant[] */ } fn void va_variants_implicit(args...) { /* args has type variant[] */ } extern fn void va_untyped(...); // only used for extern C functions fn void test() { va_singletyped(1, 2, 3); int x = 1; variant v = &x; va_variants_explicit(&&1, &x, v); // pass references for non-variant arguments va_variants_implicit(1, x, \"foo\"); // arguments are implicitly converted to variants va_untyped(1, x, \"foo\"); // extern C-function }","title":"Varargs"},{"location":"functions/#functions-and-optional-returns","text":"The return parameter may be an optional result type \u2013 a type suffixed by ! indicating that this function might either return a regular value or an optional result value . The below example might return optional values from both the SomeError optional enum as well as the OtherResult type. fn double! testError() { double val = random_value(); if (val >= 0.2) return SomeError.BAD_JOSS_ERROR!; if (val > 0.5) return OtherError.BAD_LUCK_ERROR!; return val; } A function call which is passed one or more optional result type arguments will only execute if all optional values contain expected results , otherwise the first optional result value is returned. fn void test() { // The following line is either prints a value less than 0.2 // or does not print at all: printf(\"%d\\n\", testError()); double x = (testError() + testError()) else 100; // This prints either a value less than 0.4 or 100: printf(\"%d\\n\", x); } This allows us to chain functions: fn void printInputWithExplicitChecks() { string! line = readLine(); if (try line) { // line is a regular \"string\" here. int! val = atoi(line); if (try val) { printf(\"You typed the number %d\\n\", val); return; } } printf(\"You didn't type an integer :(\\n\"); } fn void printInputWithChaining() { if (try int val = atoi(readLine())) { printf(\"You typed the number %d\\n\", val); return; } printf(\"You didn't type an integer :(\\n\"); }","title":"Functions and optional returns"},{"location":"functions/#methods","text":"Methods look exactly like functions, but are prefixed with the type name and is (usually) invoked using dot syntax: struct Point { int x; int y; } fn void Point.add(Point* p, int x) { p.x = x; } fn void example() { Point p = { 1, 2 } // with struct-functions p.add(10); // Also callable as: Point.add(&p, 10); } Struct and unions will always take pointer, whereas enums take the enum value. enum State { STOPPED, RUNNING } fn bool State.mayOpen(State state) { switch (state) { case STOPPED: return true; case RUNNING: return false; } }","title":"Methods"},{"location":"functions/#restrictions-on-methods","text":"Methods on a struct/union may not have the same name as a member. Methods only works on distinct, struct, union and enum types. When taking a function pointer of a method, use the full name. Using sub types, overlapping function names will be shadowed.","title":"Restrictions on methods"},{"location":"functions/#contracts","text":"C3's error handling is not intended to use errors to signal invalid data or to check invariants and post conditions. Instead C3's approach is to add annotations to the function, that conditionally will be compiled into asserts. As an example, the following code: /** * @param foo : the number of foos * @require foo > 0, foo < 1000 * @return number of foos x 10 * @ensure return < 10000, return > 0 **/ fn int testFoo(int foo) { return foo * 10; } Will in debug builds be compiled into something like this: fn int testFoo(int foo) { assert(foo > 0); assert(foo < 1000); int _return = foo * 10; assert(_return < 10000); assert(_return > 0); return _return; } The compiler is allowed to use the contracts for optimizations. For example this: fn int testExample(int bar) { if (testFoo(bar) == 0) return -1; return 1; } May be optimized to: fn int testExample(int bar) { return 1; } In this case the compiler can look at the post condition of result > 0 to determine that testFoo(foo) == 0 must always be false. Looking closely at this code, we not that nothing guarantees that bar is not violating the preconditions. In Safe builds this will usually be checked in runtime, but a sufficiently smart compiler will warn about the lack of checks on bar . Execution of code violating pre and post conditions has unspecified behaviour.","title":"Contracts"},{"location":"functions/#short-function-declaration-syntax","text":"For very short functions, C3 offers a \"short declaration\" syntax using => : // Regular fn int square(int x) { return x * x; } // Short fn int square_short(int x) => x * x;","title":"Short function declaration syntax"},{"location":"functions/#lambdas","text":"It's possible to create anonymous functions using the regular fn syntax. Anonymous functions are identical to regular functions and do not capture variables from the surrounding scope: define IntTransform = fn int(int); fn void apply(int[] arr, IntTransform t) { foreach (&i : arr) *i = t(*i); } fn void main() { int[] x = { 1, 2, 5 }; // Short syntax with inference: apply(x, fn (i) => i * i); // Regular syntax without inference: // apply(x, fn int(int i) { return i * i; }); // Prints [1, 4, 25] io::printfln(\"%s\", x); }","title":"Lambdas"},{"location":"functions/#static-initializer-and-finalizers","text":"It is sometimes useful to run code at startup and shutdown. Static initializers and finalizers are special functions that are run at startup and shutdown respectively: static initialize { // Run at startup some_function.init(512); } static finalize { some_thing.shutdown(); } Note that invoking static finalize is an best effort attempt by the OS and may not be called during abnormal shutdown.","title":"Static initializer and finalizers"},{"location":"functions/#changing-priority-of-static-initializers-and-finalizers","text":"It is possible to use the attribute @priority(<priority>) to set the actual priority. It is recommended that programs use a priority of 1024 or higher. The higher the value, the later it will be called. The lowest priority is 65535. // Print \"Hello World\" at startup. static initialize @priority(3000) { io::println(\"World\"); } static initialize @priority(2000) { io::print(\"Hello \"); }","title":"Changing priority of static initializers and finalizers"},{"location":"generics/","text":"Generics Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: // TypeA, TypeB, TypeC are generic parameters. module vector <TypeA, TypeB, TypeC>; The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test <Type1, Type2>; struct Foo { Type1 a; } fn Type2 test(Type2 b, Foo *foo) { return foo.a + b; } Including a generic module works as usual, but to use a type, it must be defined before use. define FooFloat = Foo<float, double>; define testFloat = foo_test::test<float, double>; ... FooFloat f; ... testFloat(1.0, &f); Just like for macros, optional constraints may be added to improve compile errors: *Note: constraints are not feature complete /** * @require $checks(TypeA a = (TypeB)1 + (TypeC)1) */ module vector <TypeA, TypeB, TypeC>; /* .. code * ../ define testFunction = vector::testFunc<Bar, float, int>; // This would give the error // --> Illegal arguments for generic module vector, // breaks check 'Bar a = (float)1 + (int)1'","title":"Generics"},{"location":"generics/#generics","text":"Generic modules are parameterized modules that allow functionality for arbitrary types. For generic modules, the generic parameters follows the module name: // TypeA, TypeB, TypeC are generic parameters. module vector <TypeA, TypeB, TypeC>; The code inside of the module can use the generic parameters as if they were well defined symbols: module foo_test <Type1, Type2>; struct Foo { Type1 a; } fn Type2 test(Type2 b, Foo *foo) { return foo.a + b; } Including a generic module works as usual, but to use a type, it must be defined before use. define FooFloat = Foo<float, double>; define testFloat = foo_test::test<float, double>; ... FooFloat f; ... testFloat(1.0, &f); Just like for macros, optional constraints may be added to improve compile errors: *Note: constraints are not feature complete /** * @require $checks(TypeA a = (TypeB)1 + (TypeC)1) */ module vector <TypeA, TypeB, TypeC>; /* .. code * ../ define testFunction = vector::testFunc<Bar, float, int>; // This would give the error // --> Illegal arguments for generic module vector, // breaks check 'Bar a = (float)1 + (int)1'","title":"Generics"},{"location":"ideas/","text":"Ideas WARNING Unfinished ideas / brain dumps Static initializers Allow initialization of globals before main is invoked. Introduce a general static block. module foo; int x; static { x = rand(); } int y = rand(); fn int randomCalculation() { return rand(); } Sematic roughly work like in Java, except that all know globals are initialized before main, as opposed to when the class is invoked. The order of initialization is unspecified. Module versioning Go Modules: Build file contains required library versions: e.g. 2.5.7 First number is major version number and is considered incompatible (basically a different module completely) Dependency resolution per major library version is done by picking the minimal version. E.g. module Foo requires Bar 1.5+ and module Baz requires 1.3+. Our module using Bar and Baz will resolve the minimal version to 1.5. This is the version that will be used. Note that if Foo used 2.5+, then both Bar 2.5 and 1.3 would be required. Possible design: 1. Dependency contains no-version, major version, minor version, major + minor + build or list of major versions 2. Try to resolve the major version to use. If none is selected, pick max. More than one are required -> compile error (example: A needs 1, 2, B needs 2, 3 => pick 2, A needs 1, 2, B needs 3, 4 => error) 3. Pick the maximum minor + build version available. If this is less than minimum minor + build version needed => error. 4. Excluding versions should be possible, eg exclude 1.3.4 Generic as keyword for polymorphic functions For macros that essentially are polymorphic functions, we could use the keyword \"generic\" instead: macro swap(&a, &b) { ... } // Cannot be generic, captures are not allowed. macro max(a, b) { ... } // Can be generic macro doSomething(a, #a) { ... } // Cannot be generic, uses unevaluated expressions macro malloc($Type) { ... } // Can be generic. // Example of \"max\": generic max(a, b) { return a > b ? b : a; } // Example of \"malloc\" generic malloc($Type) { _builtin_malloc($Type.sizeof); } Invocation changes: int max_value = @max(foo(), bar()); // macro int max_value = max(foo(), bar()); // generic This would furthermore remove the \"!\" addition for escaping macros, adding it as an attribute: macro returnme() @escaping { return; } Macros could then also more natural invoke defer: macro deferclose() @scopeless { defer close(); } Both would be invoked: @deferclose(); @returnme(); It would be possible to define a generic, such a generic could be taken the address of: #define intmax = max(int, int); #define TwoIntfn = fn int(int, int); TwoIntFunc x = &intmax; Associative array literals Syntax and implementation under consideration! Associative arrays are mappings between keys and values: IntStringMap x = { \"a\": 2, \"b\": { \"3\" : \"foo\" } }; To use an associative array, the struct needs to define the following generics: _map_init() and _map_init_add . In the example above, the actual code is compiled to: IntStringMap x; _map_init(&x); _map_init_add(&x, \"a\", 2); IntStringMap _temp; _map_init(&_temp); _map_init_add(&x, \"3\", \"foo\"); _map_init_add(&x, \"b\", _temp); Array literals Arrays can be initialized using compound literals, but there is also a special format for array initialization using [] . In this case, the type is inferred. It allows uniform initialization of all types of arrays: int[3] y = [1, 2, 3]; // Fixed array allocated on the stack int[] z = [1, 2, 3]; // Slice pointing at literal allocated on the stack It offers some convenience when calling functions taking arrays: fn void test1(int[3] x) { ... } fn void test2(int[] y) { ... } fn void test2(int[3]* z) { ... } test1([ 1, 2, 3 ]); test2([ 1, 2, 3 ]); test3([ 1, 2, 3 ]); Allow slicing of user defined containers // Supporting the full set. macro Foo._slice(Foo* foo, a, b, $a_from_end, $b_from_end) { $if ($a_from_end): $if ($b_from_end): return foo.values[^a..^b]; $endif: return foo.values[^a..b]; $endif; $if ($b_from_end): return foo.values[a..^b]; $endif; return foo.values[a..b]; } // Not supporting reverse macro Bar._slice(Bar *bar, a, b, $a_from_end, $b_from_end) { $assert(!$a_from_end && !$b_from_end, \"Slicing from the end is not possible for Bar types.\"); return bar.valyes[a..b]; } Allow narrowing conversions for floats Narrowing conversions for double -> float are common and might not be sufficiently important to do explicitly. Tests built in Unit tests built in as an integral part of the language like D. Attribute to ensure alignment @assertalign works as GCCs warn_if_not_aligned. On non packed structs, this will prevent compilation if padding is inserted in front of the member. On a packed struct, it will prevent compilation if it is not aligned. Binary include The ability to include a binary file during compile time. An additional embed-path gives search dirs. byte[] file = @binary_include(\"foo.dat\"); Limiting embed to x bytes: byte[] file = @binary_include(\"/dev/urandomg\", 16); Compile time run-include The ability to run a piece of code at compile time and include the result in the code. @run_include(\"foo.sh\", $some_param, \"-x\", $another_param); Macro text interpolation For certain cases, pure text interpolation might be needed. Within macros, any text within `` can be evaluated and parsed. macro void @foo($x, #f) { `#f $x * $x`; } fn void test() { int x = 1; @foo(4, \"x +=\"); // Expands to -> // x += 4 * 4; } Another example, showing the difference between #var and `#var` : macro void @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { int x = 1; @foo2(x); // Expands to -> // printf(\"%s was %d\\n\", \"x\", x); } Compile time string functions In order to facilitate certain types of macros, the following macros are built in: @strToUpper(#f) Convert string to upper case. @strToLower(#f) Convert string to lower case. @strToVarName(#f, #space) Convert string to camel case from a space-based name scheme. @strToTypeName(#f, #space) Convert string to title case from a space-based name scheme. @strFromName(#f, #space) Convert title case or lower camel case to a space based scheme. @strReplace(#str, #pattern, #replacement, #count) Replace a string with another. @subString(#str, #start, #length) Return a substring of a compile time string. @strFind(#str, #stringToFind) Find a substring in a compile time string. @strHash(#str) Return the FNV1a hash of a string. @strLen(#str) Return a compile time length of a string. @stringify(#str) Escapes a string so it becomes a valid string. Implicit \"this\" in method functions struct Foo { int i; } fn Foo.next(Foo*) { i++; } Unsorted Tagged any A tagged pointer union type for any possible type. Easy to get properties Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports Associate properties to an enum enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" } Tagged unions tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And another... struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { struct square { int side; } struct rectangle { int length; int height; } struct circle { int radius; } } } And yet another... struct Shape { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; } Built in maps Same reasoning as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = map[0]!!; // Requires a rethrow // Retrive or use default int i = try map[12] else -1; // Extend a map: fn bool int[int].remove_if_negative(int[int] *map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int *map, int32_t index); Built in managed pointers Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check.","title":"Crazy ideas"},{"location":"ideas/#ideas","text":"WARNING Unfinished ideas / brain dumps","title":"Ideas"},{"location":"ideas/#static-initializers","text":"Allow initialization of globals before main is invoked. Introduce a general static block. module foo; int x; static { x = rand(); } int y = rand(); fn int randomCalculation() { return rand(); } Sematic roughly work like in Java, except that all know globals are initialized before main, as opposed to when the class is invoked. The order of initialization is unspecified.","title":"Static initializers"},{"location":"ideas/#module-versioning","text":"Go Modules: Build file contains required library versions: e.g. 2.5.7 First number is major version number and is considered incompatible (basically a different module completely) Dependency resolution per major library version is done by picking the minimal version. E.g. module Foo requires Bar 1.5+ and module Baz requires 1.3+. Our module using Bar and Baz will resolve the minimal version to 1.5. This is the version that will be used. Note that if Foo used 2.5+, then both Bar 2.5 and 1.3 would be required. Possible design: 1. Dependency contains no-version, major version, minor version, major + minor + build or list of major versions 2. Try to resolve the major version to use. If none is selected, pick max. More than one are required -> compile error (example: A needs 1, 2, B needs 2, 3 => pick 2, A needs 1, 2, B needs 3, 4 => error) 3. Pick the maximum minor + build version available. If this is less than minimum minor + build version needed => error. 4. Excluding versions should be possible, eg exclude 1.3.4","title":"Module versioning"},{"location":"ideas/#generic-as-keyword-for-polymorphic-functions","text":"For macros that essentially are polymorphic functions, we could use the keyword \"generic\" instead: macro swap(&a, &b) { ... } // Cannot be generic, captures are not allowed. macro max(a, b) { ... } // Can be generic macro doSomething(a, #a) { ... } // Cannot be generic, uses unevaluated expressions macro malloc($Type) { ... } // Can be generic. // Example of \"max\": generic max(a, b) { return a > b ? b : a; } // Example of \"malloc\" generic malloc($Type) { _builtin_malloc($Type.sizeof); } Invocation changes: int max_value = @max(foo(), bar()); // macro int max_value = max(foo(), bar()); // generic This would furthermore remove the \"!\" addition for escaping macros, adding it as an attribute: macro returnme() @escaping { return; } Macros could then also more natural invoke defer: macro deferclose() @scopeless { defer close(); } Both would be invoked: @deferclose(); @returnme(); It would be possible to define a generic, such a generic could be taken the address of: #define intmax = max(int, int); #define TwoIntfn = fn int(int, int); TwoIntFunc x = &intmax;","title":"Generic as keyword for polymorphic functions"},{"location":"ideas/#associative-array-literals","text":"Syntax and implementation under consideration! Associative arrays are mappings between keys and values: IntStringMap x = { \"a\": 2, \"b\": { \"3\" : \"foo\" } }; To use an associative array, the struct needs to define the following generics: _map_init() and _map_init_add . In the example above, the actual code is compiled to: IntStringMap x; _map_init(&x); _map_init_add(&x, \"a\", 2); IntStringMap _temp; _map_init(&_temp); _map_init_add(&x, \"3\", \"foo\"); _map_init_add(&x, \"b\", _temp);","title":"Associative array literals"},{"location":"ideas/#array-literals","text":"Arrays can be initialized using compound literals, but there is also a special format for array initialization using [] . In this case, the type is inferred. It allows uniform initialization of all types of arrays: int[3] y = [1, 2, 3]; // Fixed array allocated on the stack int[] z = [1, 2, 3]; // Slice pointing at literal allocated on the stack It offers some convenience when calling functions taking arrays: fn void test1(int[3] x) { ... } fn void test2(int[] y) { ... } fn void test2(int[3]* z) { ... } test1([ 1, 2, 3 ]); test2([ 1, 2, 3 ]); test3([ 1, 2, 3 ]);","title":"Array literals"},{"location":"ideas/#allow-slicing-of-user-defined-containers","text":"// Supporting the full set. macro Foo._slice(Foo* foo, a, b, $a_from_end, $b_from_end) { $if ($a_from_end): $if ($b_from_end): return foo.values[^a..^b]; $endif: return foo.values[^a..b]; $endif; $if ($b_from_end): return foo.values[a..^b]; $endif; return foo.values[a..b]; } // Not supporting reverse macro Bar._slice(Bar *bar, a, b, $a_from_end, $b_from_end) { $assert(!$a_from_end && !$b_from_end, \"Slicing from the end is not possible for Bar types.\"); return bar.valyes[a..b]; }","title":"Allow slicing of user defined containers"},{"location":"ideas/#allow-narrowing-conversions-for-floats","text":"Narrowing conversions for double -> float are common and might not be sufficiently important to do explicitly.","title":"Allow narrowing conversions for floats"},{"location":"ideas/#tests-built-in","text":"Unit tests built in as an integral part of the language like D.","title":"Tests built in"},{"location":"ideas/#attribute-to-ensure-alignment","text":"@assertalign works as GCCs warn_if_not_aligned. On non packed structs, this will prevent compilation if padding is inserted in front of the member. On a packed struct, it will prevent compilation if it is not aligned.","title":"Attribute to ensure alignment"},{"location":"ideas/#binary-include","text":"The ability to include a binary file during compile time. An additional embed-path gives search dirs. byte[] file = @binary_include(\"foo.dat\"); Limiting embed to x bytes: byte[] file = @binary_include(\"/dev/urandomg\", 16);","title":"Binary include"},{"location":"ideas/#compile-time-run-include","text":"The ability to run a piece of code at compile time and include the result in the code. @run_include(\"foo.sh\", $some_param, \"-x\", $another_param);","title":"Compile time run-include"},{"location":"ideas/#macro-text-interpolation","text":"For certain cases, pure text interpolation might be needed. Within macros, any text within `` can be evaluated and parsed. macro void @foo($x, #f) { `#f $x * $x`; } fn void test() { int x = 1; @foo(4, \"x +=\"); // Expands to -> // x += 4 * 4; } Another example, showing the difference between #var and `#var` : macro void @foo2(#f) { printf(\"%s was %d\\n\", #f, `#f`); } funct void test2() { int x = 1; @foo2(x); // Expands to -> // printf(\"%s was %d\\n\", \"x\", x); }","title":"Macro text interpolation"},{"location":"ideas/#compile-time-string-functions","text":"In order to facilitate certain types of macros, the following macros are built in: @strToUpper(#f) Convert string to upper case. @strToLower(#f) Convert string to lower case. @strToVarName(#f, #space) Convert string to camel case from a space-based name scheme. @strToTypeName(#f, #space) Convert string to title case from a space-based name scheme. @strFromName(#f, #space) Convert title case or lower camel case to a space based scheme. @strReplace(#str, #pattern, #replacement, #count) Replace a string with another. @subString(#str, #start, #length) Return a substring of a compile time string. @strFind(#str, #stringToFind) Find a substring in a compile time string. @strHash(#str) Return the FNV1a hash of a string. @strLen(#str) Return a compile time length of a string. @stringify(#str) Escapes a string so it becomes a valid string.","title":"Compile time string functions"},{"location":"ideas/#implicit-this-in-method-functions","text":"struct Foo { int i; } fn Foo.next(Foo*) { i++; }","title":"Implicit \"this\" in method functions"},{"location":"ideas/#unsorted","text":"","title":"Unsorted"},{"location":"ideas/#tagged-any","text":"A tagged pointer union type for any possible type.","title":"Tagged any"},{"location":"ideas/#easy-to-get-properties","text":"Endianness Register size Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type) Query what type of overflow the processor supports","title":"Easy to get properties"},{"location":"ideas/#associate-properties-to-an-enum","text":"enum State [char* name, byte bit] int { START(\"begin!\", 0x01) = 0, END(\"end it!\", 0x10) } funct void test() { printf(\"%s\\n\", State.START.name); // Prints \"begin!\" printf(\"%d\\n\", State.END.bit); // Prints \"16\" }","title":"Associate properties to an enum"},{"location":"ideas/#tagged-unions","text":"tagged union Foo { int i; const char *c; }; Foo foo; foo.i = 3; @istag(foo.i) // => true @istag(foo.c) // => false foo.c = \"hello\"; @istag(foo.i) // => false @istag(foo.c) // => true switch(@tag(foo)) { case Foo.i: printf(\"Was %d\\n\", foo.i); case Foo.c: printf(\"Was %s\\n\", foo.c); } Alternative syntax etc: struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { SQUARE: { int side; } RECTANGLE: { int length, height; } CIRCLE: { int radius; } } } And another... struct Shape { int centerX; int centerY; byte kind; // Implicit enum union (kind) { struct square { int side; } struct rectangle { int length; int height; } struct circle { int radius; } } } And yet another... struct Shape { int centerX; int centerY; tagged union (kind) { case SQUARE: int side; case RECTANGLE: int length; int height; case CIRCLE: int radius; } byte kind; }","title":"Tagged unions"},{"location":"ideas/#built-in-maps","text":"Same reasoning as arrays. Question about memory management is the same. int[int] map; // Built-in maps map[1] = 11; // Retrieving a value int i = map[0]!!; // Requires a rethrow // Retrive or use default int i = try map[12] else -1; // Extend a map: fn bool int[int].remove_if_negative(int[int] *map, int index) { if (try map[index] >= 0 else true) return false; map.remove(index); return true; } // The underlying C function becomes: // bool module_name__map_int_int__remove_if_negative(struct _map_int_int *map, int32_t index);","title":"Built in maps"},{"location":"ideas/#built-in-managed-pointers","text":"Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities: Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership. Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -> unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such. Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check.","title":"Built in managed pointers"},{"location":"libraries/","text":"Libraries Note, the library system is in early alpha, everything below is subject to change C3 allows convenient packaging of C3 source files optionally with statically or dynamically linked libraries. To use such a library, simply pass the path to the library directory and add the library you wish to link to. The compiler will resolve any dependencies to other libraries and only compile those that are in use. How it works A library may be used either packaged or unpacked. If unpacked, it is simply a directory with the .c3l suffix, which contains all the necessary files, if packed, this is simply a compressed variant of a directory with the same structure. The specification In the top of the library resides the manifest.json file which has the following structure: { \"provides\" : \"my_lib\", \"targets\" : { \"macos-x64\" : { \"linkflags\" : [], \"dependencies\" : [], \"linked-libs\" : [\"my_lib_static\", \"Cocoa.framework\", \"c\"] }, \"windows-x64\" : { \"linkflags\" : [\"/stack:65536\"], \"dependencies\" : [\"ms_my_extra\"], \"linked-libs\" : [\"my_lib_static\", \"kernel32\"] } } } In the example here, this library supports two targets: macos-x64 and windows-x64 . If we tried to use it with any other target, the compiler would give an error. We see that if we use the windows-x64 target it will also load the ms_my_extra library. And we also see that the linker would have a special argument on that platform. Both targets expect my_lib_static to be available for linking. If this library provides this or dynamic library it will be in the target sub directories, so it likely has the path windows-x64/my_lib_static.lib and macos-z64/libmy_lib_static.a . Source code Aside from the manifest, C3 will read any C and C3 files in the same directory as manifest.json as well as any files in the target subdirectory for the current target. For static libraries typically a .c3i file (that is, a C3 file without any implementations) is provided, similar to how .h files are used in C. How to \u2013 automatically \u2013 export libraries This is not implemented yet, docs will materialize once it is finished","title":"Libraries"},{"location":"libraries/#libraries","text":"Note, the library system is in early alpha, everything below is subject to change C3 allows convenient packaging of C3 source files optionally with statically or dynamically linked libraries. To use such a library, simply pass the path to the library directory and add the library you wish to link to. The compiler will resolve any dependencies to other libraries and only compile those that are in use.","title":"Libraries"},{"location":"libraries/#how-it-works","text":"A library may be used either packaged or unpacked. If unpacked, it is simply a directory with the .c3l suffix, which contains all the necessary files, if packed, this is simply a compressed variant of a directory with the same structure.","title":"How it works"},{"location":"libraries/#the-specification","text":"In the top of the library resides the manifest.json file which has the following structure: { \"provides\" : \"my_lib\", \"targets\" : { \"macos-x64\" : { \"linkflags\" : [], \"dependencies\" : [], \"linked-libs\" : [\"my_lib_static\", \"Cocoa.framework\", \"c\"] }, \"windows-x64\" : { \"linkflags\" : [\"/stack:65536\"], \"dependencies\" : [\"ms_my_extra\"], \"linked-libs\" : [\"my_lib_static\", \"kernel32\"] } } } In the example here, this library supports two targets: macos-x64 and windows-x64 . If we tried to use it with any other target, the compiler would give an error. We see that if we use the windows-x64 target it will also load the ms_my_extra library. And we also see that the linker would have a special argument on that platform. Both targets expect my_lib_static to be available for linking. If this library provides this or dynamic library it will be in the target sub directories, so it likely has the path windows-x64/my_lib_static.lib and macos-z64/libmy_lib_static.a .","title":"The specification"},{"location":"libraries/#source-code","text":"Aside from the manifest, C3 will read any C and C3 files in the same directory as manifest.json as well as any files in the target subdirectory for the current target. For static libraries typically a .c3i file (that is, a C3 file without any implementations) is provided, similar to how .h files are used in C.","title":"Source code"},{"location":"libraries/#how-to-automatically-export-libraries","text":"This is not implemented yet, docs will materialize once it is finished","title":"How to \u2013 automatically \u2013 export libraries"},{"location":"macros/","text":"Macros The macro capabilities of C3 reaches across several constructs: macros (prefixed with @ at invocation), generic functions , generic modules , compile time variables (prefixed with $ ), macro compile time execution (using $if , $for , $foreach , $switch ) and attributes. A quick comparison of C and C3 macros Conditional compilation // C #if defined(x) && Y > 3 int z; #endif // C3 $if ($defined(x) && $y > 3): int z; $endif; Macros // C #define M(x) ((x) + 2) #define UInt32 unsigned int // Use: int y = M(foo() + 2); UInt32 b = y; // C3 macro m(x) { return x + 2; } define UInt32 = uint; // Use: int y = @m(foo() + 2); UInt32 b = y; Dynamic scoping // C #define Z() ptr->x->y->z int x = Z(); // C3 ... currently no corresponding functionality ... Reference arguments Use & in front of a parameter to capture the variable and pass it by reference without having to explicitly use & and pass a pointer. (Note that in C++ this is allowed for normal functions, whereas for C3 it is only permitted with macros.) // C #define M(x, y) x = 2 * (y); // C3 macro m(int &x, int y) { x = 2 * y; } First class types // C #define SIZE(T) (sizeof(T) + sizeof(int)) // C3 macro size($Type) { return $Type.sizeof + int.sizeof; } Trailing blocks for macros // C #define FOR_EACH(x, list) \\ for (x = (list); x; x = x->next) // Use: Foo *it; FOR_EACH(it, list) { if (!process(it)) return; } // C3 macro for_each(list; @body(it)) { for ($typeof(list) x = list; x; x = x.next) { @body(x); } } // Use: @for_each(list; Foo* x) { if (!process(x)) return; } First class names // C #define offsetof(T, field) (size_t)(&((T*)0)->field) // C3 macro usz offset($Type, #field) { $Type* t = null; return (usz)(uptr)&t.#field; } Declaration attributes // C #define PURE_INLINE __attribute__((pure)) __attribute__((always_inline)) int foo(int x) PURE_INLINE { ... } // C3 define @PureInline = @pure, @inline fn int foo(int) @PureInline { ... } Declaration macros // C #define DECLARE_LIST(name) List name = { .head = NULL }; // Use: DECLARE_LIST(hello) // C3 ... currently no corresponding functionality ... Stringification #define CHECK(x) do { if (!x) abort(#x); } while(0) // C3 macro fn check(#expr) { if (!#expr) abort($stringify(#expr)); } Top level evaluation Script languages, and also upcoming languages like Jai , usually have unbounded top level evaluation. The flexibility of this style of meta programming has a trade off in making the code more challenging to understand. In C3, top level compile time evaluation is limited to $if and $switch constructs + macros with constant expression evaluation. This makes the code easier to read, but at the cost of expressive power. Macro declarations A macro is defined using macro <name>(<parameters>) . All user defined macros use the @ symbol if they use the & or # parameters. The parameters have different sigils: $ means compile time evaluated (constant expression or type). # indicates an expression that is not yet evaluated, but is bound to where it was defined. Finally & is used to implicitly pass a parameter by reference. @ is required on macros that use # and & parameters. A basic swap: /** * @checked a = b, b = a */ macro void @swap(&a, &b) { $typeof(a) temp = a; a = b; b = temp; } This expands on usage like this: fn void test() { int a = 10; int b = 20; @swap(a, b); } // Equivalent to: fn void test() { int a = 10; int b = 20; { int __temp = a; a = b; b = __temp; } } Note the necessary & . Here is an incorrect swap and what it would expand to: macro void badswap(a, b) { $typeof(a) temp = a; a = b; b = temp; } fn void test() { int a = 10; int b = 20; badswap(a, b); } // Equivalent to: fn void test() { int a = 10; int b = 20; { int __a = a; int __b = b; int __temp = __a; __a = __b; __b = __temp; } } Macro methods Similar to regular methods a macro may also be associated with a particular type: struct Foo { ... } macro Foo.generate(Foo *foo) { ... } Foo f; f.generate(); Capturing a trailing block It is often useful for a macro to take a trailing compound statement as an argument. In C++ this pattern is usually expressed with a lambda, but in C3 this is completely inlined. To accept a trailing block, ; @name(param1, ...) is placed after declaring the regular macro parameters. Here's an example to illustrate its use: /** * A macro looping through a list of values, executing the body once * every pass. * * @checked { int i = a.len; value2 = a[i]; } **/ macro @foreach(a; @body(index, value)) { for (int i = 0; i < a.len; i++) { @body(i, a[i]); } } fn void test() { double[] a = { 1.0, 2.0, 3.0 }; @foreach(a; int index, double value) { io::printfn(\"a[%d] = %f\", index, value); } } // Expands to code similar to: fn void test() { int[] a = { 1, 2, 3 }; { int[] __a = a; for (int __i = 0; i < __a.len; i++) { io::printfn(\"Value: %d, x2: %d\", __value1, __value2); } } } Macros returning values A macro may return a value, it is then considered an expression rather than a statement: macro square(x) { return x * x; } fn int getTheSquare(int x) { return square(x); } fn double getTheSquare2(double x) { return square(x); } Calling macros It's perfectly fine for a macro to invoke another macro or itself. macro square(x) { return x * x; } macro squarePlusOne(x) { return square(x) + 1; // Expands to \"return x * x + 1;\" } The maximum recursion depth is limited to the macro-recursion-depth build setting. Macro vaargs Macros support the typed vaargs used by C3 functions: macro void foo(int... args) and macro void bar(args...) but it also supports a unique set of macro vaargs that look like C style vaargs: macro void baz(...) To access the arguments there is a family of $va-* built in functions to retrieve the arguments: macro compile_time_sum(...) { var $x = 0; $for (var $i = 0; $i < $vacount(); $i++): $x += $vaconst($i); $endfor; return $x; } $if (compile_time_sum(1, 3) > 2): // Will compile to $if (4 > 2) ... $endif; $vacount Returns the number of arguments. $vaarg Returns the argument as a regular parameter. The argument is guaranteed to be evaluated once, even if the argument is used multiple times. $vaconst Returns the argument as a compile time constant, this is suitable for placing in a compile time variable or use for compile time evaluation, e.g. $foo = $vaconst(1) . This corresponds to $ parameters. $vaexpr Returns the argument as an unevaluated expression. Multiple uses will evaluate the expression multiple times, this corresponds to # parameters. $vatype Returns the argument as a type. This corresponds to $Type style parameters, e.g. $vatype(2) a = 2 $varef Returns the argument as an lvalue. This corresponds to &myref style parameters, e.g. $varef(1) = 123 . Untyped lists Compile time variables may hold untyped lists. Such lists may be iterated over or implicitly converted to initializer lists: var $a = { 1, 2 }; $foreach ($x : $a): io::printfn(\"%d\", $x); $endforeach; int[2] x = $a; io::printfn(\"%s\", x); io::printfn(\"%s\", $a[1]); // Will print // 1 // 2 // [1, 2] // 2 Macro directives Inside of a macro, we can use the compile time statements $if , $for and $switch . Macros may also be recursively invoked. As previously mentioned, $if and $switch may also be invoked on the top level. $if, $else and $elif $if (<const expr>): takes a compile time constant value and evaluates it to true or false. macro foo($x, $y) { $if ($x > 3): $y += $x * $x; $else: $y += $x; $endif; } const int FOO = 10; fn void test() { int a = 5; int b = 4; foo(1, a); // Allowed, expands to a += 1; // foo(b, a); // Error: b is not a compile time constant. foo(FOO, a); // Allowed, expands to a += FOO * FOO; } Loops using $foreach and $for $foreach (<range> : <variable>): ... $endforeach; allows compile time recursion. $foreach may recurse over enums, struct fields or constant ranges. Everything must be known at compile time. Compile time looping: macro foo($a) { $for (var $x = 0; $x < $a; $x++): io::printfn(\"%d\", $x); $endfor; } fn void test() { foo(2); // Expands to -> // io::printfn(\"%d\", 0); // io::printfn(\"%d\", 1); } Looping over enums: macro foo_enum($SomeEnum) { $foreach ($x : $SomeEnum.values): io::printfn(\"%d\", (int)$x); $endforeach; } enum MyEnum { A, B, } fn void test() { foo_enum(MyEnum); // Expands to -> // io::printfn(\"%d\", (int)MyEnum.A); // io::printfn(\"%d\", (int)MyEnum.B); } An important thing to note is that the content of the $foreeach or $for body must be a complete statement. It's not possible to compile partial statements. Switching on type with $switch It's possible to switch on type: macro void foo(a, b) { $switch(a, b): $case int, int: return a * b; $endswitch; return a + b; } Conditional macros at the top level A limitation with the macros is that they are only used within functions. This is deliberate \u2013 macros expanding at the top level are much harder to reason about since they should be able to define new types or change the meaning of the code that follows. Still, the usefulness of top level macros is great, which is why C3 offers three pieces of functionality for the top level: conditional compilation, global constants and attributes Conditional compilation Conditional compilation is done with $if and $else , which works just like inside of functions. $if ($defined(platform::OS) && platform::OS == WIN32): fn void doSomethingWin32Specific() { /* .... */ } $endif; Global constants Global constant on the top level work like compile time variables in macros \u2013 with the exception that they must always be declared constant. They are evaluated in order, but will resolve on-demand if needed.","title":"Macros"},{"location":"macros/#macros","text":"The macro capabilities of C3 reaches across several constructs: macros (prefixed with @ at invocation), generic functions , generic modules , compile time variables (prefixed with $ ), macro compile time execution (using $if , $for , $foreach , $switch ) and attributes.","title":"Macros"},{"location":"macros/#a-quick-comparison-of-c-and-c3-macros","text":"","title":"A quick comparison of C and C3 macros"},{"location":"macros/#conditional-compilation","text":"// C #if defined(x) && Y > 3 int z; #endif // C3 $if ($defined(x) && $y > 3): int z; $endif;","title":"Conditional compilation"},{"location":"macros/#macros_1","text":"// C #define M(x) ((x) + 2) #define UInt32 unsigned int // Use: int y = M(foo() + 2); UInt32 b = y; // C3 macro m(x) { return x + 2; } define UInt32 = uint; // Use: int y = @m(foo() + 2); UInt32 b = y;","title":"Macros"},{"location":"macros/#dynamic-scoping","text":"// C #define Z() ptr->x->y->z int x = Z(); // C3 ... currently no corresponding functionality ...","title":"Dynamic scoping"},{"location":"macros/#reference-arguments","text":"Use & in front of a parameter to capture the variable and pass it by reference without having to explicitly use & and pass a pointer. (Note that in C++ this is allowed for normal functions, whereas for C3 it is only permitted with macros.) // C #define M(x, y) x = 2 * (y); // C3 macro m(int &x, int y) { x = 2 * y; }","title":"Reference arguments"},{"location":"macros/#first-class-types","text":"// C #define SIZE(T) (sizeof(T) + sizeof(int)) // C3 macro size($Type) { return $Type.sizeof + int.sizeof; }","title":"First class types"},{"location":"macros/#trailing-blocks-for-macros","text":"// C #define FOR_EACH(x, list) \\ for (x = (list); x; x = x->next) // Use: Foo *it; FOR_EACH(it, list) { if (!process(it)) return; } // C3 macro for_each(list; @body(it)) { for ($typeof(list) x = list; x; x = x.next) { @body(x); } } // Use: @for_each(list; Foo* x) { if (!process(x)) return; }","title":"Trailing blocks for macros"},{"location":"macros/#first-class-names","text":"// C #define offsetof(T, field) (size_t)(&((T*)0)->field) // C3 macro usz offset($Type, #field) { $Type* t = null; return (usz)(uptr)&t.#field; }","title":"First class names"},{"location":"macros/#declaration-attributes","text":"// C #define PURE_INLINE __attribute__((pure)) __attribute__((always_inline)) int foo(int x) PURE_INLINE { ... } // C3 define @PureInline = @pure, @inline fn int foo(int) @PureInline { ... }","title":"Declaration attributes"},{"location":"macros/#declaration-macros","text":"// C #define DECLARE_LIST(name) List name = { .head = NULL }; // Use: DECLARE_LIST(hello) // C3 ... currently no corresponding functionality ...","title":"Declaration macros"},{"location":"macros/#stringification","text":"#define CHECK(x) do { if (!x) abort(#x); } while(0) // C3 macro fn check(#expr) { if (!#expr) abort($stringify(#expr)); }","title":"Stringification"},{"location":"macros/#top-level-evaluation","text":"Script languages, and also upcoming languages like Jai , usually have unbounded top level evaluation. The flexibility of this style of meta programming has a trade off in making the code more challenging to understand. In C3, top level compile time evaluation is limited to $if and $switch constructs + macros with constant expression evaluation. This makes the code easier to read, but at the cost of expressive power.","title":"Top level evaluation"},{"location":"macros/#macro-declarations","text":"A macro is defined using macro <name>(<parameters>) . All user defined macros use the @ symbol if they use the & or # parameters. The parameters have different sigils: $ means compile time evaluated (constant expression or type). # indicates an expression that is not yet evaluated, but is bound to where it was defined. Finally & is used to implicitly pass a parameter by reference. @ is required on macros that use # and & parameters. A basic swap: /** * @checked a = b, b = a */ macro void @swap(&a, &b) { $typeof(a) temp = a; a = b; b = temp; } This expands on usage like this: fn void test() { int a = 10; int b = 20; @swap(a, b); } // Equivalent to: fn void test() { int a = 10; int b = 20; { int __temp = a; a = b; b = __temp; } } Note the necessary & . Here is an incorrect swap and what it would expand to: macro void badswap(a, b) { $typeof(a) temp = a; a = b; b = temp; } fn void test() { int a = 10; int b = 20; badswap(a, b); } // Equivalent to: fn void test() { int a = 10; int b = 20; { int __a = a; int __b = b; int __temp = __a; __a = __b; __b = __temp; } }","title":"Macro declarations"},{"location":"macros/#macro-methods","text":"Similar to regular methods a macro may also be associated with a particular type: struct Foo { ... } macro Foo.generate(Foo *foo) { ... } Foo f; f.generate();","title":"Macro methods"},{"location":"macros/#capturing-a-trailing-block","text":"It is often useful for a macro to take a trailing compound statement as an argument. In C++ this pattern is usually expressed with a lambda, but in C3 this is completely inlined. To accept a trailing block, ; @name(param1, ...) is placed after declaring the regular macro parameters. Here's an example to illustrate its use: /** * A macro looping through a list of values, executing the body once * every pass. * * @checked { int i = a.len; value2 = a[i]; } **/ macro @foreach(a; @body(index, value)) { for (int i = 0; i < a.len; i++) { @body(i, a[i]); } } fn void test() { double[] a = { 1.0, 2.0, 3.0 }; @foreach(a; int index, double value) { io::printfn(\"a[%d] = %f\", index, value); } } // Expands to code similar to: fn void test() { int[] a = { 1, 2, 3 }; { int[] __a = a; for (int __i = 0; i < __a.len; i++) { io::printfn(\"Value: %d, x2: %d\", __value1, __value2); } } }","title":"Capturing a trailing block"},{"location":"macros/#macros-returning-values","text":"A macro may return a value, it is then considered an expression rather than a statement: macro square(x) { return x * x; } fn int getTheSquare(int x) { return square(x); } fn double getTheSquare2(double x) { return square(x); }","title":"Macros returning values"},{"location":"macros/#calling-macros","text":"It's perfectly fine for a macro to invoke another macro or itself. macro square(x) { return x * x; } macro squarePlusOne(x) { return square(x) + 1; // Expands to \"return x * x + 1;\" } The maximum recursion depth is limited to the macro-recursion-depth build setting.","title":"Calling macros"},{"location":"macros/#macro-vaargs","text":"Macros support the typed vaargs used by C3 functions: macro void foo(int... args) and macro void bar(args...) but it also supports a unique set of macro vaargs that look like C style vaargs: macro void baz(...) To access the arguments there is a family of $va-* built in functions to retrieve the arguments: macro compile_time_sum(...) { var $x = 0; $for (var $i = 0; $i < $vacount(); $i++): $x += $vaconst($i); $endfor; return $x; } $if (compile_time_sum(1, 3) > 2): // Will compile to $if (4 > 2) ... $endif;","title":"Macro vaargs"},{"location":"macros/#vacount","text":"Returns the number of arguments.","title":"$vacount"},{"location":"macros/#vaarg","text":"Returns the argument as a regular parameter. The argument is guaranteed to be evaluated once, even if the argument is used multiple times.","title":"$vaarg"},{"location":"macros/#vaconst","text":"Returns the argument as a compile time constant, this is suitable for placing in a compile time variable or use for compile time evaluation, e.g. $foo = $vaconst(1) . This corresponds to $ parameters.","title":"$vaconst"},{"location":"macros/#vaexpr","text":"Returns the argument as an unevaluated expression. Multiple uses will evaluate the expression multiple times, this corresponds to # parameters.","title":"$vaexpr"},{"location":"macros/#vatype","text":"Returns the argument as a type. This corresponds to $Type style parameters, e.g. $vatype(2) a = 2","title":"$vatype"},{"location":"macros/#varef","text":"Returns the argument as an lvalue. This corresponds to &myref style parameters, e.g. $varef(1) = 123 .","title":"$varef"},{"location":"macros/#untyped-lists","text":"Compile time variables may hold untyped lists. Such lists may be iterated over or implicitly converted to initializer lists: var $a = { 1, 2 }; $foreach ($x : $a): io::printfn(\"%d\", $x); $endforeach; int[2] x = $a; io::printfn(\"%s\", x); io::printfn(\"%s\", $a[1]); // Will print // 1 // 2 // [1, 2] // 2","title":"Untyped lists"},{"location":"macros/#macro-directives","text":"Inside of a macro, we can use the compile time statements $if , $for and $switch . Macros may also be recursively invoked. As previously mentioned, $if and $switch may also be invoked on the top level.","title":"Macro directives"},{"location":"macros/#if-else-and-elif","text":"$if (<const expr>): takes a compile time constant value and evaluates it to true or false. macro foo($x, $y) { $if ($x > 3): $y += $x * $x; $else: $y += $x; $endif; } const int FOO = 10; fn void test() { int a = 5; int b = 4; foo(1, a); // Allowed, expands to a += 1; // foo(b, a); // Error: b is not a compile time constant. foo(FOO, a); // Allowed, expands to a += FOO * FOO; }","title":"$if, $else and $elif"},{"location":"macros/#loops-using-foreach-and-for","text":"$foreach (<range> : <variable>): ... $endforeach; allows compile time recursion. $foreach may recurse over enums, struct fields or constant ranges. Everything must be known at compile time. Compile time looping: macro foo($a) { $for (var $x = 0; $x < $a; $x++): io::printfn(\"%d\", $x); $endfor; } fn void test() { foo(2); // Expands to -> // io::printfn(\"%d\", 0); // io::printfn(\"%d\", 1); } Looping over enums: macro foo_enum($SomeEnum) { $foreach ($x : $SomeEnum.values): io::printfn(\"%d\", (int)$x); $endforeach; } enum MyEnum { A, B, } fn void test() { foo_enum(MyEnum); // Expands to -> // io::printfn(\"%d\", (int)MyEnum.A); // io::printfn(\"%d\", (int)MyEnum.B); } An important thing to note is that the content of the $foreeach or $for body must be a complete statement. It's not possible to compile partial statements.","title":"Loops using $foreach and $for"},{"location":"macros/#switching-on-type-with-switch","text":"It's possible to switch on type: macro void foo(a, b) { $switch(a, b): $case int, int: return a * b; $endswitch; return a + b; }","title":"Switching on type with $switch"},{"location":"macros/#conditional-macros-at-the-top-level","text":"A limitation with the macros is that they are only used within functions. This is deliberate \u2013 macros expanding at the top level are much harder to reason about since they should be able to define new types or change the meaning of the code that follows. Still, the usefulness of top level macros is great, which is why C3 offers three pieces of functionality for the top level: conditional compilation, global constants and attributes","title":"Conditional macros at the top level"},{"location":"macros/#conditional-compilation_1","text":"Conditional compilation is done with $if and $else , which works just like inside of functions. $if ($defined(platform::OS) && platform::OS == WIN32): fn void doSomethingWin32Specific() { /* .... */ } $endif;","title":"Conditional compilation"},{"location":"macros/#global-constants","text":"Global constant on the top level work like compile time variables in macros \u2013 with the exception that they must always be declared constant. They are evaluated in order, but will resolve on-demand if needed.","title":"Global constants"},{"location":"modules/","text":"Modules C3 groups functions, types, variables and macros into namespaces called modules. When doing builds, any C3 file must start with the module keyword, specifying the module. When compiling single files, the module is not needed and the module name is assumed to be the file name, converted to lower case, with any invalid characters replaced by underscore ( _ ). A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module bar; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar . Details Some details about the C3 module system: Modules can be arbitrarily nested, e.g. module foo::bar::baz; to create the sub module baz in the sub module bar of the module foo . Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters. Importing modules Modules are imported using the import statement. Imports always recursively import sub-modules. Any module will automatically import all other modules with the same parent module. foo.c3 module some::foo; fn void test() {} bar.c3 module bar; import some; // import some::foo; <- not needed, as it is a sub module to \"some\" fn void test() { foo::test(); // some::foo::test() also works. } In some cases there may be ambiguities, in which case the full path can be used to resolve the ambiguity: abc.c3 module abc; struct Context { int a; } def.c3 module def; struct Context { void* ptr; } test.c3 module test1; import def, abc; // Context c = {} <- ambiguous abc::Context c = {}; Implicit imports The module system will also implicitly import: The std::core module (and sub modules). Any other module sharing the same top module. E.g. the module foo::abc will implicitly also import modules foo and foo::cde if they exist. Visibility All files in the same module share the same global declaration namespace. By default a symbol is visible to all other modules. To make a symbol only visible inside the module, use the keyword private . module foo; fn void init() { .. } private fn void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it is specified as private . Overriding symbol visibility rules By using import private , it's possible to access another module\u00b4s private symbols. Many other module systems have hierarchal visibility rules, but the import private feature allows visibility to be manipulated in a more ad-hoc manner without imposing hard rules. For example, you may provide a library with two modules: \"mylib::net\" and \"mylib::file\" - which both use functions and types from a common \"mylib::internals\" module. The two libraries use import private mylib::internals to access this module's private functions and type. To an external user of the library, the \"mylib::internals\" does not seem to exist, but inside of your library you use it as a shared dependency. A simple example: // File a.c3 module a; private fn void aFunction() { ... } // File b.c3 module b; private fn void bFunction() { ... } // File c.c3 module c; import a; import private b; fn void test() { a::aFunction(); // <-- error, aFunction is private b::bFunction(); // Allowed since import was \"private\" } Private modules Modules may be declared using private , this makes the whole module private. Such a module must always be imported using import private . Note that import private is not recursive. module private foo; ... module bar; import private foo; // Allowed ... module baz; import foo; // Error, trying to import private module. Using functions and types from other modules As a rule, functions, macros, constants, variables and types in the same module do not need any namespace prefix. For imported modules the following rules hold: Functions, macros, constants and variables require at least the (sub-) module name. Types do not require the module name unless the name is ambiguous. In case of ambiguity, only so many levels of module names are needed as to make the symbol unambiguous. // File a.c3 module a; struct Foo { ... } struct Bar { ... } struct TheAStruct { ... } fn void anAFunction() { ... } // File b.c3 module b; struct Foo { ... } struct Bar { ... } struct TheBStruct { ... } fn void aBFunction() { ... } // File c.c3 module c; import a; import b; struct TheCStruct { ... } struct Bar { ... } fn void aCFunction() { ... } fn void test() { TheAStruct stA; TheBStruct stB; TheCStruct stC; // Name required to avoid ambiguity; b::Foo stBFoo; // Will always pick the current module's // name. Bar bar; // Namespace required: a::aAFunction(); b::aBFunction(); // A local symbol does not require it: aCFunction(); } This means that the rule for the common case can be summarized as Types are used without prefix; functions, variables, macros and constants are prefixed with the sub module name. Versioning and dynamic inclusion NOTE: This feature may significantly change. When including dynamic libraries, it is possible to use optional functions and globals. This is done using the @dynamic attribute. An example library could have this: dynlib.c3i module dynlib; fn void do_something() @dynamic(4.0) fn void do_something_else() @dynamic(0, 5.0) fn void do_another_thing() @dynamic(0, 2.5) Importing the dynamic library and setting the base version to 4.5 and minimum version to 3.0, we get the following: test.c3 import dynlib; fn void test() { if (@available(dynlib::do_something)) { dynlib::do_something(); } else { dynlib::do_someting_else(); } } In this example the code would run do_something if available (that is, when the dynamic library is 4.0 or higher), or fallback to do_something_else otherwise. If we tried to conditionally add something not available in the compilation itself, that is a compile time error: if (@available(dynlib::do_another_thing)) { dynlib::do_another_thing(); // Error: This function is not available with 3.0 } Versionless dynamic loading is also possible: maybe_dynlib.c3i module maybe_dynlib; fn void testme() @dynamic; test2.c3 import maybe_dynlib; fn void testme2() { if (@available(maybe_dynlib::testme)) { dynlib::testme(); } } This allows things like optionally loading dynamic libraries on the platforms where this is available. Textual includes It's sometimes useful to include an entire file, doing so employs the $include function. Includes are only valid at the top level. File Foo.c3 module foo; $include(\"Foo.x\"); fn void test() { printf(\"%d\", testX(2)); } File Foo.x fn testX(int i) { return i + 1; } The result is as if Foo.c3 contained the following: module foo; fn testX(int i) { return i + 1; } fn void test() { printf(\"%d\", testX(2)); } The include may use an absolute or relative path, the relative path is always relative to the source file in which the include appears.","title":"Modules"},{"location":"modules/#modules","text":"C3 groups functions, types, variables and macros into namespaces called modules. When doing builds, any C3 file must start with the module keyword, specifying the module. When compiling single files, the module is not needed and the module name is assumed to be the file name, converted to lower case, with any invalid characters replaced by underscore ( _ ). A module can consist of multiple files, e.g. file_a.c3 module foo; /* ... */ file_b.c3 module foo; /* ... */ file_c.c3 module bar; /* ... */ Here file_a.c3 and file_b.c3 belong to the same module, foo while file_c.c3 belongs to to bar .","title":"Modules"},{"location":"modules/#details","text":"Some details about the C3 module system: Modules can be arbitrarily nested, e.g. module foo::bar::baz; to create the sub module baz in the sub module bar of the module foo . Module names must be alphanumeric lower case letters plus the underscore character: _ . Module names are limited to 31 characters.","title":"Details"},{"location":"modules/#importing-modules","text":"Modules are imported using the import statement. Imports always recursively import sub-modules. Any module will automatically import all other modules with the same parent module. foo.c3 module some::foo; fn void test() {} bar.c3 module bar; import some; // import some::foo; <- not needed, as it is a sub module to \"some\" fn void test() { foo::test(); // some::foo::test() also works. } In some cases there may be ambiguities, in which case the full path can be used to resolve the ambiguity: abc.c3 module abc; struct Context { int a; } def.c3 module def; struct Context { void* ptr; } test.c3 module test1; import def, abc; // Context c = {} <- ambiguous abc::Context c = {};","title":"Importing modules"},{"location":"modules/#implicit-imports","text":"The module system will also implicitly import: The std::core module (and sub modules). Any other module sharing the same top module. E.g. the module foo::abc will implicitly also import modules foo and foo::cde if they exist.","title":"Implicit imports"},{"location":"modules/#visibility","text":"All files in the same module share the same global declaration namespace. By default a symbol is visible to all other modules. To make a symbol only visible inside the module, use the keyword private . module foo; fn void init() { .. } private fn void open() { .. } In this example, the other modules can use the init() function after importing foo, but only files in the foo module can use open(), as it is specified as private .","title":"Visibility"},{"location":"modules/#overriding-symbol-visibility-rules","text":"By using import private , it's possible to access another module\u00b4s private symbols. Many other module systems have hierarchal visibility rules, but the import private feature allows visibility to be manipulated in a more ad-hoc manner without imposing hard rules. For example, you may provide a library with two modules: \"mylib::net\" and \"mylib::file\" - which both use functions and types from a common \"mylib::internals\" module. The two libraries use import private mylib::internals to access this module's private functions and type. To an external user of the library, the \"mylib::internals\" does not seem to exist, but inside of your library you use it as a shared dependency. A simple example: // File a.c3 module a; private fn void aFunction() { ... } // File b.c3 module b; private fn void bFunction() { ... } // File c.c3 module c; import a; import private b; fn void test() { a::aFunction(); // <-- error, aFunction is private b::bFunction(); // Allowed since import was \"private\" }","title":"Overriding symbol visibility rules"},{"location":"modules/#private-modules","text":"Modules may be declared using private , this makes the whole module private. Such a module must always be imported using import private . Note that import private is not recursive. module private foo; ... module bar; import private foo; // Allowed ... module baz; import foo; // Error, trying to import private module.","title":"Private modules"},{"location":"modules/#using-functions-and-types-from-other-modules","text":"As a rule, functions, macros, constants, variables and types in the same module do not need any namespace prefix. For imported modules the following rules hold: Functions, macros, constants and variables require at least the (sub-) module name. Types do not require the module name unless the name is ambiguous. In case of ambiguity, only so many levels of module names are needed as to make the symbol unambiguous. // File a.c3 module a; struct Foo { ... } struct Bar { ... } struct TheAStruct { ... } fn void anAFunction() { ... } // File b.c3 module b; struct Foo { ... } struct Bar { ... } struct TheBStruct { ... } fn void aBFunction() { ... } // File c.c3 module c; import a; import b; struct TheCStruct { ... } struct Bar { ... } fn void aCFunction() { ... } fn void test() { TheAStruct stA; TheBStruct stB; TheCStruct stC; // Name required to avoid ambiguity; b::Foo stBFoo; // Will always pick the current module's // name. Bar bar; // Namespace required: a::aAFunction(); b::aBFunction(); // A local symbol does not require it: aCFunction(); } This means that the rule for the common case can be summarized as Types are used without prefix; functions, variables, macros and constants are prefixed with the sub module name.","title":"Using functions and types from other modules"},{"location":"modules/#versioning-and-dynamic-inclusion","text":"NOTE: This feature may significantly change. When including dynamic libraries, it is possible to use optional functions and globals. This is done using the @dynamic attribute. An example library could have this: dynlib.c3i module dynlib; fn void do_something() @dynamic(4.0) fn void do_something_else() @dynamic(0, 5.0) fn void do_another_thing() @dynamic(0, 2.5) Importing the dynamic library and setting the base version to 4.5 and minimum version to 3.0, we get the following: test.c3 import dynlib; fn void test() { if (@available(dynlib::do_something)) { dynlib::do_something(); } else { dynlib::do_someting_else(); } } In this example the code would run do_something if available (that is, when the dynamic library is 4.0 or higher), or fallback to do_something_else otherwise. If we tried to conditionally add something not available in the compilation itself, that is a compile time error: if (@available(dynlib::do_another_thing)) { dynlib::do_another_thing(); // Error: This function is not available with 3.0 } Versionless dynamic loading is also possible: maybe_dynlib.c3i module maybe_dynlib; fn void testme() @dynamic; test2.c3 import maybe_dynlib; fn void testme2() { if (@available(maybe_dynlib::testme)) { dynlib::testme(); } } This allows things like optionally loading dynamic libraries on the platforms where this is available.","title":"Versioning and dynamic inclusion"},{"location":"modules/#textual-includes","text":"It's sometimes useful to include an entire file, doing so employs the $include function. Includes are only valid at the top level. File Foo.c3 module foo; $include(\"Foo.x\"); fn void test() { printf(\"%d\", testX(2)); } File Foo.x fn testX(int i) { return i + 1; } The result is as if Foo.c3 contained the following: module foo; fn testX(int i) { return i + 1; } fn void test() { printf(\"%d\", testX(2)); } The include may use an absolute or relative path, the relative path is always relative to the source file in which the include appears.","title":"Textual includes"},{"location":"moreexamples/","text":"More Examples Hello World fn void main() { io::println(\"Hello world!\"); } Fibonacci recursive fn long fib(long n) { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); } HTTP Server import net::http_server; fn void! httpHandler(HttpContext* context) { context.response.contentType = \"text/plain\"; context.response.printf(\"Hello world!\\n\"); } fn void main() { HttpServer server; server.init(); InetAddress! addr = server.bindPort(8080); if (catch addr) { printf(\"Failed to open server.\\n\"); exit(-1); } printf(\"Begin listening to on http://%s\\n\", addr.description()); server.listen(&httpHandler); }","title":"More Examples"},{"location":"moreexamples/#more-examples","text":"","title":"More Examples"},{"location":"moreexamples/#hello-world","text":"fn void main() { io::println(\"Hello world!\"); }","title":"Hello World"},{"location":"moreexamples/#fibonacci-recursive","text":"fn long fib(long n) { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); }","title":"Fibonacci recursive"},{"location":"moreexamples/#http-server","text":"import net::http_server; fn void! httpHandler(HttpContext* context) { context.response.contentType = \"text/plain\"; context.response.printf(\"Hello world!\\n\"); } fn void main() { HttpServer server; server.init(); InetAddress! addr = server.bindPort(8080); if (catch addr) { printf(\"Failed to open server.\\n\"); exit(-1); } printf(\"Begin listening to on http://%s\\n\", addr.description()); server.listen(&httpHandler); }","title":"HTTP Server"},{"location":"naming/","text":"Naming rules C3 introduces fairly strict naming rules to reduce ambiguity. As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character. Structs, unions, enums and faults All user defined types must start with A-Z after any optional initial _ and include at least 1 lower case letter. Bar , _T_i12 and TTi are all valid names. _1 , bAR and BAR are not. For C-compatibility it's possible to alias the type to a external name using the attribute \"externname\". struct Foo @extname(\"foo\") { int x; Bar bar; } union Bar { int i; double d; } enum Baz { VALUE_1, VALUE_2 } fault Err { OOPS, LOTS_OF_OOPS } Variables and parameters All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not. int theGlobal = 1; fn void foo(int x) { Foo foo = getFoo(x); theGlobal++; } Global constants Global constants must start with A-Z after any optional initial _ . _FOO2 , BAR_FOO , X are all valid global constants, _ , _bar , x are not. const int A_VALUE = 12; Enum / Fault values Enum and fault values follow the same naming standard as global constants. enum Baz { VALUE_1, VALUE_2 } fault Err { OOPS, LOTS_OF_OOPS } Struct / union members Struct and union members follow the same naming rules as variables. Modules Module names may contain a-z, 0-9 and _ , no upper case characters are allowed. module foo; Functions and macros Functions and macros must start with a-z after any optional initial _ . fn void theMostAmazingFunction() { return; } macro justDoIt(x) { justDo(x); }","title":"Naming rules"},{"location":"naming/#naming-rules","text":"C3 introduces fairly strict naming rules to reduce ambiguity. As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and _ . The initial character can not be a number. Furthermore, all identifiers are limited to 31 character.","title":"Naming rules"},{"location":"naming/#structs-unions-enums-and-faults","text":"All user defined types must start with A-Z after any optional initial _ and include at least 1 lower case letter. Bar , _T_i12 and TTi are all valid names. _1 , bAR and BAR are not. For C-compatibility it's possible to alias the type to a external name using the attribute \"externname\". struct Foo @extname(\"foo\") { int x; Bar bar; } union Bar { int i; double d; } enum Baz { VALUE_1, VALUE_2 } fault Err { OOPS, LOTS_OF_OOPS }","title":"Structs, unions, enums and faults"},{"location":"naming/#variables-and-parameters","text":"All variables and parameters except for global constant variables must start with a-z after any optional initial _ . ___a fooBar and _test_ are all valid variable / parameter names. _ , _Bar , X are not. int theGlobal = 1; fn void foo(int x) { Foo foo = getFoo(x); theGlobal++; }","title":"Variables and parameters"},{"location":"naming/#global-constants","text":"Global constants must start with A-Z after any optional initial _ . _FOO2 , BAR_FOO , X are all valid global constants, _ , _bar , x are not. const int A_VALUE = 12;","title":"Global constants"},{"location":"naming/#enum-fault-values","text":"Enum and fault values follow the same naming standard as global constants. enum Baz { VALUE_1, VALUE_2 } fault Err { OOPS, LOTS_OF_OOPS }","title":"Enum / Fault values"},{"location":"naming/#struct-union-members","text":"Struct and union members follow the same naming rules as variables.","title":"Struct / union members"},{"location":"naming/#modules","text":"Module names may contain a-z, 0-9 and _ , no upper case characters are allowed. module foo;","title":"Modules"},{"location":"naming/#functions-and-macros","text":"Functions and macros must start with a-z after any optional initial _ . fn void theMostAmazingFunction() { return; } macro justDoIt(x) { justDo(x); }","title":"Functions and macros"},{"location":"operators/","text":"Operator overloading C3 allows some limited operator overloading for working with containers. \"Element at\" operator [] Implementing [] allows a type to use the my_type[<value>] syntax: struct Foo { double[] x; } fn double Foo.get(Foo* this, usz i) @operator([]) { return this.x[i]; } It's possible to use any type as argument, such as a string: fn double Bar.get(Bar* this, String str) @operator([]) { return this.get_val_by_key(str); } Only a single [] overload is allowed. \"Element ref\" operator &[] Similar to [], the operator returns a value for &my_type[<value>] , which may be retrieved in a different way. If this overload isn't defined, then &my_type[<value>] would be a syntax error. fn double* Foo.get_ref(Foo* this, usz i) @operator(&[]) { return &this.x[i]; } \"Element set\" operator []= The counterpart of [] allows setting an element using my_type[<index>] = <value> . fn void Foo.get_ref(Foo* this, usz i, double new_val) @operator([]=) { return this.x[i] = new_val; } \"len\" operator Unlike the previous operator overloads, the \"len\" operator simply enables functionality which augments the [] -family of operators: you can use the \"from end\" syntax e.g my_type[^1] to get the last element assuming the indexing uses integers. Enabling 'foreach' In order to use a type with foreach, e.g. foreach(d : foo) , at a minimum [] and len need to be implemented. If &[] is implemented, foreach by reference is enabled (e.g. foreach(double* &d : foo) ) fn double Foo.get(Foo* this, usz i) @operator([]) { return this.x[i]; } fn usz Foo.len(Foo* this) @operator(len) { return this.x.len; } fn void test(Foo f) { // Print all elements in f foreach (d : f) { io::printfn(\"%f\", d); } }","title":"Operator overloading"},{"location":"operators/#operator-overloading","text":"C3 allows some limited operator overloading for working with containers.","title":"Operator overloading"},{"location":"operators/#element-at-operator","text":"Implementing [] allows a type to use the my_type[<value>] syntax: struct Foo { double[] x; } fn double Foo.get(Foo* this, usz i) @operator([]) { return this.x[i]; } It's possible to use any type as argument, such as a string: fn double Bar.get(Bar* this, String str) @operator([]) { return this.get_val_by_key(str); } Only a single [] overload is allowed.","title":"\"Element at\" operator []"},{"location":"operators/#element-ref-operator","text":"Similar to [], the operator returns a value for &my_type[<value>] , which may be retrieved in a different way. If this overload isn't defined, then &my_type[<value>] would be a syntax error. fn double* Foo.get_ref(Foo* this, usz i) @operator(&[]) { return &this.x[i]; }","title":"\"Element ref\" operator &amp;[]"},{"location":"operators/#element-set-operator","text":"The counterpart of [] allows setting an element using my_type[<index>] = <value> . fn void Foo.get_ref(Foo* this, usz i, double new_val) @operator([]=) { return this.x[i] = new_val; }","title":"\"Element set\" operator []="},{"location":"operators/#len-operator","text":"Unlike the previous operator overloads, the \"len\" operator simply enables functionality which augments the [] -family of operators: you can use the \"from end\" syntax e.g my_type[^1] to get the last element assuming the indexing uses integers.","title":"\"len\" operator"},{"location":"operators/#enabling-foreach","text":"In order to use a type with foreach, e.g. foreach(d : foo) , at a minimum [] and len need to be implemented. If &[] is implemented, foreach by reference is enabled (e.g. foreach(double* &d : foo) ) fn double Foo.get(Foo* this, usz i) @operator([]) { return this.x[i]; } fn usz Foo.len(Foo* this) @operator(len) { return this.x.len; } fn void test(Foo f) { // Print all elements in f foreach (d : f) { io::printfn(\"%f\", d); } }","title":"Enabling 'foreach'"},{"location":"precedence/","text":"Precedence rules Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- @ , prefix - , ~ , prefix * , & , prefix ++ and -- infix * , / , % , *% << , >> ^ , | , infix & + , infix - == , != , >= , <= , > , < && || ternary ?: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 Error, requires parenthesis! a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 Error, requires parenthesis! The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Parenthesis are required for those conflated levels of precedence. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence"},{"location":"precedence/#precedence-rules","text":"Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11): () , [] , . , postfix ++ and -- @ , prefix - , ~ , prefix * , & , prefix ++ and -- infix * , / , % , *% << , >> ^ , | , infix & + , infix - == , != , >= , <= , > , < && || ternary ?: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |= The main difference is that bitwise operations and shift has higher precedence than addition/subtraction and multiplication/division in C3. Bitwise operations also have higher precedence than the relational operators. Also, there is no difference in precedence between && || or between the bitwise operators. Examples a + b >> c + d (a + b) >> (c + d) // C (+ - are evaluated before >>) a + (b >> c) + d // C3 (>> is evaluated before + -) a & b == c a & (b == c) // C (bitwise operators are evaluated after relational) (a & b) == c // C3 (bitwise operators are evaluated before relational) a > b == c < d (a > b) == (c < d) // C (< > binds tighter than ==) ((a > b) == c) < d // C3 Error, requires parenthesis! a | b ^ c & d a | ((b ^ c) & d) // C (All bitwise operators have different precedence) ((a | b) ^ c) & d // C3 Error, requires parenthesis! The change in precedence of the bitwise operators corrects a long standing issue in the C specification. The change in precedence for shift operations goes towards making the precedence less surprising. Conflating the precedence of relational and equality operations, and all bitwise operations was motivated by simplification: few remember the exact internal differences in precedence between bitwise operators. Parenthesis are required for those conflated levels of precedence. Left-to-right offers a very simple model to think about the internal order of operations, and encourages use of explicit ordering, as best practice in C is to use parentheses anyway.","title":"Precedence rules"},{"location":"primer/","text":"A quick primer on C3 for C programmers This primer is intended as a guide to how the C syntax \u2013 and in some cases C semantics \u2013 is different in C3. It is intended to help you take a piece of C code and understand how it can be converted manually to C3. Struct, enum and union declarations Don't add a ; after enum, struct and union declarations, and note the slightly different syntax for declaring a named struct inside of a struct. // C typedef struct { int a; struct { double x; } bar; } Foo; // C3 struct Foo { int a; struct bar { double x; } } Also, user defined types are used without a struct , union or enum keyword, as if the name was a C typedef. Arrays Array sizes are written next to the type and arrays do not decay to pointers, you need to do it manually: // C int x[2] = { 1, 2 }; int *y = x; // C3 int[2] x = { 1, 2 }; int *y = &x; You will probably prefer slices to pointers when passing data around: // C int x[100] = ...; int y[30] = ...; int z[15] = ...; sortMyArray(x, 100); sortMyArray(y, 30); // Sort part of the array! sortMyArray(z + 1, 10); // C3 int[100] x = ...; int[30] y = ...; sortMyArray(&x); // Implicit conversion from int[100]* -> int[] sortMyArray(&y); // Implicit conversion from int[30]* -> int[] sortMyArray(z[1..10]; // Inclusive ranges! Note that declaring an array of inferred size will look different in C3: // C int x[] = { 1, 2, 3 }; // x is int[3] // C3 int[*] x = { 1, 2, 3 }; // x is int[3] Arrays are trivially copyable: // C int x[3] = ...; int y[3]; for (int i = 0; i < 3; i++) y[i] = x[i]; // C3 int[3] x = ...; int[3] y = x; See more here . Undefined behaviour C3 has less undefined behaviour, in particular integers are defined as using 2s complement and signed overflow is wrapping. See more here . Functions Functions are declared like C, but you need to put fn in front: // C: int foo(Foo *b, int x, void *z) { ... } // C3 fn int foo(Foo* b, int x, void *z) { ... } See more about functions, like named and default arguments here . Calling C functions Declare a function (or variable) with extern and it will be possible to access it from C3: // To access puts: extern fn int puts(char*); ... puts(\"Hello world\"); Note that currently only the C standard library is automatically passed to the linker. In order to link with other libraries, you either need to explicitly tell the compiler to link them. If you want to use a different identifier inside of your C3 code compared to the function or variable's external name \u2013 use the @extname attribute: extern fn int _puts(char* message) @extname(\"puts\"); ... _puts(\"Hello world\"); // <- calls the puts function in libc Identifiers Name standards are enforced: // Starting with uppercase and followed somewhere by at least // one lower case is a user defined type: Foo x; M____y y; // Starting with lowercase is a variable or a function or a member name: x.myval = 1; int z = 123; fn void fooBar(int x) { ... } // Only upper case is a constant or an enum value: const int FOOBAR = 123; enum Test { STATE_A = 0, STATE_B = 2 } Variable declaration Declaring more than one variable at a time is not allowed: // C int a, b; // Not allowed in C3 // C3 int a; int b; In C3, variables are always zero initialized, unless you explicitly opt out using void : // C int a = 0; int b; // C3 int a; int b = void; Compound literals Compound literals use C++ style brace initialization, not cast style like in C. For convenience, assigning to a struct will infer the type even if it's not an initializer. // C Foo f = { 1, 2 }; f = (Foo) { 1, 2 }; callFoo((Foo) { 2, 3 }); // C3 Foo f = { 1, 2 }; f = { 1, 2 }; callFoo(Foo{ 2, 3 }); Typedef Instead of typedef , use define // C typedef Foo* FooPtr; // C3 define FooPtr = Foo*; define also allows you to do things that otherwise you'd use #define for: // C #define puts println #define my_string my_excellent_string char *my_string = \"Party on\"; ... println(my_excellent_string); // C3 define println = puts; define my_excellent_string = my_string; char* my_string = \"Party on\"; ... println(my_excellent_string); Read more about define here . Basic types Several C types that would be variable sized are fixed size, and others changed names: // C int16_t a; int32_t b; int64_t c; uint64_t d; size_t e; ssize_t f; ptrdiff_t g; intptr_t h; // C3 short a; // Guaranteed 16 bits int b; // Guaranteed 32 bits long c; // Guaranteed 64 bits ulong d; // Guaranteed 64 bits usz e; // Same as C size_t, depends on target isz f; // Same as C ptrdiff_t iptr g; // Same as intptr_t depends on target ireg i; // Register sized integer Read more about types here . Instead of #include: Modules and import Declaring the module name is not mandatory, but if you leave it out the file name will be used as the module name. Imports are recursive. module otherlib::foo; fn void test() { ... } struct FooStruct { ... } module mylib::bar; import otherlib; fn void myCheck() { foo::test(); // foo prefix is mandatory. mylib::foo::test(); // This also works; FooStruct x; // But user defined types don't need the prefix. otherlib::foo::FooStruct y; // But it is allowed. } Comments The /* */ comments are nesting: /* This /* will all */ be commented out */ Note that doc comments, starting with /** has special rules for parsing it, and is not considered a regular comment. See contracts for more information. Type qualifiers Qualifiers like const and volatile are removed, but const before a constant will make it treated as a compile time constant. The constant does not need to be typed. const A = false; // Compile time $if (A): // This will not be compiled $else: // This will be compiled $endif volatile is replaced by macros for volatile load and store. Goto removed goto is removed, but there is labelled break and continue as well as defer to handle the cases when it is commonly used in C. // C Foo *foo = malloc(sizeof(Foo)); if (tryFoo(foo)) goto FAIL; if (modifyFoo(foo)) goto FAIL; free(foo); return true; FAIL: free(foo); return false; // C3, direct translation: do FAIL: { Foo *foo = malloc(sizeof(Foo)); if (tryFoo(foo)) break FAIL; if (modifyFoo(foo)) break FAIL; free(foo); return true; } free(foo); return false; // C3, using defer: Foo *foo = @mem::malloc(Foo); defer free(foo); if (tryFoo(foo)) return false; if (modifyFoo(foo)) return false; return true; Changes in switch case statements automatically break. Use nextcase to fallthrough to the next statement, but empty case statements have implicit fallthrough: // C switch (a) { case 1: case 2: doOne(); break; case 3: i = 0; case 4: doFour(); break; case 5: doFive(); default: return false; } // C3 switch (a) { case 1: case 2: doOne(); case 3: i = 0; nextcase; case 4: doFour(); case 5: doFive(); nextcase; default: return false; } Note that we can jump to an arbitrary case using C3: // C switch (a) { case 1: doOne(); goto LABEL3; case 2: doTwo(); break; case 3: LABEL3: doThree(); default: return false; } // C3 switch (a) { case 1: doOne(); nextcase 3; case 2: doTwo(); case 3: doThree(); nextcase; default: return false; } Other changes The following things are enhancements to C, that does not have a direct counterpart in C. Expression blocks Defer Methods Errors Semantic macros Generic modules Contracts Reflection Operator overloading Macro methods Static initialize and finalize functions","title":"A quick primer on C3"},{"location":"primer/#a-quick-primer-on-c3-for-c-programmers","text":"This primer is intended as a guide to how the C syntax \u2013 and in some cases C semantics \u2013 is different in C3. It is intended to help you take a piece of C code and understand how it can be converted manually to C3.","title":"A quick primer on C3 for C programmers"},{"location":"primer/#struct-enum-and-union-declarations","text":"Don't add a ; after enum, struct and union declarations, and note the slightly different syntax for declaring a named struct inside of a struct. // C typedef struct { int a; struct { double x; } bar; } Foo; // C3 struct Foo { int a; struct bar { double x; } } Also, user defined types are used without a struct , union or enum keyword, as if the name was a C typedef.","title":"Struct, enum and union declarations"},{"location":"primer/#arrays","text":"Array sizes are written next to the type and arrays do not decay to pointers, you need to do it manually: // C int x[2] = { 1, 2 }; int *y = x; // C3 int[2] x = { 1, 2 }; int *y = &x; You will probably prefer slices to pointers when passing data around: // C int x[100] = ...; int y[30] = ...; int z[15] = ...; sortMyArray(x, 100); sortMyArray(y, 30); // Sort part of the array! sortMyArray(z + 1, 10); // C3 int[100] x = ...; int[30] y = ...; sortMyArray(&x); // Implicit conversion from int[100]* -> int[] sortMyArray(&y); // Implicit conversion from int[30]* -> int[] sortMyArray(z[1..10]; // Inclusive ranges! Note that declaring an array of inferred size will look different in C3: // C int x[] = { 1, 2, 3 }; // x is int[3] // C3 int[*] x = { 1, 2, 3 }; // x is int[3] Arrays are trivially copyable: // C int x[3] = ...; int y[3]; for (int i = 0; i < 3; i++) y[i] = x[i]; // C3 int[3] x = ...; int[3] y = x; See more here .","title":"Arrays"},{"location":"primer/#undefined-behaviour","text":"C3 has less undefined behaviour, in particular integers are defined as using 2s complement and signed overflow is wrapping. See more here .","title":"Undefined behaviour"},{"location":"primer/#functions","text":"Functions are declared like C, but you need to put fn in front: // C: int foo(Foo *b, int x, void *z) { ... } // C3 fn int foo(Foo* b, int x, void *z) { ... } See more about functions, like named and default arguments here .","title":"Functions"},{"location":"primer/#calling-c-functions","text":"Declare a function (or variable) with extern and it will be possible to access it from C3: // To access puts: extern fn int puts(char*); ... puts(\"Hello world\"); Note that currently only the C standard library is automatically passed to the linker. In order to link with other libraries, you either need to explicitly tell the compiler to link them. If you want to use a different identifier inside of your C3 code compared to the function or variable's external name \u2013 use the @extname attribute: extern fn int _puts(char* message) @extname(\"puts\"); ... _puts(\"Hello world\"); // <- calls the puts function in libc","title":"Calling C functions"},{"location":"primer/#identifiers","text":"Name standards are enforced: // Starting with uppercase and followed somewhere by at least // one lower case is a user defined type: Foo x; M____y y; // Starting with lowercase is a variable or a function or a member name: x.myval = 1; int z = 123; fn void fooBar(int x) { ... } // Only upper case is a constant or an enum value: const int FOOBAR = 123; enum Test { STATE_A = 0, STATE_B = 2 }","title":"Identifiers"},{"location":"primer/#variable-declaration","text":"Declaring more than one variable at a time is not allowed: // C int a, b; // Not allowed in C3 // C3 int a; int b; In C3, variables are always zero initialized, unless you explicitly opt out using void : // C int a = 0; int b; // C3 int a; int b = void;","title":"Variable declaration"},{"location":"primer/#compound-literals","text":"Compound literals use C++ style brace initialization, not cast style like in C. For convenience, assigning to a struct will infer the type even if it's not an initializer. // C Foo f = { 1, 2 }; f = (Foo) { 1, 2 }; callFoo((Foo) { 2, 3 }); // C3 Foo f = { 1, 2 }; f = { 1, 2 }; callFoo(Foo{ 2, 3 });","title":"Compound literals"},{"location":"primer/#typedef","text":"Instead of typedef , use define // C typedef Foo* FooPtr; // C3 define FooPtr = Foo*; define also allows you to do things that otherwise you'd use #define for: // C #define puts println #define my_string my_excellent_string char *my_string = \"Party on\"; ... println(my_excellent_string); // C3 define println = puts; define my_excellent_string = my_string; char* my_string = \"Party on\"; ... println(my_excellent_string); Read more about define here .","title":"Typedef"},{"location":"primer/#basic-types","text":"Several C types that would be variable sized are fixed size, and others changed names: // C int16_t a; int32_t b; int64_t c; uint64_t d; size_t e; ssize_t f; ptrdiff_t g; intptr_t h; // C3 short a; // Guaranteed 16 bits int b; // Guaranteed 32 bits long c; // Guaranteed 64 bits ulong d; // Guaranteed 64 bits usz e; // Same as C size_t, depends on target isz f; // Same as C ptrdiff_t iptr g; // Same as intptr_t depends on target ireg i; // Register sized integer Read more about types here .","title":"Basic types"},{"location":"primer/#instead-of-include-modules-and-import","text":"Declaring the module name is not mandatory, but if you leave it out the file name will be used as the module name. Imports are recursive. module otherlib::foo; fn void test() { ... } struct FooStruct { ... } module mylib::bar; import otherlib; fn void myCheck() { foo::test(); // foo prefix is mandatory. mylib::foo::test(); // This also works; FooStruct x; // But user defined types don't need the prefix. otherlib::foo::FooStruct y; // But it is allowed. }","title":"Instead of #include: Modules and import"},{"location":"primer/#comments","text":"The /* */ comments are nesting: /* This /* will all */ be commented out */ Note that doc comments, starting with /** has special rules for parsing it, and is not considered a regular comment. See contracts for more information.","title":"Comments"},{"location":"primer/#type-qualifiers","text":"Qualifiers like const and volatile are removed, but const before a constant will make it treated as a compile time constant. The constant does not need to be typed. const A = false; // Compile time $if (A): // This will not be compiled $else: // This will be compiled $endif volatile is replaced by macros for volatile load and store.","title":"Type qualifiers"},{"location":"primer/#goto-removed","text":"goto is removed, but there is labelled break and continue as well as defer to handle the cases when it is commonly used in C. // C Foo *foo = malloc(sizeof(Foo)); if (tryFoo(foo)) goto FAIL; if (modifyFoo(foo)) goto FAIL; free(foo); return true; FAIL: free(foo); return false; // C3, direct translation: do FAIL: { Foo *foo = malloc(sizeof(Foo)); if (tryFoo(foo)) break FAIL; if (modifyFoo(foo)) break FAIL; free(foo); return true; } free(foo); return false; // C3, using defer: Foo *foo = @mem::malloc(Foo); defer free(foo); if (tryFoo(foo)) return false; if (modifyFoo(foo)) return false; return true;","title":"Goto removed"},{"location":"primer/#changes-in-switch","text":"case statements automatically break. Use nextcase to fallthrough to the next statement, but empty case statements have implicit fallthrough: // C switch (a) { case 1: case 2: doOne(); break; case 3: i = 0; case 4: doFour(); break; case 5: doFive(); default: return false; } // C3 switch (a) { case 1: case 2: doOne(); case 3: i = 0; nextcase; case 4: doFour(); case 5: doFive(); nextcase; default: return false; } Note that we can jump to an arbitrary case using C3: // C switch (a) { case 1: doOne(); goto LABEL3; case 2: doTwo(); break; case 3: LABEL3: doThree(); default: return false; } // C3 switch (a) { case 1: doOne(); nextcase 3; case 2: doTwo(); case 3: doThree(); nextcase; default: return false; }","title":"Changes in switch"},{"location":"primer/#other-changes","text":"The following things are enhancements to C, that does not have a direct counterpart in C. Expression blocks Defer Methods Errors Semantic macros Generic modules Contracts Reflection Operator overloading Macro methods Static initialize and finalize functions","title":"Other changes"},{"location":"project/","text":"Customizing A Project A new project is provided with a barebone structure in project.json : { \"version\": \"0.1.0\", \"authors\": [ \"John Doe <john.doe@example.com>\" ], \"langrev\": \"1\", \"warnings\": [ \"no-unused\" ], // sources compiled \"sources\": [ \"./**\" ], // directories where C3 library files may be found \"dependency-search-paths\": [ \"lib\" ], // libraries to use \"dependencies\": [], // c compiler \"cc\": \"cc\", // c sources \"c-sources\": [ \"./c-source/**\" ], \"targets\": { \"hello_world\": { \"type\": \"executable\" } } } By default, an executable in assumed, but changing the type to \"static-lib\" or \"dynamic-lib\" creates static library and dynamic library targets respectively. This part will be updated, stay tuned Compilation options The project file contains common settings at the top level, that can be overridden by each target, by simply assigning that particular key. So if the top level defines target to be macos-x64 and the actual target defines it to be windows-x64 , then the windows-x64 will be used for compilation. Similarly, compiler command line parameters can be used in turn to override the target setting. targets The list of targets that can be built. dependencies List of C3 libraries (\".c3l\") to use when compiling the target. sources List of source files to compile. cc C compiler to use for compiling C sources (if C sources are compiled together with C3 files). c-sources List of C sources to compile. version Not handled yet Version for library, will also be provided as a compile time constant. authors Not handled yet List of authors to add for library compilation. langrev Not handled yet The language revision to use. config Not added yet Under the config you define external constants (\"key: value\") that will be included in compilation as if they were global macro constants. export Not added yet Define the list of modules to be exported by a library. Not valid for executables. warnings Not completely supported yet List of warnings to enable during compilation. Target options type This mandatory option should be one of \"executable\", \"dynamic-lib\" and \"static-lib\". More types will be added Using environment variables Not supported yet In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Project Structure"},{"location":"project/#customizing-a-project","text":"A new project is provided with a barebone structure in project.json : { \"version\": \"0.1.0\", \"authors\": [ \"John Doe <john.doe@example.com>\" ], \"langrev\": \"1\", \"warnings\": [ \"no-unused\" ], // sources compiled \"sources\": [ \"./**\" ], // directories where C3 library files may be found \"dependency-search-paths\": [ \"lib\" ], // libraries to use \"dependencies\": [], // c compiler \"cc\": \"cc\", // c sources \"c-sources\": [ \"./c-source/**\" ], \"targets\": { \"hello_world\": { \"type\": \"executable\" } } } By default, an executable in assumed, but changing the type to \"static-lib\" or \"dynamic-lib\" creates static library and dynamic library targets respectively. This part will be updated, stay tuned","title":"Customizing A Project"},{"location":"project/#compilation-options","text":"The project file contains common settings at the top level, that can be overridden by each target, by simply assigning that particular key. So if the top level defines target to be macos-x64 and the actual target defines it to be windows-x64 , then the windows-x64 will be used for compilation. Similarly, compiler command line parameters can be used in turn to override the target setting.","title":"Compilation options"},{"location":"project/#targets","text":"The list of targets that can be built.","title":"targets"},{"location":"project/#dependencies","text":"List of C3 libraries (\".c3l\") to use when compiling the target.","title":"dependencies"},{"location":"project/#sources","text":"List of source files to compile.","title":"sources"},{"location":"project/#cc","text":"C compiler to use for compiling C sources (if C sources are compiled together with C3 files).","title":"cc"},{"location":"project/#c-sources","text":"List of C sources to compile.","title":"c-sources"},{"location":"project/#version","text":"Not handled yet Version for library, will also be provided as a compile time constant.","title":"version"},{"location":"project/#authors","text":"Not handled yet List of authors to add for library compilation.","title":"authors"},{"location":"project/#langrev","text":"Not handled yet The language revision to use.","title":"langrev"},{"location":"project/#config","text":"Not added yet Under the config you define external constants (\"key: value\") that will be included in compilation as if they were global macro constants.","title":"config"},{"location":"project/#export","text":"Not added yet Define the list of modules to be exported by a library. Not valid for executables.","title":"export"},{"location":"project/#warnings","text":"Not completely supported yet List of warnings to enable during compilation.","title":"warnings"},{"location":"project/#target-options","text":"","title":"Target options"},{"location":"project/#type","text":"This mandatory option should be one of \"executable\", \"dynamic-lib\" and \"static-lib\". More types will be added","title":"type"},{"location":"project/#using-environment-variables","text":"Not supported yet In addition to constants any values starting with \"$\" will be assumed to be environment variables. For example \"$HOME\" would on unix systems return the home directory. For strings that start with $ but should not be interpreted as an environment variable. For example, the string \"\\$HOME\" would be interpreted as the plain string \"$HOME\"","title":"Using environment variables"},{"location":"reflection/","text":"Reflection C3 allows both compile time and runtime reflection. During compile time the type information may be directly used as compile time constants, the same data is then available dynamically at runtime. Note that not all reflection is implemented in the compiler at this point in time. Compile time reflection During compile time there are a number of compile time fields that may be accessed directly. Type properties It is possible to access properties on the type itself: associated elements inf inner kind len max membersof min nan names params returns sizeof typeid values associated Not yet implemented Only available for enums. Returns an array containing the types of associated values if any. enum Foo : int(double d, String s) { BAR(1.0, \"normal\"), BAZ(2.0, \"exceptional\") } String s = $nameof(Foo.associated[0]); // \"double\" elements Returns the element count of an enum or fault. enum FooEnum { BAR, BAZ } int x = FooEnum.elements; // 2 inf Only available for floating point types Returns a representation of floating point \"infinity\". inner This returns a typeid to an \"inner\" type. What this means is different for each type: Array -> the array base type. Bitstruct -> underlying base type. Enum -> underlying enum base type. Pointer -> the type being pointed to. Vector -> the vector base type. Distinct -> the underlying type. It is not defined for other types. kind Returns the underlying TypeKind as defined in std::core::types. TypeKind kind = int.kind; // TypeKind.SIGNED_INT len Returns the length of the array. usz len = int[4].len; // 4 max Returns the maximum value of the type (only valid for integer and float types). ushort max_ushort = ushort.max; // 65535 membersof Only available for struct and union types. Returns an array containing the fields in a struct or enum. struct Baz { int x; Foo* z; } String x = $nameof($typefrom(Baz.membersof[1])); // \"z\" min Returns the minimum value of the type (only valid for integer and float types). ichar min_ichar = ichar.min; // -128 names Returns a subarray containing the names of an enum or fault. enum FooEnum { BAR, BAZ } String[] x = FooEnum.names; // [\"BAR\", \"BAZ\"] params Not yet implemented Only available for function types. Returns a list of all parameters. define TestFunc = fn int(int, double); String s = $nameof(TestFunc.params[1]); // \"double\" returns Only available for function types. Returns the type of the return type. define TestFunc = fn int(int, double); String s = $nameof($typeform(TestFunc.returns)); // \"int\" sizeof Returns the size in bytes for the given type, like C sizeof . usz x = Foo.sizeof; typeid Returns the typeid for the given type. Typedefs will return the typeid of the underlying type. The typeid size is the same as that of an iptr . typeid x = Foo.typeid; values Returns a subarray containing the values of an enum or fault. enum FooEnum { BAR, BAZ } String x = $nameof(FooEnum.values[1]); // \"BAR\" Compile time functions There are several built-in functions to inspect the code during compile time. $alignof $checks $defined $eval $evaltype $extnameof $nameof $offsetof $qnameof $sizeof $stringify $typeof $alignof Returns the alignment in bytes needed for the type or member. module test::bar; struct Foo { int x; char[] y; } int g = 123; $alignof(Foo.x); // => returns 4 $alignof(Foo.y); // => returns 8 on 64 bit $alignof(Foo); // => returns 8 on 64 bit $alignof(g); // => returns 4 $checks Returns true if the expression can be parsed and analysed, false otherwise. int a; typeid b; bool x = $checks(a + a); // x = true bool y = $checks(b + b); // y = false This function can be very useful when checking macro arguments. $defined Returns true if the expression inside is defined. $defined(Foo.x); // => returns true $defined(Foo.z); // => returns false $eval Converts a compile time string with the corresponding variable: int a = 123; // => a is now 123 $eval(\"a\") = 222; // => a is now 222 $eval(\"mymodule::fooFunc\")(a); // => same as mymodule::fooFunc(a) $eval is limited to a single, optionally path prefixed, identifier. Consequently methods cannot be evaluated directly: struct Foo { ... } fn int Foo.test(Foo* f) { ... } fn void test() { void* test1 = &$eval(\"test\"); // Works void* test2 = &Foo.$eval(\"test\"); // Works // void* test3 = &$eval(\"Foo.test\"); // Error } $evaltype Similar to $eval but for types: $evaltype(\"float\") f = 12.0f; $extnameof Returns the external name of a type, variable or function. The external name is the one used by the linker. fn void testfn(int x) { } String a = $extnameof(g); // => \"test.bar.g\"; string b = $extnameof(testfn); // => \"test.bar.testfn\" $nameof Returns the name of a function, type or variable as a string without module prefixes. define Bar = Foo; String a = $nameof(int[4]); // => \"int[4]\" String b = $nameof(Foo) // => \"Foo\" String c = $nameof(Bar); // => \"Foo\" String d = $nameof(g); // => \"g\" $offsetof Returns the offset of a member in a struct. $offsetof(Foo.y); // => returns 8 on 64 bit, 4 on 32 bit $qnameof Returns the same as $nameof , but with the full module name prepended. int x; String a = $qnameof(int[4]); // => \"int[4]\" String b = $qnameof(Foo) // => \"test::bar::Foo\" String c = $qnameof(Foo[4]); // => \"test::bar::Foo[4]\" String d = $qnameof(g); // => \"test::bar::g\" $sizeof This is used on a value to determine the allocation size needed. $sizeof(a) is equivalent to doing $typeof(a).sizeof . Note that this is only used on values and not on types. $typeof(a)* x = allocate_bytes($sizeof(a)); *x = a; $stringify Returns the expression as a string. It has a special behaviour for macro expression parameters, where $stringify(#foo) will return the expression contained in #foo rather than simply return \"#foo\" $typeof Returns the type of an expression or variable as a type itself. Foo f; $typeof(f) x = f;","title":"Reflection"},{"location":"reflection/#reflection","text":"C3 allows both compile time and runtime reflection. During compile time the type information may be directly used as compile time constants, the same data is then available dynamically at runtime. Note that not all reflection is implemented in the compiler at this point in time.","title":"Reflection"},{"location":"reflection/#compile-time-reflection","text":"During compile time there are a number of compile time fields that may be accessed directly.","title":"Compile time reflection"},{"location":"reflection/#type-properties","text":"It is possible to access properties on the type itself: associated elements inf inner kind len max membersof min nan names params returns sizeof typeid values","title":"Type properties"},{"location":"reflection/#associated","text":"Not yet implemented Only available for enums. Returns an array containing the types of associated values if any. enum Foo : int(double d, String s) { BAR(1.0, \"normal\"), BAZ(2.0, \"exceptional\") } String s = $nameof(Foo.associated[0]); // \"double\"","title":"associated"},{"location":"reflection/#elements","text":"Returns the element count of an enum or fault. enum FooEnum { BAR, BAZ } int x = FooEnum.elements; // 2","title":"elements"},{"location":"reflection/#inf","text":"Only available for floating point types Returns a representation of floating point \"infinity\".","title":"inf"},{"location":"reflection/#inner","text":"This returns a typeid to an \"inner\" type. What this means is different for each type: Array -> the array base type. Bitstruct -> underlying base type. Enum -> underlying enum base type. Pointer -> the type being pointed to. Vector -> the vector base type. Distinct -> the underlying type. It is not defined for other types.","title":"inner"},{"location":"reflection/#kind","text":"Returns the underlying TypeKind as defined in std::core::types. TypeKind kind = int.kind; // TypeKind.SIGNED_INT","title":"kind"},{"location":"reflection/#len","text":"Returns the length of the array. usz len = int[4].len; // 4","title":"len"},{"location":"reflection/#max","text":"Returns the maximum value of the type (only valid for integer and float types). ushort max_ushort = ushort.max; // 65535","title":"max"},{"location":"reflection/#membersof","text":"Only available for struct and union types. Returns an array containing the fields in a struct or enum. struct Baz { int x; Foo* z; } String x = $nameof($typefrom(Baz.membersof[1])); // \"z\"","title":"membersof"},{"location":"reflection/#min","text":"Returns the minimum value of the type (only valid for integer and float types). ichar min_ichar = ichar.min; // -128","title":"min"},{"location":"reflection/#names","text":"Returns a subarray containing the names of an enum or fault. enum FooEnum { BAR, BAZ } String[] x = FooEnum.names; // [\"BAR\", \"BAZ\"]","title":"names"},{"location":"reflection/#params","text":"Not yet implemented Only available for function types. Returns a list of all parameters. define TestFunc = fn int(int, double); String s = $nameof(TestFunc.params[1]); // \"double\"","title":"params"},{"location":"reflection/#returns","text":"Only available for function types. Returns the type of the return type. define TestFunc = fn int(int, double); String s = $nameof($typeform(TestFunc.returns)); // \"int\"","title":"returns"},{"location":"reflection/#sizeof","text":"Returns the size in bytes for the given type, like C sizeof . usz x = Foo.sizeof;","title":"sizeof"},{"location":"reflection/#typeid","text":"Returns the typeid for the given type. Typedefs will return the typeid of the underlying type. The typeid size is the same as that of an iptr . typeid x = Foo.typeid;","title":"typeid"},{"location":"reflection/#values","text":"Returns a subarray containing the values of an enum or fault. enum FooEnum { BAR, BAZ } String x = $nameof(FooEnum.values[1]); // \"BAR\"","title":"values"},{"location":"reflection/#compile-time-functions","text":"There are several built-in functions to inspect the code during compile time. $alignof $checks $defined $eval $evaltype $extnameof $nameof $offsetof $qnameof $sizeof $stringify $typeof","title":"Compile time functions"},{"location":"reflection/#alignof","text":"Returns the alignment in bytes needed for the type or member. module test::bar; struct Foo { int x; char[] y; } int g = 123; $alignof(Foo.x); // => returns 4 $alignof(Foo.y); // => returns 8 on 64 bit $alignof(Foo); // => returns 8 on 64 bit $alignof(g); // => returns 4","title":"$alignof"},{"location":"reflection/#checks","text":"Returns true if the expression can be parsed and analysed, false otherwise. int a; typeid b; bool x = $checks(a + a); // x = true bool y = $checks(b + b); // y = false This function can be very useful when checking macro arguments.","title":"$checks"},{"location":"reflection/#defined","text":"Returns true if the expression inside is defined. $defined(Foo.x); // => returns true $defined(Foo.z); // => returns false","title":"$defined"},{"location":"reflection/#eval","text":"Converts a compile time string with the corresponding variable: int a = 123; // => a is now 123 $eval(\"a\") = 222; // => a is now 222 $eval(\"mymodule::fooFunc\")(a); // => same as mymodule::fooFunc(a) $eval is limited to a single, optionally path prefixed, identifier. Consequently methods cannot be evaluated directly: struct Foo { ... } fn int Foo.test(Foo* f) { ... } fn void test() { void* test1 = &$eval(\"test\"); // Works void* test2 = &Foo.$eval(\"test\"); // Works // void* test3 = &$eval(\"Foo.test\"); // Error }","title":"$eval"},{"location":"reflection/#evaltype","text":"Similar to $eval but for types: $evaltype(\"float\") f = 12.0f;","title":"$evaltype"},{"location":"reflection/#extnameof","text":"Returns the external name of a type, variable or function. The external name is the one used by the linker. fn void testfn(int x) { } String a = $extnameof(g); // => \"test.bar.g\"; string b = $extnameof(testfn); // => \"test.bar.testfn\"","title":"$extnameof"},{"location":"reflection/#nameof","text":"Returns the name of a function, type or variable as a string without module prefixes. define Bar = Foo; String a = $nameof(int[4]); // => \"int[4]\" String b = $nameof(Foo) // => \"Foo\" String c = $nameof(Bar); // => \"Foo\" String d = $nameof(g); // => \"g\"","title":"$nameof"},{"location":"reflection/#offsetof","text":"Returns the offset of a member in a struct. $offsetof(Foo.y); // => returns 8 on 64 bit, 4 on 32 bit","title":"$offsetof"},{"location":"reflection/#qnameof","text":"Returns the same as $nameof , but with the full module name prepended. int x; String a = $qnameof(int[4]); // => \"int[4]\" String b = $qnameof(Foo) // => \"test::bar::Foo\" String c = $qnameof(Foo[4]); // => \"test::bar::Foo[4]\" String d = $qnameof(g); // => \"test::bar::g\"","title":"$qnameof"},{"location":"reflection/#sizeof_1","text":"This is used on a value to determine the allocation size needed. $sizeof(a) is equivalent to doing $typeof(a).sizeof . Note that this is only used on values and not on types. $typeof(a)* x = allocate_bytes($sizeof(a)); *x = a;","title":"$sizeof"},{"location":"reflection/#stringify","text":"Returns the expression as a string. It has a special behaviour for macro expression parameters, where $stringify(#foo) will return the expression contained in #foo rather than simply return \"#foo\"","title":"$stringify"},{"location":"reflection/#typeof","text":"Returns the type of an expression or variable as a type itself. Foo f; $typeof(f) x = f;","title":"$typeof"},{"location":"rejectedideas/","text":"Rejected ideas These are ideas that will not be implemented in C3 with rationale given. Constructors and destructors A fundamental concept in C3 is that data is not \"active\". This is to say there is no code associated with the data implicitly unlike constructors and destructors in an object oriented language. Not having constructors / destructors prevents RAII-style resource handling, but also allows the code to assume the memory can be freely allocated and initialized as it sees fit, without causing any corruption or undefined behaviour. There is a fundamental difference between active objects and inert data, each has its advantages and disadvantages. C3 follows the C model, which is that data is passive and does not enforce any behaviour. This has very deep implications on the semantics of the language and adding constructors and destructors would change the language greatly, requiring modification of many parts of the language altering. For that reason constructors and destructors will not be considered for C3. Unicode identifiers The main argument for unicode identifiers is that \"it allows people to code in their own language\". However, there is no proof that this actually is used in practice. Furthermore there are practical issues, such as bidirectional text, characters with different code points that are rendered in an identical way etc. Given the complexity and the lack of actual proven benefit, unicode identifiers will not happen for C3.","title":"Rejected ideas"},{"location":"rejectedideas/#rejected-ideas","text":"These are ideas that will not be implemented in C3 with rationale given.","title":"Rejected ideas"},{"location":"rejectedideas/#constructors-and-destructors","text":"A fundamental concept in C3 is that data is not \"active\". This is to say there is no code associated with the data implicitly unlike constructors and destructors in an object oriented language. Not having constructors / destructors prevents RAII-style resource handling, but also allows the code to assume the memory can be freely allocated and initialized as it sees fit, without causing any corruption or undefined behaviour. There is a fundamental difference between active objects and inert data, each has its advantages and disadvantages. C3 follows the C model, which is that data is passive and does not enforce any behaviour. This has very deep implications on the semantics of the language and adding constructors and destructors would change the language greatly, requiring modification of many parts of the language altering. For that reason constructors and destructors will not be considered for C3.","title":"Constructors and destructors"},{"location":"rejectedideas/#unicode-identifiers","text":"The main argument for unicode identifiers is that \"it allows people to code in their own language\". However, there is no proof that this actually is used in practice. Furthermore there are practical issues, such as bidirectional text, characters with different code points that are rendered in an identical way etc. Given the complexity and the lack of actual proven benefit, unicode identifiers will not happen for C3.","title":"Unicode identifiers"},{"location":"sample/","text":"Sample Here is a bit of code manually converted to C3 from C. struct Node { uint hole; uint size; Node* next; Node* prev; } struct Footer { Node *header; } struct Bin { Node* head; } struct Heap { size start; size end; Bin* bins[BIN_COUNT]; } const uint OFFSET = 8; /** * @require heap != nil, start > 0 */ void Heap.init(Heap* heap, usz start) { Node* init_region = (Node*)start; init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - Node.sizeof - Footer.sizeof; init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = (void*)start; heap.end = (void*)(start + HEAP_INIT_SIZE); } void* Heap.alloc(Heap* heap, usz size) { uint index = get_bin_index(size); Bin* temp = (Bin*)heap.bins[index]; Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node* split = (Node*)((char*)found + Node.sizeof + Footer.sizeof) + size; split.size = found.size - size - Node.sizeof - Footer.sizeof; split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node* wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ fn void Heap.free(Heap* heap, void *p) { Bin* list; Footer& new_foot, old_foot; Node* head = (Node*)((char*)p - OFFSET); if (head == (Node*)((uptr)heap.start)) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node* next = (Node*)((char*)head.getFoot() + Footer.sizeof); Footer* f = (Footer*)((char*)(head) - Footer.sizeof); Node* prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } fn uint Heap.expand(Heap* heap, usz sz) { return 0; } fn void Heap.contract(Heap* heap, usz sz) { return; } fn uint get_bin_index(usz sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } fn void Node.createFoot(Node* head) { Footer* foot = head.getFoot(); foot.header = head; } fn Footer* Node.getFoot(Node* node) { return (Footer*)((char*)node + Node.sizeof + node.size); } fn Node* getWilderness(Heap* heap) { Footer* wild_foot = (Footer*)((char*)heap.end - Footer.sizeof); return wild_foot.header; }","title":"More code examples"},{"location":"sample/#sample","text":"Here is a bit of code manually converted to C3 from C. struct Node { uint hole; uint size; Node* next; Node* prev; } struct Footer { Node *header; } struct Bin { Node* head; } struct Heap { size start; size end; Bin* bins[BIN_COUNT]; } const uint OFFSET = 8; /** * @require heap != nil, start > 0 */ void Heap.init(Heap* heap, usz start) { Node* init_region = (Node*)start; init_region.hole = 1; init_region.size = HEAP_INIT_SIZE - Node.sizeof - Footer.sizeof; init_region.createFoot(); heap.bins[get_bin_index(init_region.size)].add(init_region); heap.start = (void*)start; heap.end = (void*)(start + HEAP_INIT_SIZE); } void* Heap.alloc(Heap* heap, usz size) { uint index = get_bin_index(size); Bin* temp = (Bin*)heap.bins[index]; Node* found = temp.getBestFit(size); while (!found) { temp = heap.bins[++index]; found = temp.getBestFit(size); } if ((found.size - size) > (overhead + MIN_ALLOC_SZ)) { Node* split = (Node*)((char*)found + Node.sizeof + Footer.sizeof) + size; split.size = found.size - size - Node.sizeof - Footer.sizeof; split.hole = 1; split.createFoot(); uint new_idx = get_bin_index(split.size); heap.bins[new_idx].addNode(split); found.size = size; found.createFoot(found); } found.hole = 0; heap.bins[index].removeNode(found); Node* wild = heap.getWilderness(heap); if (wild.size < MIN_WILDERNESS) { uint success = heap.expand(0x1000); if (success == 0) { return nil; } } else if (wild.size > MAX_WILDERNESS) { heap.contract(0x1000); } found.prev = nil; found.next = nil; return &found.next; } /** * @require p != nil */ fn void Heap.free(Heap* heap, void *p) { Bin* list; Footer& new_foot, old_foot; Node* head = (Node*)((char*)p - OFFSET); if (head == (Node*)((uptr)heap.start)) { head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); return; } Node* next = (Node*)((char*)head.getFoot() + Footer.sizeof); Footer* f = (Footer*)((char*)(head) - Footer.sizeof); Node* prev = f.header; if (prev.hole) { list = heap.bins[get_bin_index(prev.size)]; list.removeNode(prev); prev.size += overhead + head.size; new_foot = head.getFoot(head); new_foot.header = prev; head = prev; } if (next.hole) { list = heap.bins[get_bin_index(next.size)]; list.removeNode(next); head.size += overhead + next.size; old_foot = next.getFoot(); old_foot.header = 0; next.size = 0; next.hole = 0; new_foot = head.getFoot(head); new_foot.header = head; } head.hole = 1; heap.bins[get_bin_index(head.size)].addNode(head); } fn uint Heap.expand(Heap* heap, usz sz) { return 0; } fn void Heap.contract(Heap* heap, usz sz) { return; } fn uint get_bin_index(usz sz) { uint index = 0; sz = sz < 4 ? 4 : sz; while (sz >>= 1) index++; index -= 2; if (index > BIN_MAX_IDX) index = BIN_MAX_IDX; return index; } fn void Node.createFoot(Node* head) { Footer* foot = head.getFoot(); foot.header = head; } fn Footer* Node.getFoot(Node* node) { return (Footer*)((char*)node + Node.sizeof + node.size); } fn Node* getWilderness(Heap* heap) { Footer* wild_foot = (Footer*)((char*)heap.end - Footer.sizeof); return wild_foot.header; }","title":"Sample"},{"location":"setup/","text":"Setup C3 is not ready for end users yet, but should be possible to get it up and running on any platform that LLVM can compile on. You will need CMake installed. 1. Install LLVM See LLVM the LLVM documentation on how to set up LLVM 10 for development. On OS X, installing through Homebrew works fine. Using apt-get on Linux should work fine as well. 2. Clone the C3 compiler source code from Github This should be as simple as doing: git clone https://github.com/c3lang/c3c.git ... from the command line. 3. Build the compiler Create the build directory: MyMachine:c3c$ mkdir build MyMachine:c3c$ cd build/ Use CMake to set up: MyMachine:c3c/build$ cmake ../ Build the compiler: MyMachine:c3c/build$ make 4. Test it out MyMachine:c3c/build$ ./c3c compile ../resources/testfragments/helloworld.c3","title":"Setup"},{"location":"setup/#setup","text":"C3 is not ready for end users yet, but should be possible to get it up and running on any platform that LLVM can compile on. You will need CMake installed.","title":"Setup"},{"location":"setup/#1-install-llvm","text":"See LLVM the LLVM documentation on how to set up LLVM 10 for development. On OS X, installing through Homebrew works fine. Using apt-get on Linux should work fine as well.","title":"1. Install LLVM"},{"location":"setup/#2-clone-the-c3-compiler-source-code-from-github","text":"This should be as simple as doing: git clone https://github.com/c3lang/c3c.git ... from the command line.","title":"2. Clone the C3 compiler source code from Github"},{"location":"setup/#3-build-the-compiler","text":"Create the build directory: MyMachine:c3c$ mkdir build MyMachine:c3c$ cd build/ Use CMake to set up: MyMachine:c3c/build$ cmake ../ Build the compiler: MyMachine:c3c/build$ make","title":"3. Build the compiler"},{"location":"setup/#4-test-it-out","text":"MyMachine:c3c/build$ ./c3c compile ../resources/testfragments/helloworld.c3","title":"4. Test it out"},{"location":"specialfunctions/","text":"Built in functions C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc abs Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long) byteswap Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long) bitreverse Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long) ceil Return the closest integral number, rounded up. float ceilf(float) double ceil(double) clz Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong) cos Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad) ctz Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"Built in functions"},{"location":"specialfunctions/#built-in-functions","text":"C3 offers direct access to built in functions where available for certain operations. Often these are implemented as generic functions that may have multiple implementations. abs byteswap bitreverse ceil clz cos ctz divfloor divtrunc exp exp2 floor ln log2 log10 memcpy memset mod muloverflow popcount shlexact shrexact sin sqrt suboverflow trunc","title":"Built in functions"},{"location":"specialfunctions/#abs","text":"Returns the absolute value of a float or integer value. The underlying functions are: float fabsf(float) double fabsf(double) quad fabsl(quad) * char absc(char) int abs(int) long absl(long)","title":"abs"},{"location":"specialfunctions/#byteswap","text":"Swaps the byte order, switching between little endian and big endian. The underlying functions are: ushort byteswapus(ushort) short byteswaps(short) uint byteswapu(uint) int byteswap(int) ulong byteswapul(ulong) long byteswapl(long)","title":"byteswap"},{"location":"specialfunctions/#bitreverse","text":"Reverses all bits in an integer, including the sign bit the underlying functions are byte bitreverseb(byte) char bitreversec(char) ushort bitreverseus(ushort) short bitreverses(short) uint bitreverseu(uint) int bitreverse(int) ulong bitreverseul(ulong) long bitreversel(long)","title":"bitreverse"},{"location":"specialfunctions/#ceil","text":"Return the closest integral number, rounded up. float ceilf(float) double ceil(double)","title":"ceil"},{"location":"specialfunctions/#clz","text":"Return the number of leading zeroes. uint clzb(byte/char) uint clz(int/uint) uint clzl(long/ulong)","title":"clz"},{"location":"specialfunctions/#cos","text":"Return the cos value from radian angle. float cosf(float) double cos(double) quad cos(quad)","title":"cos"},{"location":"specialfunctions/#ctz","text":"Return the number of trailing zeroes. uint ctzb(byte/char) uint ctz(int/uint) uint ctzl(long/ulong)","title":"ctz"},{"location":"specification/","text":"Specification THIS SPECIFICATION IS UNDER DEVELOPMENT Notation The syntax is specified using Extended Backus-Naur Form (EBNF): production ::= PRODUCTION_NAME '::=' expression? expression ::= alternative (\"|\" alternative)* alternative ::= term term* term ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition set ::= '[' (range | CHAR) (rang | CHAR)* ']' range ::= CHAR '-' CHAR group ::= '(' expression ')' option ::= expression '?' repetition ::= expression '*' Productions are expressions constructed from terms and the following operators, in increasing precedence: | alternation () grouping ? option (0 or 1 times) * repetition (0 to n times) Uppercase production names are used to identify lexical tokens. Non-terminals are in lower case. Lexical tokens are enclosed in single quotes ''. The form a..b represents the set of characters from a through b as alternatives. Source code representation A program consists of one or more translation units stored in files written in the Unicode character set, stored as a sequence of bytes using the UTF-8 encoding. Except for comments and the contents of character and string literals, all input elements are formed only from the ASCII subset (U+0000 to U+007F) of Unicode. A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar. Lexical Translations A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar. The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would. Example: a--b is translated as a , -- , b , which does not form a grammatically correct expression, even >though the tokenization a , - , - , b could form a grammatically correct expression. Line Terminators The C3 compiler divides the sequence of input bytes into lines by recognizing line terminators Lines are terminated by the ASCII LF character (U+000A), also known as \"newline\". A line termination specifies the termination of the // form of a comment. Input Elements and Tokens An input element may be: White space Comment Doc Comment Token A token may be: Identifier Keyword Literal Separator Operator A Doc Comment consists of: A stream of descriptive text A list of directive Tokens Those input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the syntactic grammar. Whitespace and comments can serve to separate tokens that might be tokenized in another manner. For example the characters + and = may form the operator token += only if there is no intervening white space or comment. White Space White space is defined as the ASCII horizontal tab character (U+0009), form feed character (U+000A), vertical tab (U+000B), carriage return (U+000D), space character (U+0020) and the line terminator character (U+000D). WHITESPACE ::= [ \\t\\f\\v\\r\\n] Letters and digits UC_LETTER ::= [A-Z] LC_LETTER ::= [a-z] LETTER ::= UC_LETTER | LC_LETTER DIGIT ::= [0-9] HEX_DIGIT ::= [0-9a-fA-F] BINARY_DIGIT ::= [01] OCTAL_DIGIT ::= [0-7] UC_LETTER_US ::= UC_LETTER | \"_\" ALPHANUM ::= LETTER | DIGIT ALPHANUM_US ::= ALPHANUM | \"_\" UC_ALPHANUM_US ::= UC_LETTER_US | DIGIT Comments Thre are three types of regular comments: // text a line comment. The text between // and line end is ignored. /* text */ block comments. The text between /* and */ is ignored. It has nesting behaviour, so for every /* discovered between the first /* and the last */ a corresponding */ must be found. Doc comments /** text **/ doc block comment. The text between /** and **/ is optionally parsed using the doc comment syntatic grammar. A compiler may choose to read /** text **/ as a regular comment. /// text doc line comment. The text between /// and line end is optionally parsed using the doc comment syntactic grammar. A compiler may choose to read /// as a regular comment. Identifiers Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter or underscore. C3 has three types of identifiers: const identifiers - containing only underscore and upper-case letters, type identifiers - starting with an upper case letter followed by at least one underscore letter and regular identifiers, starting with a lower case letter. IDENTIFIER ::= \"_\"* LC_LETTER ALPHANUM_US* CONST_IDENT ::= \"_\"* UC_LETTER UC_ALPHANUM_US* TYPE_IDENT ::= \"_\"* UC_LETTER \"_\"* LC_LETTER ALPHANUM_US* CT_IDENT ::= \"$\" IDENTIFIER CT_CONST_IDENT ::= \"$\" CONST_IDENT CT_TYPE_IDENT ::= \"$\" TYPE_IDENT Keywords The following keywords are reserved and may not be used as identifiers: alias as asm anyerr assert attribute break case cast catch const continue default defer define do else enum extern errtype false fn generic if import in local macro module nextcase nil public return struct switch true try typeid $typeof define var volatile void while bool quad double float long ulong int uint byte short ushort char isz usz float16 float128 $assert $case $default $if $for $else $elif $if $switch $foreach $endswitch $endif $endforeach Operators and punctuation The following character sequences represent operators and punctuation. & @ ~ | ^ : , / $ . ; ) > < # { } - ( ) * [ ] % >= <= + += -= ! ? ?: && -> &= |= ^= /= .. == ({ }) -% +% *% ++ -- %= != || :: << >> !! ... *%= +%= -%= <<= >>= Integer literals An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. INTEGER ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT DECIMAL_LIT ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)? BINARY_LIT ::= '0' [bB] '_'* BINARY_DIGITS OCTAL_LIT ::= '0' [oO] '_'* OCTAL_DIGITS HEX_LIT ::= '0' [xX] '_'* HEX_DIGITS BINARY_DIGIT ::= [01] HEX_DIGIT ::= [0-9a-fA-F] DECIMAL_DIGITS ::= DIGIT ('_'* DIGIT)* BINARY_DIGITS ::= BINARY_DIGIT ('_'* BINARY_DIGIT)* OCTAL_DIGITS ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)* HEX_DIGITS ::= HEX_DIGIT ('_'* HEX_DIGIT)* 42 4_2 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 0600 // Invalid, non zero decimal number may not start with 0 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 0_xBadFace // invalid: _ must separate successive digits Floating point literals A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by powers of 10. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. An exponent value exp scales the mantissa (integer and fractional part) by powers of 2. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. FLOAT_LIT ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT DEC_FLOAT_LIT ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? | DECIMAL_DIGITS DEC_EXPONENT | '.' DECIMAL_DIGITS DEC_EXPONENT? DEC_EXPONENT ::= [eE] [+-]? DECIMAL_DIGITS HEX_FLOAT_LIT ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT HEX_MANTISSA ::= HEX_DIGITS '.' HEX_DIGITS? | HEX_DIGITS | '.' HEX_DIGITS HEX_EXPONENT ::= [pP] [+-] DECIMAL_DIGITS Character literals A character literal may either: (a) represent a constant value of up to 8 bytes (16 bytes on platforms with Int128 support) or (b) a single unicode character. Escape sequences can be used to represent byte values 0-31 and 128-255. The following backslash escapes are available to escape: \\0 0x00 zero value \\a 0x07 alert/bell \\b 0x08 backspace \\e 0x1B escape \\f 0x0C form feed \\n 0x0A newline \\r 0x0D carriage return \\t 0x09 horizontal tab \\v 0x0B vertical tab \\\\ 0x5C backslash \\' 0x27 single quote ' \\\" 0x22 double quote \" \\x Escapes a single byte hex value \\u Escapes a two byte unicode hex value \\U Escapes a four byte unicode hex value CHAR_ELEMENT ::= [\\x20-\\x26] | [\\x28-\\x5B] | [\\x5D-\\x7F] CHAR_LIT_BYTE ::= CHAR_ELEMENT | \\x5C CHAR_ESCAPE CHAR_ESCAPE ::= [abefnrtv\\'\\\"\\\\] | 'x' HEX_DIGIT HEX_DIGIT UNICODE_CHAR ::= unicode_char | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT CHARACTER_LIT ::= \"'\" (CHAR_LIT_BYTE+) | UNICODE_CHAR \"'\" String literals A string literal represents a string constant obtained from concatenating a sequence of characters. String literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals, with the same restrictions. The two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. STRING_LIT ::= \\x22 (CHAR_LIT_BYTE | UNICODE_CHAR)* \\x22 Types Types consist of built-in types and user-defined types (enums, structs, unions, bitstructs, errtype and distinct). Boolean types The Integer types Floating point types Vector types Complex types A complex type is defined as a struct with two elements of the same floating point type. The first member holds the real part of a complex number, and the second member holds the imaginary part. struct Complex { float real; float imaginary; } String types Array types An array has the alignment of its element. Zero sized arrays are allowed and have the size 0. Vararray types Subarray types The subarray consist of a pointer, followed by a usz length, having the alignment of pointers. Pointer types Struct types A struct without any members or with only arrays of size 0 have the size 0. The alignment of a struct without any members is 1. Union types The alignment of a union without any members is 1. Error types Th Enum types Function types Virtual types Declarations and scope Expressions Casts Pointer casts Integer to pointer cast Any integer of pointer size or larger may be explicitly cast to a pointer. An integer to pointer cast is considered non-constant, except in the special case where the integer == 0. In that case, the result is constant null . Example: byte a = 1; int* b = (int*)a; // Invalid, pointer type is > 8 bits. int* c = (int*)1; // Valid, but runtime value. int* d = (int*)0; // Valid and constant value. Pointer to integer cast A pointer may be cast to any integer, truncating the pointer value if the size of the pointer is larger than the pointer size. A pointer to integer cast is considered non-constant, except in the special case of a null pointer, where it is equal to the integer value 0. Example: fn void test() { ... } define VoidFunc = fn void test(); VoidFunc a = &test; int b = (int)null; int c = (int)a; // Invalid, not constant int d = (int)((int*)1); // Invalid, not constant Subscript operator The subscript operator may take as its left side a pointer, array, subarray or vararray. The index may be of any integer type. TODO NOTE The subscript operator is not symmetrical as in C. For example in C3 array[n] = 33 is allowed, but not n[array] = 33 . This is a change from C. Operands Compound Literals Compound literals have the format compound_literal ::= TYPE_IDENTIFIER '(' initializer_list ')' initializer_list ::= '{' (initializer_param (',' initializer_param)* ','?)? '}' initializer_param ::= expression | designator '=' expression designator ::= array_designator | range_designator | field_designator array_designator ::= '[' expression ']' range_designator ::= '[' range_expression ']' field_designator ::= IDENTIFIER range_expression ::= (range_index)? '..' (range_index)? range_index ::= expression | '^' expression Taking the address of a compound literal will yield a pointer to stack allocated temporary. Function calls Varargs For varargs, a bool or any integer smaller than what the C ABI specifies for the c int type is cast to int . Any float smaller than a double is cast to double . Compile time floats will be cast to double. Compile time integers will be cast to c int type. Statements If statement Switch stat Modules","title":"Specification"},{"location":"specification/#specification","text":"THIS SPECIFICATION IS UNDER DEVELOPMENT","title":"Specification"},{"location":"specification/#notation","text":"The syntax is specified using Extended Backus-Naur Form (EBNF): production ::= PRODUCTION_NAME '::=' expression? expression ::= alternative (\"|\" alternative)* alternative ::= term term* term ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition set ::= '[' (range | CHAR) (rang | CHAR)* ']' range ::= CHAR '-' CHAR group ::= '(' expression ')' option ::= expression '?' repetition ::= expression '*' Productions are expressions constructed from terms and the following operators, in increasing precedence: | alternation () grouping ? option (0 or 1 times) * repetition (0 to n times) Uppercase production names are used to identify lexical tokens. Non-terminals are in lower case. Lexical tokens are enclosed in single quotes ''. The form a..b represents the set of characters from a through b as alternatives.","title":"Notation"},{"location":"specification/#source-code-representation","text":"A program consists of one or more translation units stored in files written in the Unicode character set, stored as a sequence of bytes using the UTF-8 encoding. Except for comments and the contents of character and string literals, all input elements are formed only from the ASCII subset (U+0000 to U+007F) of Unicode. A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar.","title":"Source code representation"},{"location":"specification/#lexical-translations","text":"A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols of the syntactic grammar. The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would. Example: a--b is translated as a , -- , b , which does not form a grammatically correct expression, even >though the tokenization a , - , - , b could form a grammatically correct expression.","title":"Lexical Translations"},{"location":"specification/#line-terminators","text":"The C3 compiler divides the sequence of input bytes into lines by recognizing line terminators Lines are terminated by the ASCII LF character (U+000A), also known as \"newline\". A line termination specifies the termination of the // form of a comment.","title":"Line Terminators"},{"location":"specification/#input-elements-and-tokens","text":"An input element may be: White space Comment Doc Comment Token A token may be: Identifier Keyword Literal Separator Operator A Doc Comment consists of: A stream of descriptive text A list of directive Tokens Those input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the syntactic grammar. Whitespace and comments can serve to separate tokens that might be tokenized in another manner. For example the characters + and = may form the operator token += only if there is no intervening white space or comment.","title":"Input Elements and Tokens"},{"location":"specification/#white-space","text":"White space is defined as the ASCII horizontal tab character (U+0009), form feed character (U+000A), vertical tab (U+000B), carriage return (U+000D), space character (U+0020) and the line terminator character (U+000D). WHITESPACE ::= [ \\t\\f\\v\\r\\n]","title":"White Space"},{"location":"specification/#letters-and-digits","text":"UC_LETTER ::= [A-Z] LC_LETTER ::= [a-z] LETTER ::= UC_LETTER | LC_LETTER DIGIT ::= [0-9] HEX_DIGIT ::= [0-9a-fA-F] BINARY_DIGIT ::= [01] OCTAL_DIGIT ::= [0-7] UC_LETTER_US ::= UC_LETTER | \"_\" ALPHANUM ::= LETTER | DIGIT ALPHANUM_US ::= ALPHANUM | \"_\" UC_ALPHANUM_US ::= UC_LETTER_US | DIGIT","title":"Letters and digits"},{"location":"specification/#comments","text":"Thre are three types of regular comments: // text a line comment. The text between // and line end is ignored. /* text */ block comments. The text between /* and */ is ignored. It has nesting behaviour, so for every /* discovered between the first /* and the last */ a corresponding */ must be found.","title":"Comments"},{"location":"specification/#doc-comments","text":"/** text **/ doc block comment. The text between /** and **/ is optionally parsed using the doc comment syntatic grammar. A compiler may choose to read /** text **/ as a regular comment. /// text doc line comment. The text between /// and line end is optionally parsed using the doc comment syntactic grammar. A compiler may choose to read /// as a regular comment.","title":"Doc comments"},{"location":"specification/#identifiers","text":"Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter or underscore. C3 has three types of identifiers: const identifiers - containing only underscore and upper-case letters, type identifiers - starting with an upper case letter followed by at least one underscore letter and regular identifiers, starting with a lower case letter. IDENTIFIER ::= \"_\"* LC_LETTER ALPHANUM_US* CONST_IDENT ::= \"_\"* UC_LETTER UC_ALPHANUM_US* TYPE_IDENT ::= \"_\"* UC_LETTER \"_\"* LC_LETTER ALPHANUM_US* CT_IDENT ::= \"$\" IDENTIFIER CT_CONST_IDENT ::= \"$\" CONST_IDENT CT_TYPE_IDENT ::= \"$\" TYPE_IDENT","title":"Identifiers"},{"location":"specification/#keywords","text":"The following keywords are reserved and may not be used as identifiers: alias as asm anyerr assert attribute break case cast catch const continue default defer define do else enum extern errtype false fn generic if import in local macro module nextcase nil public return struct switch true try typeid $typeof define var volatile void while bool quad double float long ulong int uint byte short ushort char isz usz float16 float128 $assert $case $default $if $for $else $elif $if $switch $foreach $endswitch $endif $endforeach","title":"Keywords"},{"location":"specification/#operators-and-punctuation","text":"The following character sequences represent operators and punctuation. & @ ~ | ^ : , / $ . ; ) > < # { } - ( ) * [ ] % >= <= + += -= ! ? ?: && -> &= |= ^= /= .. == ({ }) -% +% *% ++ -- %= != || :: << >> !! ... *%= +%= -%= <<= >>=","title":"Operators and punctuation"},{"location":"specification/#integer-literals","text":"An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value. INTEGER ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT DECIMAL_LIT ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)? BINARY_LIT ::= '0' [bB] '_'* BINARY_DIGITS OCTAL_LIT ::= '0' [oO] '_'* OCTAL_DIGITS HEX_LIT ::= '0' [xX] '_'* HEX_DIGITS BINARY_DIGIT ::= [01] HEX_DIGIT ::= [0-9a-fA-F] DECIMAL_DIGITS ::= DIGIT ('_'* DIGIT)* BINARY_DIGITS ::= BINARY_DIGIT ('_'* BINARY_DIGIT)* OCTAL_DIGITS ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)* HEX_DIGITS ::= HEX_DIGIT ('_'* HEX_DIGIT)* 42 4_2 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 0600 // Invalid, non zero decimal number may not start with 0 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 0_xBadFace // invalid: _ must separate successive digits","title":"Integer literals"},{"location":"specification/#floating-point-literals","text":"A floating-point literal is a decimal or hexadecimal representation of a floating-point constant. A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by powers of 10. A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. An exponent value exp scales the mantissa (integer and fractional part) by powers of 2. For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value. FLOAT_LIT ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT DEC_FLOAT_LIT ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? | DECIMAL_DIGITS DEC_EXPONENT | '.' DECIMAL_DIGITS DEC_EXPONENT? DEC_EXPONENT ::= [eE] [+-]? DECIMAL_DIGITS HEX_FLOAT_LIT ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT HEX_MANTISSA ::= HEX_DIGITS '.' HEX_DIGITS? | HEX_DIGITS | '.' HEX_DIGITS HEX_EXPONENT ::= [pP] [+-] DECIMAL_DIGITS","title":"Floating point literals"},{"location":"specification/#character-literals","text":"A character literal may either: (a) represent a constant value of up to 8 bytes (16 bytes on platforms with Int128 support) or (b) a single unicode character. Escape sequences can be used to represent byte values 0-31 and 128-255. The following backslash escapes are available to escape: \\0 0x00 zero value \\a 0x07 alert/bell \\b 0x08 backspace \\e 0x1B escape \\f 0x0C form feed \\n 0x0A newline \\r 0x0D carriage return \\t 0x09 horizontal tab \\v 0x0B vertical tab \\\\ 0x5C backslash \\' 0x27 single quote ' \\\" 0x22 double quote \" \\x Escapes a single byte hex value \\u Escapes a two byte unicode hex value \\U Escapes a four byte unicode hex value CHAR_ELEMENT ::= [\\x20-\\x26] | [\\x28-\\x5B] | [\\x5D-\\x7F] CHAR_LIT_BYTE ::= CHAR_ELEMENT | \\x5C CHAR_ESCAPE CHAR_ESCAPE ::= [abefnrtv\\'\\\"\\\\] | 'x' HEX_DIGIT HEX_DIGIT UNICODE_CHAR ::= unicode_char | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT CHARACTER_LIT ::= \"'\" (CHAR_LIT_BYTE+) | UNICODE_CHAR \"'\"","title":"Character literals"},{"location":"specification/#string-literals","text":"A string literal represents a string constant obtained from concatenating a sequence of characters. String literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals, with the same restrictions. The two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\xFF represent a single byte of value 0xFF=255, while \u00ff, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF. STRING_LIT ::= \\x22 (CHAR_LIT_BYTE | UNICODE_CHAR)* \\x22","title":"String literals"},{"location":"specification/#types","text":"Types consist of built-in types and user-defined types (enums, structs, unions, bitstructs, errtype and distinct).","title":"Types"},{"location":"specification/#boolean-types","text":"The","title":"Boolean types"},{"location":"specification/#integer-types","text":"","title":"Integer types"},{"location":"specification/#floating-point-types","text":"","title":"Floating point types"},{"location":"specification/#vector-types","text":"","title":"Vector types"},{"location":"specification/#complex-types","text":"A complex type is defined as a struct with two elements of the same floating point type. The first member holds the real part of a complex number, and the second member holds the imaginary part. struct Complex { float real; float imaginary; }","title":"Complex types"},{"location":"specification/#string-types","text":"","title":"String types"},{"location":"specification/#array-types","text":"An array has the alignment of its element. Zero sized arrays are allowed and have the size 0.","title":"Array types"},{"location":"specification/#vararray-types","text":"","title":"Vararray types"},{"location":"specification/#subarray-types","text":"The subarray consist of a pointer, followed by a usz length, having the alignment of pointers.","title":"Subarray types"},{"location":"specification/#pointer-types","text":"","title":"Pointer types"},{"location":"specification/#struct-types","text":"A struct without any members or with only arrays of size 0 have the size 0. The alignment of a struct without any members is 1.","title":"Struct types"},{"location":"specification/#union-types","text":"The alignment of a union without any members is 1.","title":"Union types"},{"location":"specification/#error-types","text":"Th","title":"Error types"},{"location":"specification/#enum-types","text":"","title":"Enum types"},{"location":"specification/#function-types","text":"","title":"Function types"},{"location":"specification/#virtual-types","text":"","title":"Virtual types"},{"location":"specification/#declarations-and-scope","text":"","title":"Declarations and scope"},{"location":"specification/#expressions","text":"","title":"Expressions"},{"location":"specification/#casts","text":"","title":"Casts"},{"location":"specification/#pointer-casts","text":"","title":"Pointer casts"},{"location":"specification/#integer-to-pointer-cast","text":"Any integer of pointer size or larger may be explicitly cast to a pointer. An integer to pointer cast is considered non-constant, except in the special case where the integer == 0. In that case, the result is constant null . Example: byte a = 1; int* b = (int*)a; // Invalid, pointer type is > 8 bits. int* c = (int*)1; // Valid, but runtime value. int* d = (int*)0; // Valid and constant value.","title":"Integer to pointer cast"},{"location":"specification/#pointer-to-integer-cast","text":"A pointer may be cast to any integer, truncating the pointer value if the size of the pointer is larger than the pointer size. A pointer to integer cast is considered non-constant, except in the special case of a null pointer, where it is equal to the integer value 0. Example: fn void test() { ... } define VoidFunc = fn void test(); VoidFunc a = &test; int b = (int)null; int c = (int)a; // Invalid, not constant int d = (int)((int*)1); // Invalid, not constant","title":"Pointer to integer cast"},{"location":"specification/#subscript-operator","text":"The subscript operator may take as its left side a pointer, array, subarray or vararray. The index may be of any integer type. TODO NOTE The subscript operator is not symmetrical as in C. For example in C3 array[n] = 33 is allowed, but not n[array] = 33 . This is a change from C.","title":"Subscript operator"},{"location":"specification/#operands","text":"","title":"Operands"},{"location":"specification/#compound-literals","text":"Compound literals have the format compound_literal ::= TYPE_IDENTIFIER '(' initializer_list ')' initializer_list ::= '{' (initializer_param (',' initializer_param)* ','?)? '}' initializer_param ::= expression | designator '=' expression designator ::= array_designator | range_designator | field_designator array_designator ::= '[' expression ']' range_designator ::= '[' range_expression ']' field_designator ::= IDENTIFIER range_expression ::= (range_index)? '..' (range_index)? range_index ::= expression | '^' expression Taking the address of a compound literal will yield a pointer to stack allocated temporary.","title":"Compound Literals"},{"location":"specification/#function-calls","text":"","title":"Function calls"},{"location":"specification/#varargs","text":"For varargs, a bool or any integer smaller than what the C ABI specifies for the c int type is cast to int . Any float smaller than a double is cast to double . Compile time floats will be cast to double. Compile time integers will be cast to c int type.","title":"Varargs"},{"location":"specification/#statements","text":"","title":"Statements"},{"location":"specification/#if-statement","text":"","title":"If statement"},{"location":"specification/#switch-stat","text":"","title":"Switch stat"},{"location":"specification/#modules","text":"","title":"Modules"},{"location":"standard_library/","text":"Library The standard library is currently in development, so frequent changes will occur. Note that all std::core modules and sub modules are implicitly imported. std::core::builtin All functions and macros in this library can be used without path qualifiers. void panic(char message, char file, char *function, uint line) Default function called when the asserts fails. void @swap(&a, &b) Swap values in a and b . int a = 3; int b = 5; @swap(a, b); io::printfn(\"%d\", a); // Prints 5 varcast(variant v, $Type) Optionally cast the value v to type $Type* on failure returns VarCastResult.TYPE_MISMATCH . int b; variant a = &b; float*! c = varcast(a, float); // Will return TYPE_MISMATCH int*! d = varcast(a, int); // Works! void unreachable($string = \"Unreachable statement reached.\") Mark a code path as unreachable. switch (x) { case 0: foo(); case 1: bar(); default: // Should never happen. unreachable(\"x should have been 0 or 1\"); } On safe mode this will throw a runtime panic when reached. For release mode the compiler will assume this case never happens. bitcast(value, $Type) Do a bitcast of a value to $Type , requires that the types are of the same memory size. float x = 1.0; int y = bitcast(x, int); // y = 0x3f800000 enum_by_name($Type, enum_name) Optionally returns the enum value with the given name. $Type must be an enum. Returns SearchResult.MISSING on failure. enum Foo { ABC, CDE, EFG } fn void! test() { Foo f = enum_by_name(Foo, \"CDE\")?; // same as Foo f = Foo.CDE; } void @scope(&variable; @body) Scopes a variable: int a = 3; @scope(a) { a = 4; a++; }; // Prints a = 3 io::printfn(\"a = %d\", a, b); less, greater, less_eq, greater_eq, equals All macros take two values and compare them. Any type implementing Type.less or Type.compare_to may be compared (or if the type implements < ). Types implementing Type.equals may use equals even if neither less nor compare_to are implemented. Faults IteratorResult returned when reaching the end of an iterator. SearchResult used when a search fails. VarCastResult when a variant cast fails. std::core::env Constants OS_TYPE the OS type compiled for. COMPILER_OPT_LEVEL the optimization level used. I128_SUPPORT true if int128 support is available. COMPILER_SAFE_MODE true if compiled with safety checks. std::core::mem malloc, malloc_checked, malloc_aligned Allocate the given number of bytes. malloc will panic on out of memory, whereas malloc_checked and malloc_aligned returns an optional value. malloc_aligned adds an alignment, which must be a power of 2. Any pointer allocated using malloc_aligned must be freed using free_aligned rather the normal free or memory corruption may result. char* data = malloc(8); char*! data2 = malloc_checked(8); int[<16>]*! data3 = malloc_aligned(16 * int.sizeof), 128); calloc, calloc_checked, calloc_aligned Identical to malloc , except the data is guaranteed to be zeroed out. relloc, relloc_checked, realloc_aligned Resizes memory allocated using malloc or calloc . Any extra data is guaranteed to be zeroed out. realloc_aligned can only be used with pointers created using calloc_aligned or alloc_aligned . free, free_aligned Frees memory allocated using malloc or calloc . char[] alloc_bytes(usz bytes) Similar to malloc, but returns the data as a subarray. Will panic on out of memory. alloc($Type) Will allocate enough memory for exactly the type provided: Foo* f = mem::alloc(Foo); @scoped(Allocator* allocator; @body()) Swaps the current memory allocator for the duration of the call. DynamicArenaAllocator dynamic_arena; dynamic_arena.init(1024); mem::@scoped(&dynamic_arena) { // This allocation uses the dynamic arena Foo* f = mem::alloc(Foo); }; // Release any dynamic arena memory. dynamic_arena.destroy(); @tscoped(; @body()) Same as @scoped, but uses the temporary allocator rather than any arbitrary allocator. void* tmalloc(usz size, usz alignment = 0) Allocates memory using the temporary allocator. Panic on failure. void* tcalloc(usz size, usz alignment = 0) Same as tmalloc but clears the memory. void trealloc(void ptr, usz size, usz alignment = 0) realloc but on memory received using tcalloc or tmalloc . talloc($Type) Like alloc but using the temporary allocator. void @pool(;@body) Opens a temporary memory scope. @poo() { // This allocation uses the dynamic arena Foo* f = talloc(Foo); }; @volatile_load(&x) Returns the value in x using a volatile load. // Both loads will always happen: int y = @volatile_load(my_global); y = @volatile_load(my_global); @volatile_store(&x, y) Store the value y in x using a volatile store. // Both stores will always happen: @volatile_store(y, 1); @volatile_store(y, 1); usz aligned_offset(usz offset, usz alignment) Returns an aligned size based on the current offset. The alignment must be a power of two. E.g. mem::aligned_offset(17, 8) would return 24 usz aligned_pointer(void* ptr, usz alignment) Returns a pointer aligned to the given alignment, using aligned_offset . bool ptr_is_aligned(void* ptr, usz alignment) Return true if the pointer is aligned, false otherwise. void copy(void dst, void src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false) Copies bytes from one pointer to another. It may optionally be set as volatile, in which case the copy may not be optimized away. Furthermore the source and destination alignment may be used. Foo* f = talloc(data_size); mem::copy(f, slice.ptr, size); void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false) Sets bytes to a value. This operation may be aligned and/or volatile. See the copy method. void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false) Sets bytes to zero. This operation may be aligned and/or volatile. See the copy method. @clone(&value) Makes a shallow copy of a value using the regular allocator. Foo f = ... return @clone(f); @tclone(&value) Same as @clone but uses the temporary allocator. std::core::mem::array alloc($Type, usz elements) Allocate a slice with elements number of elements, returning a subarray of the given length. Elements are not initialized. array::talloc variant uses the temporary allocator. int[] ints = array::alloc(int, 100); make($Type, usz elements) Like array::alloc but all elements are cleared. tmake variant uses the temporary allocator. std::core::types bool is_comparable($Type) Return true if the type can be used with comparison operators. bool is_equatable_value(value) Return true if the value can be compared using the equals macro. bool is_equatable_value(value) Return true if the value can be compared using the comparison macros. kind_is_int(TypeKind kind) variant_to_int(variant v, $Type) Returns an optional value of $Type if the variant value losslessly may be converted into the given type. Returns a ConversionResult otherwise. variant v = &&128; short y = variant_to_int(v, short)!!; // Works ichar z = variant_to_int(v, ichar)!!; // Panics VALUE_OUT_OF_RANGE std::core::string::conv usz! char32_to_utf8(Char32 c, char* output, usz available) Convert a UTF32 codepoint to an UTF8 buffer. size has the number of writable bytes left. It returns the number of bytes used, or UnicodeResult.CONVERSION_FAILED if the buffer is too small. void char32_to_utf16_unsafe(Char32 c, Char16** output) Convert a UTF32 codepoint to an UTF16 buffer without bounds checking, moving the output pointer 1 or 2 steps. std::io usz! printf(String format, args...) @maydiscard Regular printf functionality: %s , %x , %d , %f and %p are supported. Will also print enums and vectors. usz! VarString.printf(VarString* str, String format, args...) @maydiscard Same as printf but on varstrings. usz! File.printf(File file, String format, args...) @maydiscard Same as printf but on files. void! File.open(File* file, String filename, String mode) Open a file with the given file name with the given mode (r, w etc) void! File.seek(File *file, long offset, Seek seekMode = Seek.SET) Seek in a file. Based on the libc function. void! File.close(File *file) @inline Close a file, based on the libc function. bool File.eof(File* file) @inline True if EOF has been reached. Based on the libc function. void! File.putc(File *file, char c) Write a single byte to a file. See the libc function. usz File.read(File file, void buffer, usz items, usz element_size = 1) Read into a buffer, based on the libc function. usz File.write(File file, void buffer, usz items, usz element_size = 1) Write to a buffer, based on the libc function. stdout(), stdin(), stderr() Return stdout, stdin and stderr respectively. std::collections::list Generic list module, elements are of Type . import std::collections::list; define MyIntList = List<int>; ... MyIntList list; list.push(123); list.free(); List.push(List *list, Type element), append(...) Append a single value to the list. Type List.pop(List* list) Removes and returns the last entry in the list. Type List.pop_first(List *list) Removes the first entry in the list. void List.remove_at(List *list, usz index) Removes the entry at index . void List.insert_at(List *list, usz index, Type type) Inserts a value at index . void List.push_front(List *list, Type type) Inserts a value to the front of the list. void List.remove_last(List* list) Remove the last value of the list. void List.remove_first(List *list) Remove the first element in the list. Type List.first(List list) Return the first element in the list if available. Type List.last(List list) Return the last element in the list if available. List.is_empty(List *list) Return true if the list is empty. usz List.len(List *list) Return the number of elements in the list. Type List.get(List *list, usz index) Return the value at index . void List.free(List *list) Free all memory associated with this list. void List.swap(List *list, usz i, usz j) Swap two elements in the list.","title":"Standard Library"},{"location":"standard_library/#library","text":"The standard library is currently in development, so frequent changes will occur. Note that all std::core modules and sub modules are implicitly imported.","title":"Library"},{"location":"standard_library/#stdcorebuiltin","text":"All functions and macros in this library can be used without path qualifiers.","title":"std::core::builtin"},{"location":"standard_library/#void-panicchar-message-char-file-char-function-uint-line","text":"Default function called when the asserts fails.","title":"void panic(char message, char file, char *function, uint line)"},{"location":"standard_library/#void-swapa-b","text":"Swap values in a and b . int a = 3; int b = 5; @swap(a, b); io::printfn(\"%d\", a); // Prints 5","title":"void @swap(&amp;a, &amp;b)"},{"location":"standard_library/#varcastvariant-v-type","text":"Optionally cast the value v to type $Type* on failure returns VarCastResult.TYPE_MISMATCH . int b; variant a = &b; float*! c = varcast(a, float); // Will return TYPE_MISMATCH int*! d = varcast(a, int); // Works!","title":"varcast(variant v, $Type)"},{"location":"standard_library/#void-unreachablestring-unreachable-statement-reached","text":"Mark a code path as unreachable. switch (x) { case 0: foo(); case 1: bar(); default: // Should never happen. unreachable(\"x should have been 0 or 1\"); } On safe mode this will throw a runtime panic when reached. For release mode the compiler will assume this case never happens.","title":"void unreachable($string = \"Unreachable statement reached.\")"},{"location":"standard_library/#bitcastvalue-type","text":"Do a bitcast of a value to $Type , requires that the types are of the same memory size. float x = 1.0; int y = bitcast(x, int); // y = 0x3f800000","title":"bitcast(value, $Type)"},{"location":"standard_library/#enum_by_nametype-enum_name","text":"Optionally returns the enum value with the given name. $Type must be an enum. Returns SearchResult.MISSING on failure. enum Foo { ABC, CDE, EFG } fn void! test() { Foo f = enum_by_name(Foo, \"CDE\")?; // same as Foo f = Foo.CDE; }","title":"enum_by_name($Type, enum_name)"},{"location":"standard_library/#void-scope-body","text":"Scopes a variable: int a = 3; @scope(a) { a = 4; a++; }; // Prints a = 3 io::printfn(\"a = %d\", a, b);","title":"void @scope(&variable; @body)"},{"location":"standard_library/#less-greater-less_eq-greater_eq-equals","text":"All macros take two values and compare them. Any type implementing Type.less or Type.compare_to may be compared (or if the type implements < ). Types implementing Type.equals may use equals even if neither less nor compare_to are implemented.","title":"less, greater, less_eq, greater_eq, equals"},{"location":"standard_library/#faults","text":"IteratorResult returned when reaching the end of an iterator. SearchResult used when a search fails. VarCastResult when a variant cast fails.","title":"Faults"},{"location":"standard_library/#stdcoreenv","text":"","title":"std::core::env"},{"location":"standard_library/#constants","text":"OS_TYPE the OS type compiled for. COMPILER_OPT_LEVEL the optimization level used. I128_SUPPORT true if int128 support is available. COMPILER_SAFE_MODE true if compiled with safety checks.","title":"Constants"},{"location":"standard_library/#stdcoremem","text":"","title":"std::core::mem"},{"location":"standard_library/#malloc-malloc_checked-malloc_aligned","text":"Allocate the given number of bytes. malloc will panic on out of memory, whereas malloc_checked and malloc_aligned returns an optional value. malloc_aligned adds an alignment, which must be a power of 2. Any pointer allocated using malloc_aligned must be freed using free_aligned rather the normal free or memory corruption may result. char* data = malloc(8); char*! data2 = malloc_checked(8); int[<16>]*! data3 = malloc_aligned(16 * int.sizeof), 128);","title":"malloc, malloc_checked, malloc_aligned"},{"location":"standard_library/#calloc-calloc_checked-calloc_aligned","text":"Identical to malloc , except the data is guaranteed to be zeroed out.","title":"calloc, calloc_checked, calloc_aligned"},{"location":"standard_library/#relloc-relloc_checked-realloc_aligned","text":"Resizes memory allocated using malloc or calloc . Any extra data is guaranteed to be zeroed out. realloc_aligned can only be used with pointers created using calloc_aligned or alloc_aligned .","title":"relloc, relloc_checked, realloc_aligned"},{"location":"standard_library/#free-free_aligned","text":"Frees memory allocated using malloc or calloc .","title":"free, free_aligned"},{"location":"standard_library/#char-alloc_bytesusz-bytes","text":"Similar to malloc, but returns the data as a subarray. Will panic on out of memory.","title":"char[] alloc_bytes(usz bytes)"},{"location":"standard_library/#alloctype","text":"Will allocate enough memory for exactly the type provided: Foo* f = mem::alloc(Foo);","title":"alloc($Type)"},{"location":"standard_library/#scopedallocator-allocator-body","text":"Swaps the current memory allocator for the duration of the call. DynamicArenaAllocator dynamic_arena; dynamic_arena.init(1024); mem::@scoped(&dynamic_arena) { // This allocation uses the dynamic arena Foo* f = mem::alloc(Foo); }; // Release any dynamic arena memory. dynamic_arena.destroy();","title":"@scoped(Allocator* allocator; @body())"},{"location":"standard_library/#tscoped-body","text":"Same as @scoped, but uses the temporary allocator rather than any arbitrary allocator.","title":"@tscoped(; @body())"},{"location":"standard_library/#void-tmallocusz-size-usz-alignment-0","text":"Allocates memory using the temporary allocator. Panic on failure.","title":"void* tmalloc(usz size, usz alignment = 0)"},{"location":"standard_library/#void-tcallocusz-size-usz-alignment-0","text":"Same as tmalloc but clears the memory.","title":"void* tcalloc(usz size, usz alignment = 0)"},{"location":"standard_library/#void-treallocvoid-ptr-usz-size-usz-alignment-0","text":"realloc but on memory received using tcalloc or tmalloc .","title":"void trealloc(void ptr, usz size, usz alignment = 0)"},{"location":"standard_library/#talloctype","text":"Like alloc but using the temporary allocator.","title":"talloc($Type)"},{"location":"standard_library/#void-poolbody","text":"Opens a temporary memory scope. @poo() { // This allocation uses the dynamic arena Foo* f = talloc(Foo); };","title":"void @pool(;@body)"},{"location":"standard_library/#volatile_loadx","text":"Returns the value in x using a volatile load. // Both loads will always happen: int y = @volatile_load(my_global); y = @volatile_load(my_global);","title":"@volatile_load(&amp;x)"},{"location":"standard_library/#volatile_storex-y","text":"Store the value y in x using a volatile store. // Both stores will always happen: @volatile_store(y, 1); @volatile_store(y, 1);","title":"@volatile_store(&amp;x, y)"},{"location":"standard_library/#usz-aligned_offsetusz-offset-usz-alignment","text":"Returns an aligned size based on the current offset. The alignment must be a power of two. E.g. mem::aligned_offset(17, 8) would return 24","title":"usz aligned_offset(usz offset, usz alignment)"},{"location":"standard_library/#usz-aligned_pointervoid-ptr-usz-alignment","text":"Returns a pointer aligned to the given alignment, using aligned_offset .","title":"usz aligned_pointer(void* ptr, usz alignment)"},{"location":"standard_library/#bool-ptr_is_alignedvoid-ptr-usz-alignment","text":"Return true if the pointer is aligned, false otherwise.","title":"bool ptr_is_aligned(void* ptr, usz alignment)"},{"location":"standard_library/#void-copyvoid-dst-void-src-usz-len-usz-dst_align-0-usz-src_align-0-bool-is_volatile-false","text":"Copies bytes from one pointer to another. It may optionally be set as volatile, in which case the copy may not be optimized away. Furthermore the source and destination alignment may be used. Foo* f = talloc(data_size); mem::copy(f, slice.ptr, size);","title":"void copy(void dst, void src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)"},{"location":"standard_library/#void-setvoid-dst-char-val-usz-len-usz-dst_align-0-bool-is_volatile-false","text":"Sets bytes to a value. This operation may be aligned and/or volatile. See the copy method.","title":"void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)"},{"location":"standard_library/#void-clearvoid-dst-usz-len-usz-dst_align-0-bool-is_volatile-false","text":"Sets bytes to zero. This operation may be aligned and/or volatile. See the copy method.","title":"void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false)"},{"location":"standard_library/#clonevalue","text":"Makes a shallow copy of a value using the regular allocator. Foo f = ... return @clone(f);","title":"@clone(&amp;value)"},{"location":"standard_library/#tclonevalue","text":"Same as @clone but uses the temporary allocator.","title":"@tclone(&amp;value)"},{"location":"standard_library/#stdcorememarray","text":"","title":"std::core::mem::array"},{"location":"standard_library/#alloctype-usz-elements","text":"Allocate a slice with elements number of elements, returning a subarray of the given length. Elements are not initialized. array::talloc variant uses the temporary allocator. int[] ints = array::alloc(int, 100);","title":"alloc($Type, usz elements)"},{"location":"standard_library/#maketype-usz-elements","text":"Like array::alloc but all elements are cleared. tmake variant uses the temporary allocator.","title":"make($Type, usz elements)"},{"location":"standard_library/#stdcoretypes","text":"","title":"std::core::types"},{"location":"standard_library/#bool-is_comparabletype","text":"Return true if the type can be used with comparison operators.","title":"bool is_comparable($Type)"},{"location":"standard_library/#bool-is_equatable_valuevalue","text":"Return true if the value can be compared using the equals macro.","title":"bool is_equatable_value(value)"},{"location":"standard_library/#bool-is_equatable_valuevalue_1","text":"Return true if the value can be compared using the comparison macros.","title":"bool is_equatable_value(value)"},{"location":"standard_library/#kind_is_inttypekind-kind","text":"","title":"kind_is_int(TypeKind kind)"},{"location":"standard_library/#variant_to_intvariant-v-type","text":"Returns an optional value of $Type if the variant value losslessly may be converted into the given type. Returns a ConversionResult otherwise. variant v = &&128; short y = variant_to_int(v, short)!!; // Works ichar z = variant_to_int(v, ichar)!!; // Panics VALUE_OUT_OF_RANGE","title":"variant_to_int(variant v, $Type)"},{"location":"standard_library/#stdcorestringconv","text":"","title":"std::core::string::conv"},{"location":"standard_library/#usz-char32_to_utf8char32-c-char-output-usz-available","text":"Convert a UTF32 codepoint to an UTF8 buffer. size has the number of writable bytes left. It returns the number of bytes used, or UnicodeResult.CONVERSION_FAILED if the buffer is too small.","title":"usz! char32_to_utf8(Char32 c, char* output, usz available)"},{"location":"standard_library/#void-char32_to_utf16_unsafechar32-c-char16-output","text":"Convert a UTF32 codepoint to an UTF16 buffer without bounds checking, moving the output pointer 1 or 2 steps.","title":"void char32_to_utf16_unsafe(Char32 c, Char16** output)"},{"location":"standard_library/#stdio","text":"","title":"std::io"},{"location":"standard_library/#usz-printfstring-format-args-maydiscard","text":"Regular printf functionality: %s , %x , %d , %f and %p are supported. Will also print enums and vectors.","title":"usz! printf(String format, args...) @maydiscard"},{"location":"standard_library/#usz-varstringprintfvarstring-str-string-format-args-maydiscard","text":"Same as printf but on varstrings.","title":"usz! VarString.printf(VarString* str, String format, args...) @maydiscard"},{"location":"standard_library/#usz-fileprintffile-file-string-format-args-maydiscard","text":"Same as printf but on files.","title":"usz! File.printf(File file, String format, args...) @maydiscard"},{"location":"standard_library/#void-fileopenfile-file-string-filename-string-mode","text":"Open a file with the given file name with the given mode (r, w etc)","title":"void! File.open(File* file, String filename, String mode)"},{"location":"standard_library/#void-fileseekfile-file-long-offset-seek-seekmode-seekset","text":"Seek in a file. Based on the libc function.","title":"void! File.seek(File *file, long offset, Seek seekMode = Seek.SET)"},{"location":"standard_library/#void-fileclosefile-file-inline","text":"Close a file, based on the libc function.","title":"void! File.close(File *file) @inline"},{"location":"standard_library/#bool-fileeoffile-file-inline","text":"True if EOF has been reached. Based on the libc function.","title":"bool File.eof(File* file) @inline"},{"location":"standard_library/#void-fileputcfile-file-char-c","text":"Write a single byte to a file. See the libc function.","title":"void! File.putc(File *file, char c)"},{"location":"standard_library/#usz-filereadfile-file-void-buffer-usz-items-usz-element_size-1","text":"Read into a buffer, based on the libc function.","title":"usz File.read(File file, void buffer, usz items, usz element_size = 1)"},{"location":"standard_library/#usz-filewritefile-file-void-buffer-usz-items-usz-element_size-1","text":"Write to a buffer, based on the libc function.","title":"usz File.write(File file, void buffer, usz items, usz element_size = 1)"},{"location":"standard_library/#stdout-stdin-stderr","text":"Return stdout, stdin and stderr respectively.","title":"stdout(), stdin(), stderr()"},{"location":"standard_library/#stdcollectionslist","text":"Generic list module, elements are of Type . import std::collections::list; define MyIntList = List<int>; ... MyIntList list; list.push(123); list.free();","title":"std::collections::list"},{"location":"standard_library/#listpushlist-list-type-element-append","text":"Append a single value to the list.","title":"List.push(List *list, Type element), append(...)"},{"location":"standard_library/#type-listpoplist-list","text":"Removes and returns the last entry in the list.","title":"Type List.pop(List* list)"},{"location":"standard_library/#type-listpop_firstlist-list","text":"Removes the first entry in the list.","title":"Type List.pop_first(List *list)"},{"location":"standard_library/#void-listremove_atlist-list-usz-index","text":"Removes the entry at index .","title":"void List.remove_at(List *list, usz index)"},{"location":"standard_library/#void-listinsert_atlist-list-usz-index-type-type","text":"Inserts a value at index .","title":"void List.insert_at(List *list, usz index, Type type)"},{"location":"standard_library/#void-listpush_frontlist-list-type-type","text":"Inserts a value to the front of the list.","title":"void List.push_front(List *list, Type type)"},{"location":"standard_library/#void-listremove_lastlist-list","text":"Remove the last value of the list.","title":"void List.remove_last(List* list)"},{"location":"standard_library/#void-listremove_firstlist-list","text":"Remove the first element in the list.","title":"void List.remove_first(List *list)"},{"location":"standard_library/#type-listfirstlist-list","text":"Return the first element in the list if available.","title":"Type List.first(List list)"},{"location":"standard_library/#type-listlastlist-list","text":"Return the last element in the list if available.","title":"Type List.last(List list)"},{"location":"standard_library/#listis_emptylist-list","text":"Return true if the list is empty.","title":"List.is_empty(List *list)"},{"location":"standard_library/#usz-listlenlist-list","text":"Return the number of elements in the list.","title":"usz List.len(List *list)"},{"location":"standard_library/#type-listgetlist-list-usz-index","text":"Return the value at index .","title":"Type List.get(List *list, usz index)"},{"location":"standard_library/#void-listfreelist-list","text":"Free all memory associated with this list.","title":"void List.free(List *list)"},{"location":"standard_library/#void-listswaplist-list-usz-i-usz-j","text":"Swap two elements in the list.","title":"void List.swap(List *list, usz i, usz j)"},{"location":"statements/","text":"Statements Statements largely work like in C, but with some additions. Expression blocks Expression blocks (delimited using {| |} ) are compound statements that opens their own function scope. Jumps cannot be done into or out of a function block, and return exits the block, rather than the function as a whole. The function below prints World! fn void test() { int a = 0; {| if (a) return; io::printf(\"Hello \"); return; |}; io::printf(\"World!\\n\"); } Expression blocks may also return values: fn void test(int x) { int a = {| if (x > 0) return x * 2; if (x == 0) return 100; return -x; |}; io::printfn(\"The result was %d\", a); } Labelled break and continue Labelled break and continue lets you break out of an outer scope. Labels can be put on if , switch , while and do statements. fn void test(int i) { if FOO: (i > 0) { while (1) { io::printfn(\"%d\", i); // Break out of the top if statement. if (i++ > 10) break FOO; } } } Do-without-while Do-while statements can skip the ending while . In that case it acts as if the while was while(0) : do { io::println(\"FOO\"); } while (0); // Equivalent to the above. do { io::println(\"FOO\"); }; Nextcase and labelled nextcase The nextcase statement is used in switch and if-catch to jump to the next statement: switch (i) { case 1: doSomething(); nextcase; // Jumps to case 2 case 2: doSomethingElse(); } It's also possible to use nextcase with an expression, to jump to an arbitrary case: switch (i) { case 1: doSomething(); nextcase 3; // Jump to case 3 case 2: doSomethingElse(); case 3: nextcase rand(); // Jump to random case default: io::println(\"Ended\"); } Which can be used as structured goto when creating state machines. Switch cases with runtime evaluation It's possible to use switch as an enhanced if-else chain: switch (true) { case x < 0: xless(); case x > 0: xgreater(); default: xequals(); } The above would be equivalent to writing: if (c < 0) { xless(); } else if (x > 0) { xgreater(); } else { xequals(); } Note that because of this, the first match is always picked. Consider: switch (true) { case x > 0: foo(); case x > 2: bar(); } Because of the evaluation order, only foo() will be invoked for x > 0, even when x is greater than 2. It's also possible to omit the conditional after switch . In that case it is implicitly assumed to be same as writing (true) switch { case foo() > 0: bar(); case test() == 1: baz(); }","title":"Statements"},{"location":"statements/#statements","text":"Statements largely work like in C, but with some additions.","title":"Statements"},{"location":"statements/#expression-blocks","text":"Expression blocks (delimited using {| |} ) are compound statements that opens their own function scope. Jumps cannot be done into or out of a function block, and return exits the block, rather than the function as a whole. The function below prints World! fn void test() { int a = 0; {| if (a) return; io::printf(\"Hello \"); return; |}; io::printf(\"World!\\n\"); } Expression blocks may also return values: fn void test(int x) { int a = {| if (x > 0) return x * 2; if (x == 0) return 100; return -x; |}; io::printfn(\"The result was %d\", a); }","title":"Expression blocks"},{"location":"statements/#labelled-break-and-continue","text":"Labelled break and continue lets you break out of an outer scope. Labels can be put on if , switch , while and do statements. fn void test(int i) { if FOO: (i > 0) { while (1) { io::printfn(\"%d\", i); // Break out of the top if statement. if (i++ > 10) break FOO; } } }","title":"Labelled break and continue"},{"location":"statements/#do-without-while","text":"Do-while statements can skip the ending while . In that case it acts as if the while was while(0) : do { io::println(\"FOO\"); } while (0); // Equivalent to the above. do { io::println(\"FOO\"); };","title":"Do-without-while"},{"location":"statements/#nextcase-and-labelled-nextcase","text":"The nextcase statement is used in switch and if-catch to jump to the next statement: switch (i) { case 1: doSomething(); nextcase; // Jumps to case 2 case 2: doSomethingElse(); } It's also possible to use nextcase with an expression, to jump to an arbitrary case: switch (i) { case 1: doSomething(); nextcase 3; // Jump to case 3 case 2: doSomethingElse(); case 3: nextcase rand(); // Jump to random case default: io::println(\"Ended\"); } Which can be used as structured goto when creating state machines.","title":"Nextcase and labelled nextcase"},{"location":"statements/#switch-cases-with-runtime-evaluation","text":"It's possible to use switch as an enhanced if-else chain: switch (true) { case x < 0: xless(); case x > 0: xgreater(); default: xequals(); } The above would be equivalent to writing: if (c < 0) { xless(); } else if (x > 0) { xgreater(); } else { xequals(); } Note that because of this, the first match is always picked. Consider: switch (true) { case x > 0: foo(); case x > 2: bar(); } Because of the evaluation order, only foo() will be invoked for x > 0, even when x is greater than 2. It's also possible to omit the conditional after switch . In that case it is implicitly assumed to be same as writing (true) switch { case foo() > 0: bar(); case test() == 1: baz(); }","title":"Switch cases with runtime evaluation"},{"location":"syntax/","text":"Syntax Keywords The following are reserved keywords used by C3: Note: this is out of date! * as, auto, asm, attribute, break, case, cast, catch, const, continue, default, defer, define, do, else, enum, errtype, false, for, fn, generic, if, import, local, macro, module, nextcase, nil, private, return, struct, switch, throw, throws, true, try, type, union, until, var, void, while, float, double char, bool, byte, short, ushort, int, uint, long, ulong, isz, usz, In addition to those, the following 12 are reserved but currently not used: half, quad For macros the the following 9 @ identifiers are reserved as keywords: @param, @throws, @return, @ensure, @require, @pure, @const, @reqparse, @deprecated Yacc grammar %{ #include <stdio.h> #define YYERROR_VERBOSE extern char yytext[]; extern int column; int yylex(void); void yyerror(char *s); %} %token IDENT CT_IDENT CONSTANT CONST_IDENT TYPE_IDENT STRING_LITERAL SIZEOF %token INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP %token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN %token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN %token XOR_ASSIGN OR_ASSIGN VAR NIL ELVIS HASH_IDENT NEXT %token AT %token TYPEDEF MODULE IMPORT %token CHAR SHORT INT LONG FLOAT DOUBLE CONST VOLATILE VOID %token BYTE USHORT UINT ULONG BOOL %token STRUCT UNION ENUM ELLIPSIS AS LOCAL %token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN %token TYPE FUNC ERROR MACRO GENERIC CTIF CTELIF CTENDIF CTELSE CTSWITCH CTCASE CTDEFAULT CTFOR %token THROWS THROW TRY CATCH SCOPE PUBLIC DEFER ATTRIBUTE IN %token FN_BLOCK_START FN_BLOCK_END %token MULTW ADDW SUBW %token AUTO %start translation_unit %% path : IDENT SCOPE | path IDENT SCOPE ; import_path : IDENT | import_path SCOPE IDENT ; ident_expression : CONST_IDENT | IDENT | CT_IDENT ; primary_expression : STRING_LITERAL | CONSTANT | NIL | path ident_expression | ident_expression | base_type initializer_list | base_type '.' IDENT | TYPE '(' type_expression ')' | '(' expression ')' | FN_BLOCK_START statement_list FN_BLOCK_END ; postfix_expression : primary_expression | postfix_expression '[' expression ']' | postfix_expression '(' ')' | postfix_expression '(' argument_expression_list ')' | postfix_expression '.' IDENT | postfix_expression INC_OP | postfix_expression DEC_OP ; argument_expression_list : expression | argument_expression_list ',' expression ; unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator unary_expression | SIZEOF '(' type_expression ')' ; unary_operator : '&' | '*' | '+' | '-' | SUBW | '~' | '!' | '@' ; multiplicative_expression : unary_expression | multiplicative_expression '*' unary_expression | multiplicative_expression MULTW unary_expression | multiplicative_expression '/' unary_expression | multiplicative_expression '%' unary_expression ; shift_expression : multiplicative_expression | shift_expression LEFT_OP multiplicative_expression | shift_expression RIGHT_OP multiplicative_expression ; bit_expression : shift_expression | bit_expression '&' shift_expression | bit_expression '^' shift_expression | bit_expression '|' shift_expression ; additive_expression : bit_expression | additive_expression '+' bit_expression | additive_expression ADDW bit_expression | additive_expression '-' bit_expression | additive_expression SUBW bit_expression ; relational_expression : additive_expression | relational_expression '<' additive_expression | relational_expression '>' additive_expression | relational_expression LE_OP additive_expression | relational_expression GE_OP additive_expression | relational_expression EQ_OP additive_expression | relational_expression NE_OP additive_expression ; logical_expression : relational_expression | logical_expression AND_OP relational_expression | logical_expression OR_OP relational_expression ; conditional_expression : logical_expression | logical_expression '?' expression ':' conditional_expression | logical_expression ELVIS conditional_expression ; assignment_expression : conditional_expression | unary_expression assignment_operator assignment_expression | unary_expression '=' initializer_list ; expression : assignment_expression | TRY assignment_expression | TRY assignment_expression ELSE assignment_expression ; assignment_operator : '=' | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | LEFT_ASSIGN | RIGHT_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN ; constant_expression : conditional_expression ; enumerators : enumerator | enumerators ',' enumerator ; enumerator_list : enumerators | enumerators ',' ; enumerator : CONST_IDENT | CONST_IDENT '=' constant_expression ; identifier_list : IDENT | identifier_list ',' IDENT ; macro_argument : CT_IDENT | IDENT | type_expression IDENT | type_expression CT_IDENT ; macro_argument_list : macro_argument | macro_argument_list ',' macro_argument ; declaration : type_expression IDENT '=' initializer | type_expression IDENT ; param_declaration : type_expression | type_expression IDENT | type_expression IDENT '=' initializer ; parameter_type_list : parameter_list | parameter_list ',' ELLIPSIS | parameter_list ',' type_expression ELLIPSIS ; opt_parameter_type_list : '(' ')' | '(' parameter_type_list ')' ; parameter_list : param_declaration | parameter_list ',' param_declaration ; base_type : VOID | AUTO | BOOL | CHAR | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | FLOAT | DOUBLE | TYPE_IDENT | path TYPE_IDENT | TYPE '(' constant_expression ')' ; type_expression : base_type | type_expression '*' | type_expression '[' constant_expression ']' | type_expression '[' ']' | type_expression '[' '+' ']' ; initializer : expression | initializer_list ; initializer_values : initializer | initializer_values ',' initializer ; initializer_list : '{' initializer_values '}' | '{' initializer_values ',' '}' ; ct_case_statement : CTCASE type_list ':' statement | CTDEFAULT ':' statement ; ct_elif_body : ct_elif compound_statement | ct_elif_body ct_elif compound_statement ; ct_else_body : ct_elif_body | CTELSE compound_statement | ct_elif_body CTELSE compound_statement ; ct_switch_body : ct_case_statement | ct_switch_body ct_case_statement ; ct_for_stmt : CTFOR '(' CT_IDENT IN expression ')' statement | CTFOR '(' CT_IDENT ',' CT_IDENT IN expression ')' statement ; ct_statement : ct_if compound_statement | ct_if compound_statement ct_else_body | ct_switch '{' ct_switch_body '}' | ct_for_stmt ; throw_statement : THROW expression ';' statement : compound_statement | labeled_statement | expression_statement | selection_statement | iteration_statement | jump_statement | declaration_statement | volatile_statement | catch_statement | try_statement | defer_statement | ct_statement | throw_statement ; defer_catch_body : compound_statement | expression_statement | jump_statement | iteration_statement | selection_statement ; defer_statement : DEFER defer_catch_body | DEFER catch_statement ; catch_statement : CATCH '(' type_expression IDENT ')' defer_catch_body | CATCH '(' ERROR IDENT ')' defer_catch_body ; try_statement : TRY selection_statement | TRY iteration_statement | TRY jump_statement ; volatile_statement : VOLATILE compound_statement ; label_statement : IDENT ':' statement labeled_statement : label_statement | CASE constant_expression ':' | DEFAULT ':' ; compound_statement : '{' '}' | '{' statement_list '}' ; statement_list : statement | statement_list statement ; declaration_statement : declaration ';' ; expression_statement : ';' | expression ';' ; control_expression : decl_expr_list | decl_expr_list ';' decl_expr_list ; selection_statement : IF '(' control_expression ')' statement | IF '(' control_expression ')' compound_statement ELSE statement | SWITCH '(' control_expression ')' compound_statement ; expression_list : expression | expression_list ',' expression ; decl_expr_list : expression | declaration | decl_expr_list ',' expression | decl_expr_list ',' declaration ; for_statement : FOR '(' decl_expr_list ';' expression_statement ')' statement | FOR '(' decl_expr_list ';' expression_statement expression_list ')' statement ; iteration_statement : WHILE '(' control_expression ')' statement | DO statement WHILE '(' expression ')' ';' | for_statement ; jump_statement : GOTO CONSTANT ';' | CONTINUE ';' | BREAK ';' | RETURN ';' | RETURN expression ';' ; path_ident : IDENT | path IDENT ; attribute : AT path_ident | AT path_ident '(' constant_expression ')' ; attribute_list : attribute | attribute_list attribute ; opt_attributes : attribute_list | ; error_type : path TYPE_IDENT | TYPE_IDENT | ERROR '(' expression ')' ; error_list : error_type | error_list error_type ; throw_declaration : THROWS | THROWS error_list ; opt_throw_declaration : throw_declaration | ; func_name : path TYPE_IDENT '.' IDENT | TYPE_IDENT '.' IDENT | IDENT ; func_declaration : FUNC type_expression func_name opt_parameter_type_list opt_attributes opt_throw_declaration ; func_definition : func_declaration compound_statement | func_declaration ';' ; macro_declaration : MACRO type_expression IDENT '(' macro_argument_list ')' compound_statement : MACRO IDENT '(' macro_argument_list ')' compound_statement ; struct_or_union : STRUCT | UNION ; struct_declaration : struct_or_union TYPE_IDENT opt_attributes struct_body ; struct_body : '{' struct_declaration_list '}' ; struct_declaration_list : struct_member_declaration | struct_declaration_list struct_member_declaration ; struct_member_declaration : type_expression identifier_list opt_attributes ';' | struct_or_union IDENT opt_attributes struct_body | struct_or_union opt_attributes struct_body ; enum_declaration : ENUM TYPE_IDENT ':' type_expression opt_attributes '{' enumerator_list '}' | ENUM TYPE_IDENT opt_attributes '{' enumerator_list '}' ; errors : CONST_IDENT | errors ',' CONST_IDENT ; error_list : errors | errors ',' ; error_declaration : ERROR TYPE_IDENT '{' error_list '}' ; type_list : type_expression | type_list ',' type_expression ; generics_case : CASE type_list ':' statement generics_body : generics_case | generics_body generics_case ; generics_declaration : GENERIC IDENT '(' macro_argument_list ')' '{' generics_body '}' | GENERIC type_expression IDENT '(' macro_argument_list ')' '{' generics_body '}' ; const_declaration : CONST CT_IDENT '=' initializer ';' | CONST type_expression IDENT '=' initializer ';' ; func_typedef : FUNC type_expression opt_parameter_type_list opt_throw_declaration ; typedef_declaration : TYPEDEF type_expression AS TYPE_IDENT ';' | TYPEDEF func_typedef AS TYPE_IDENT ';' ; attribute_domain : FUNC | VAR | ENUM | STRUCT | UNION | TYPEDEF | CONST | ERROR ; attribute_domains : attribute_domain | attribute_domains ',' attribute_domain ; attribute_declaration : ATTRIBUTE attribute_domains IDENT ';' | ATTRIBUTE attribute_domains IDENT '(' parameter_type_list ')' ';' ; global_declaration : type_expression IDENT ';' | type_expression IDENT '=' initializer ';' ; ct_if : CTIF '(' expression ')' ; ct_elif : CTELIF '(' expression ')' ; ct_switch : CTSWITCH '(' expression ')' ; top_level_block : '{' top_level_statements '}' ; tl_ct_elif_body : ct_elif top_level_block | tl_ct_elif_body ct_elif top_level_block ; tl_ct_else_body : tl_ct_elif_body | tl_ct_else_body CTELSE top_level_block ; tl_ct_case : CTCASE type_list ':' top_level_statements | CTDEFAULT ':' top_level_statements ; tl_ct_switch_body : tl_ct_case | tl_ct_switch_body tl_ct_case ; conditional_compilation : ct_if top_level_block | ct_if top_level_block tl_ct_else_body | ct_switch '{' tl_ct_switch_body '}' ; module_param : CT_IDENT | HASH_IDENT | TYPE_IDENT | IDENT ; module_params : module_param | module_params ',' module_param ; module : MODULE import_path ';' | MODULE import_path '(' module_params ')' ';' ; specified_import : IDENT AS IDENT | IDENT | TYPE | CONST | MACRO | TYPE AS TYPE | CONST AS CONST | MACRO AS MACRO ; specified_import_list : specified_import | specified_import_list ',' specified_import ; import_decl : IMPORT import_path ';' | IMPORT import_path ':' specified_import_list ';' ; imports : import_decl | imports import_decl ; translation_unit : module imports top_level_statements ; top_level_statements : visibility top_level | top_level_statements visibility top_level ; visibility : LOCAL | PUBLIC | LOCAL PUBLIC | PUBLIC LOCAL | ; top_level : func_definition | conditional_compilation | struct_declaration | attribute_declaration | enum_declaration | error_declaration | const_declaration | global_declaration | macro_declaration | generics_declaration | typedef_declaration ; %% void yyerror(char *s) { fflush(stdout); printf(\"\\n%*s\\n%*s\\n\", column, \"^\", column, s); } int main(int argc, char *argv[]) { yyparse(); return(0); }","title":"Grammar"},{"location":"syntax/#syntax","text":"","title":"Syntax"},{"location":"syntax/#keywords","text":"The following are reserved keywords used by C3: Note: this is out of date! * as, auto, asm, attribute, break, case, cast, catch, const, continue, default, defer, define, do, else, enum, errtype, false, for, fn, generic, if, import, local, macro, module, nextcase, nil, private, return, struct, switch, throw, throws, true, try, type, union, until, var, void, while, float, double char, bool, byte, short, ushort, int, uint, long, ulong, isz, usz, In addition to those, the following 12 are reserved but currently not used: half, quad For macros the the following 9 @ identifiers are reserved as keywords: @param, @throws, @return, @ensure, @require, @pure, @const, @reqparse, @deprecated","title":"Keywords"},{"location":"syntax/#yacc-grammar","text":"%{ #include <stdio.h> #define YYERROR_VERBOSE extern char yytext[]; extern int column; int yylex(void); void yyerror(char *s); %} %token IDENT CT_IDENT CONSTANT CONST_IDENT TYPE_IDENT STRING_LITERAL SIZEOF %token INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP %token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN %token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN %token XOR_ASSIGN OR_ASSIGN VAR NIL ELVIS HASH_IDENT NEXT %token AT %token TYPEDEF MODULE IMPORT %token CHAR SHORT INT LONG FLOAT DOUBLE CONST VOLATILE VOID %token BYTE USHORT UINT ULONG BOOL %token STRUCT UNION ENUM ELLIPSIS AS LOCAL %token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN %token TYPE FUNC ERROR MACRO GENERIC CTIF CTELIF CTENDIF CTELSE CTSWITCH CTCASE CTDEFAULT CTFOR %token THROWS THROW TRY CATCH SCOPE PUBLIC DEFER ATTRIBUTE IN %token FN_BLOCK_START FN_BLOCK_END %token MULTW ADDW SUBW %token AUTO %start translation_unit %% path : IDENT SCOPE | path IDENT SCOPE ; import_path : IDENT | import_path SCOPE IDENT ; ident_expression : CONST_IDENT | IDENT | CT_IDENT ; primary_expression : STRING_LITERAL | CONSTANT | NIL | path ident_expression | ident_expression | base_type initializer_list | base_type '.' IDENT | TYPE '(' type_expression ')' | '(' expression ')' | FN_BLOCK_START statement_list FN_BLOCK_END ; postfix_expression : primary_expression | postfix_expression '[' expression ']' | postfix_expression '(' ')' | postfix_expression '(' argument_expression_list ')' | postfix_expression '.' IDENT | postfix_expression INC_OP | postfix_expression DEC_OP ; argument_expression_list : expression | argument_expression_list ',' expression ; unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator unary_expression | SIZEOF '(' type_expression ')' ; unary_operator : '&' | '*' | '+' | '-' | SUBW | '~' | '!' | '@' ; multiplicative_expression : unary_expression | multiplicative_expression '*' unary_expression | multiplicative_expression MULTW unary_expression | multiplicative_expression '/' unary_expression | multiplicative_expression '%' unary_expression ; shift_expression : multiplicative_expression | shift_expression LEFT_OP multiplicative_expression | shift_expression RIGHT_OP multiplicative_expression ; bit_expression : shift_expression | bit_expression '&' shift_expression | bit_expression '^' shift_expression | bit_expression '|' shift_expression ; additive_expression : bit_expression | additive_expression '+' bit_expression | additive_expression ADDW bit_expression | additive_expression '-' bit_expression | additive_expression SUBW bit_expression ; relational_expression : additive_expression | relational_expression '<' additive_expression | relational_expression '>' additive_expression | relational_expression LE_OP additive_expression | relational_expression GE_OP additive_expression | relational_expression EQ_OP additive_expression | relational_expression NE_OP additive_expression ; logical_expression : relational_expression | logical_expression AND_OP relational_expression | logical_expression OR_OP relational_expression ; conditional_expression : logical_expression | logical_expression '?' expression ':' conditional_expression | logical_expression ELVIS conditional_expression ; assignment_expression : conditional_expression | unary_expression assignment_operator assignment_expression | unary_expression '=' initializer_list ; expression : assignment_expression | TRY assignment_expression | TRY assignment_expression ELSE assignment_expression ; assignment_operator : '=' | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | LEFT_ASSIGN | RIGHT_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN ; constant_expression : conditional_expression ; enumerators : enumerator | enumerators ',' enumerator ; enumerator_list : enumerators | enumerators ',' ; enumerator : CONST_IDENT | CONST_IDENT '=' constant_expression ; identifier_list : IDENT | identifier_list ',' IDENT ; macro_argument : CT_IDENT | IDENT | type_expression IDENT | type_expression CT_IDENT ; macro_argument_list : macro_argument | macro_argument_list ',' macro_argument ; declaration : type_expression IDENT '=' initializer | type_expression IDENT ; param_declaration : type_expression | type_expression IDENT | type_expression IDENT '=' initializer ; parameter_type_list : parameter_list | parameter_list ',' ELLIPSIS | parameter_list ',' type_expression ELLIPSIS ; opt_parameter_type_list : '(' ')' | '(' parameter_type_list ')' ; parameter_list : param_declaration | parameter_list ',' param_declaration ; base_type : VOID | AUTO | BOOL | CHAR | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG | FLOAT | DOUBLE | TYPE_IDENT | path TYPE_IDENT | TYPE '(' constant_expression ')' ; type_expression : base_type | type_expression '*' | type_expression '[' constant_expression ']' | type_expression '[' ']' | type_expression '[' '+' ']' ; initializer : expression | initializer_list ; initializer_values : initializer | initializer_values ',' initializer ; initializer_list : '{' initializer_values '}' | '{' initializer_values ',' '}' ; ct_case_statement : CTCASE type_list ':' statement | CTDEFAULT ':' statement ; ct_elif_body : ct_elif compound_statement | ct_elif_body ct_elif compound_statement ; ct_else_body : ct_elif_body | CTELSE compound_statement | ct_elif_body CTELSE compound_statement ; ct_switch_body : ct_case_statement | ct_switch_body ct_case_statement ; ct_for_stmt : CTFOR '(' CT_IDENT IN expression ')' statement | CTFOR '(' CT_IDENT ',' CT_IDENT IN expression ')' statement ; ct_statement : ct_if compound_statement | ct_if compound_statement ct_else_body | ct_switch '{' ct_switch_body '}' | ct_for_stmt ; throw_statement : THROW expression ';' statement : compound_statement | labeled_statement | expression_statement | selection_statement | iteration_statement | jump_statement | declaration_statement | volatile_statement | catch_statement | try_statement | defer_statement | ct_statement | throw_statement ; defer_catch_body : compound_statement | expression_statement | jump_statement | iteration_statement | selection_statement ; defer_statement : DEFER defer_catch_body | DEFER catch_statement ; catch_statement : CATCH '(' type_expression IDENT ')' defer_catch_body | CATCH '(' ERROR IDENT ')' defer_catch_body ; try_statement : TRY selection_statement | TRY iteration_statement | TRY jump_statement ; volatile_statement : VOLATILE compound_statement ; label_statement : IDENT ':' statement labeled_statement : label_statement | CASE constant_expression ':' | DEFAULT ':' ; compound_statement : '{' '}' | '{' statement_list '}' ; statement_list : statement | statement_list statement ; declaration_statement : declaration ';' ; expression_statement : ';' | expression ';' ; control_expression : decl_expr_list | decl_expr_list ';' decl_expr_list ; selection_statement : IF '(' control_expression ')' statement | IF '(' control_expression ')' compound_statement ELSE statement | SWITCH '(' control_expression ')' compound_statement ; expression_list : expression | expression_list ',' expression ; decl_expr_list : expression | declaration | decl_expr_list ',' expression | decl_expr_list ',' declaration ; for_statement : FOR '(' decl_expr_list ';' expression_statement ')' statement | FOR '(' decl_expr_list ';' expression_statement expression_list ')' statement ; iteration_statement : WHILE '(' control_expression ')' statement | DO statement WHILE '(' expression ')' ';' | for_statement ; jump_statement : GOTO CONSTANT ';' | CONTINUE ';' | BREAK ';' | RETURN ';' | RETURN expression ';' ; path_ident : IDENT | path IDENT ; attribute : AT path_ident | AT path_ident '(' constant_expression ')' ; attribute_list : attribute | attribute_list attribute ; opt_attributes : attribute_list | ; error_type : path TYPE_IDENT | TYPE_IDENT | ERROR '(' expression ')' ; error_list : error_type | error_list error_type ; throw_declaration : THROWS | THROWS error_list ; opt_throw_declaration : throw_declaration | ; func_name : path TYPE_IDENT '.' IDENT | TYPE_IDENT '.' IDENT | IDENT ; func_declaration : FUNC type_expression func_name opt_parameter_type_list opt_attributes opt_throw_declaration ; func_definition : func_declaration compound_statement | func_declaration ';' ; macro_declaration : MACRO type_expression IDENT '(' macro_argument_list ')' compound_statement : MACRO IDENT '(' macro_argument_list ')' compound_statement ; struct_or_union : STRUCT | UNION ; struct_declaration : struct_or_union TYPE_IDENT opt_attributes struct_body ; struct_body : '{' struct_declaration_list '}' ; struct_declaration_list : struct_member_declaration | struct_declaration_list struct_member_declaration ; struct_member_declaration : type_expression identifier_list opt_attributes ';' | struct_or_union IDENT opt_attributes struct_body | struct_or_union opt_attributes struct_body ; enum_declaration : ENUM TYPE_IDENT ':' type_expression opt_attributes '{' enumerator_list '}' | ENUM TYPE_IDENT opt_attributes '{' enumerator_list '}' ; errors : CONST_IDENT | errors ',' CONST_IDENT ; error_list : errors | errors ',' ; error_declaration : ERROR TYPE_IDENT '{' error_list '}' ; type_list : type_expression | type_list ',' type_expression ; generics_case : CASE type_list ':' statement generics_body : generics_case | generics_body generics_case ; generics_declaration : GENERIC IDENT '(' macro_argument_list ')' '{' generics_body '}' | GENERIC type_expression IDENT '(' macro_argument_list ')' '{' generics_body '}' ; const_declaration : CONST CT_IDENT '=' initializer ';' | CONST type_expression IDENT '=' initializer ';' ; func_typedef : FUNC type_expression opt_parameter_type_list opt_throw_declaration ; typedef_declaration : TYPEDEF type_expression AS TYPE_IDENT ';' | TYPEDEF func_typedef AS TYPE_IDENT ';' ; attribute_domain : FUNC | VAR | ENUM | STRUCT | UNION | TYPEDEF | CONST | ERROR ; attribute_domains : attribute_domain | attribute_domains ',' attribute_domain ; attribute_declaration : ATTRIBUTE attribute_domains IDENT ';' | ATTRIBUTE attribute_domains IDENT '(' parameter_type_list ')' ';' ; global_declaration : type_expression IDENT ';' | type_expression IDENT '=' initializer ';' ; ct_if : CTIF '(' expression ')' ; ct_elif : CTELIF '(' expression ')' ; ct_switch : CTSWITCH '(' expression ')' ; top_level_block : '{' top_level_statements '}' ; tl_ct_elif_body : ct_elif top_level_block | tl_ct_elif_body ct_elif top_level_block ; tl_ct_else_body : tl_ct_elif_body | tl_ct_else_body CTELSE top_level_block ; tl_ct_case : CTCASE type_list ':' top_level_statements | CTDEFAULT ':' top_level_statements ; tl_ct_switch_body : tl_ct_case | tl_ct_switch_body tl_ct_case ; conditional_compilation : ct_if top_level_block | ct_if top_level_block tl_ct_else_body | ct_switch '{' tl_ct_switch_body '}' ; module_param : CT_IDENT | HASH_IDENT | TYPE_IDENT | IDENT ; module_params : module_param | module_params ',' module_param ; module : MODULE import_path ';' | MODULE import_path '(' module_params ')' ';' ; specified_import : IDENT AS IDENT | IDENT | TYPE | CONST | MACRO | TYPE AS TYPE | CONST AS CONST | MACRO AS MACRO ; specified_import_list : specified_import | specified_import_list ',' specified_import ; import_decl : IMPORT import_path ';' | IMPORT import_path ':' specified_import_list ';' ; imports : import_decl | imports import_decl ; translation_unit : module imports top_level_statements ; top_level_statements : visibility top_level | top_level_statements visibility top_level ; visibility : LOCAL | PUBLIC | LOCAL PUBLIC | PUBLIC LOCAL | ; top_level : func_definition | conditional_compilation | struct_declaration | attribute_declaration | enum_declaration | error_declaration | const_declaration | global_declaration | macro_declaration | generics_declaration | typedef_declaration ; %% void yyerror(char *s) { fflush(stdout); printf(\"\\n%*s\\n%*s\\n\", column, \"^\", column, s); } int main(int argc, char *argv[]) { yyparse(); return(0); }","title":"Yacc grammar"},{"location":"types/","text":"Types As usual, types are divided into basic types and user defined types (enum, union, struct, faults, aliases). All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module. Naming All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. This naming requirement ensures that the language is easy to parse for tools. It is possible to use attributes to change the external name of a type: struct Stat @extname(\"stat\") { // ... } fn CInt stat(const char* pathname, Stat* buf); This would for example affect generated C headers. Differences from C Unlike C, C3 does not use type qualifiers. const exists, but is a storage class modifier, not a type qualifier. Instead of volatile , volatile loads and stores are used. In order to signal restrictions on parameter usage, parameter preconditions are used. Instead of typedef , C3 uses a more general define construct, which also supports distinct types. C3 also requires all function pointers to be used with an alias, so: define Callback = fn void(); Callback a = null; // Ok! fn Callback getCallback() { ... } // Ok! // fn fn void() getCallback() { ... } - ERROR! // fn void() a = null; - ERROR!``` Basic types Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned. Integer types Name bit size signed bool* 1 no ichar 8 yes char 8 no short 16 yes ushort 16 no int 32 yes uint 32 no long 64 yes ulong 64 no iptr** varies yes uptr** varies no isz** varies yes usz** varies no * bool will be stored as a byte. ** size, pointer and pointer sized types depend on platform. Integer arithmetics All signed integer arithmetics uses 2's complement. Integer constants Integer constants are 1293832 or -918212. Without a suffix, suffix type is assumed to the signed integer of arithmetic promotion width . Adding the u suffix gives a unsigned integer of the same width. Use ixx and uxx \u2013 where xx is the bitwidth for typed integers, e.g. 1234u16 Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100 TwoCC, FourCC and EightCC FourCC codes are often used to identify binary format types. C3 adds direct support for 4 character codes, but also 2 and 8 characters: 2 character strings, e.g. 'C3' , would convert to an ushort or short. 4 character strings, e.g. 'TEST' , converts to an uint or int. 8 character strings, e.g. 'FOOBAR11' converts to an ulong or long. Conversion is always done so that the character string has the correct ordering in memory. This means that the same characters may have different integer values on different architectures due to endianess. Base64 and hex data literals Base64 encoded values work like TwoCC/FourCC/EightCC, in that is it laid out in byte order in memory. It uses the format b64'<base64>' . Hex encoded values work as base64 but with the format x'<hex>' . In data literals any whitespace is ignored, so '00 00 11'x encodes to the same value as x'000011' . In our case we could encode b64'Rk9PQkFSMTE=' as 'FOOBAR11' . Base64 and hex data literals initializes to arrays of the char type: char[*] hello_world_base64 = b64\"SGVsbG8gV29ybGQh\"; char[*] hello_world_hex = x\"4865 6c6c 6f20 776f 726c 6421\"; String literals, and raw strings Regular string literals is text enclosed in \" ... \" just like in C. C3 also offers two other types of literals: multi-line strings and raw strings . Raw strings uses text between ` `. Inside of a raw string, no escapes are available. To write a ` double the character: char* foo = `C:\\foo\\bar.dll`; char* bar = `\"Say ``hello``\"`; // Same as char* foo = \"C:\\\\foo\\\\bar.dll\"; char* bar = \"\\\"Say `hello`\\\"\"; Floating point types Name bit size float16* 16 float 32 double 64 float128* 128 *support depends on platform Floating point constants Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediately before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10 It is possible to type a floating point by adding a suffix: Suffix type f16 float16 f32 or f float f64 double f128 float128 C compatibility For C compatibility the following types are also defined in std::core::cinterop Name c type CChar char CShort short int CUShort unsigned short int CInt int CUInt unsigned int CLong long int CULong unsigned long int CLongLong long long CULongLong unsigned long long CFloat float CDouble double CLongDouble long double Note that signed C char and unsigned char will correspond to ichar and char . CChar is only available to match the default signedness of char on the platform. Other built-in types Pointer types Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo. The typeid type The typeid can hold a runtime identifier for a type. Using <typename>.typeid a type may be converted to its unique runtime id, e.g. typeid a = Foo.typeid; . This value is pointer-sized. The variant type C3 contains a built-in variant type, which is essentially struct containing a typeid plus a void* pointer to a value. It is possible to cast the variant type to any pointer type, which will return null if the types don't match, or the pointer value otherwise. int x; variant y = &x; double *z = (double*)y; // Returns null int* w = (int*)x; // Returns the pointer to x Switching over the variant type is another method to unwrap the pointer inside: fn void test(variant z) { // Unwrapping switch switch (z) { case int: // z is unwrapped to int* here case double: // z is unwrapped to double* here } // Assignment switch switch (y = z) { case int: // y is int* here } // Direct unwrapping to a value is also possible: switch (w = *z) { case int: // w is int here } } variant.type returns the underlying pointee typeid of the contained value. variant.ptr returns the raw void* pointer. Array types Arrays are indicated by [size] after the type, e.g. int[4] . Subarrays use the type[] . For initialization the wildcard type[*] can be used to infer the size from the initializer. See the chapter on arrays . Vector types Vectors use [<size>] after the type, e.g. float[<3>] , with the restriction that vectors may only form out of integers, floats and booleans. Similar to arrays, wildcard can be used to infer the size of a vector: int[<*>] a = { 1, 2 } . Note: C3 will support scaled vectors using the syntax float[<>] , but this is currently not implemented. Types created using defined \"typedef\" Like in C, C3 has a \"typedef\" construct, define <typename> = <type> define Int32 = int; define Vector2 = float[<2>]; ... Int32 a = 1; int b = a; Function pointer types Function pointers are always used through a define : define Callback = fn void(int value); Callback callback = &test; fn void test(int a) { ... } To form a function pointer, write a normal function declaration but skipping the function name. fn int foo(double x) -> fn int(double x) . Function pointers can have default arguments, e.g. define Callback = fn void(int value = 0) but default arguments and parameter names are not taken into account when determining function pointer assignability: define Callback = fn void(int value = 1); fn void test(int a = 0) { ... } Callback callback = &main; // Ok fn void main() { callback(); // Works, same as test(0); test(); // Works, same as test(1); callback(.value = 3); // Works, same as test(3) test(.a = 4); // Works, same as test(4) // callback(.a = 3); ERROR! } Distinct types Distinct types is a kind of typedef which creates a new type that has the same properties as the original type but is - as the name suggests - distinct from it. It cannot implicitly convert into the other type. A distinct type is created by adding distinct before the type name in a \"define\": define <typename> = distinct <type> define MyId = distinct int; fn void* get_by_id(MyId id) { ... } fn void test(MyId id) { void* val = get_by_id(id); // Ok void* val2 = get_by_id(1); // Literals convert implicitly int a = 1; // void* val3 = get_by_id(a); // ERROR expected a MyId void* val4 = get_by_id((MyId)a); // Works // a = id; // ERROR can't assign 'MyId' to 'int' } Generic types Similar to function pointers, generic types are only available using define : import generic_list; // Contains the generic MyList struct Foo { int x; } define IntMyList = generic_list::MyList<int>; define FooMyList = generic_list::MyList<Foo>; Read more about generic types on the page about generics . Enum Enum (enumerated) types use the following syntax: enum State : int { PENDING, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING . Enum type inference When an enum is used in where the type can be inferred, like in case-clauses or in variable assignment, it is allowed to drop the enum name: State foo = PENDING; // State.PENDING is inferred. switch (foo) { case RUNNING: // State.RUNNING is inferred ... default: ... } fn void test(State s) { ... } ... test(RUNNING); // State.RUNNING is inferred In the case that it collides with a global in the same scope, it needs the qualifier: module test; fn void testState(State s) { ... } const State RUNNING = State.TERMINATED; // Don't do this! ... test(RUNNING); // Ambiguous test(test::RUNNING); // Uses global. test(State.RUNNING); // Uses enum constant. Enum associated values It is possible to associate each enum value with a static value. enum State : int (String state_desc, bool active) { PENDING(\"pending start\", false), RUNNING(\"running\", true), TERMINATED(\"ended\", false) } ... State s = get_state(); io::printfn(\"Currently the process is %s\", s.state_desc); if (s.active) do_something(); Faults fault defines a set of optional result values, that are similar to enums, but are used for optional returns. fault IOResult { IO_ERROR, PARSE_ERROR } fault MapResult { NOT_FOUND } Like the typeid, the constants are pointer sized and each value is globally unique, even when compared to other faults. For example the underlying value of MapResult.NOT_FOUND is guaranteed to be different from IOResult.IO_ERROR . This is true even if they are separately compiled. A fault may be stored as a normal value, but is also unique in that it may be passed as the optional result value using the ! suffix operator. Optional Result Types An optional result type is created by taking a type and appending ! . An optional result type is a tagged union containing either the expected result or an optional result value (which is a fault). int! i; i = 5; // Assigning a real value to i. i = IOResult.IO_ERROR!; // Assigning an optional result to i. Only variables and return variables may be optionals. Function and macro parameters may not be optionals. fn Foo*! getFoo() { ... } // Ok! fn void processFoo(Foo*! f) { ... } // Error int! x = 0; // Ok! Read more about the optional types on the page about error handling . Struct types Structs are always named: struct Person { char age; String name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; libc::printf(\"%s is %d years old.\", p.age, p.name); Person* pPtr = &p; pPtr.age = 20; // Ok! libc::printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person** and use dot access. \u2013 It's not allowed, only one level of dereference is done.) To change alignment and packing, optional attributes such as @packed may be used. Struct subtyping C3 allows creating struct subtypes using inline : struct ImportantPerson { inline Person person; String title; } fn void printPerson(Person p) { libc::printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied. Union types Union types are defined just like structs and are fully compatible with C. union Integral { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. libc::printf(\"%d\\n\", i.as_byte); Note that unions only take up as much space as their largest member, so Integral.sizeof is equivalent to long.sizeof . Nested sub-structs / unions Just like in C99 and later, nested anonymous sub-structs / unions are allowed. Note that the placement of struct / union names is different to match the difference in declaration. struct Person { char age; String name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } } Bitstructs Bitstructs allows storing fields in a specific bit layout. A bitstruct may only contain integer types and booleans, in most other respects it works like a struct. The main differences is that the bitstruct has a backing type and each field has a specific bit range. In addition it's not possible to take the address of a bitstruct field. bitstruct Foo : char { int a : 0..2; int b : 4..6; bool c : 7; } ... Foo f; f.a = 2; char x = (char)f; io::printfn(\"%d\", (char)f); // prints 2 f.b = 1; io::printfn(\"%d\", (char)f); // prints 18 f.c = true; io::printfn(\"%d\", (char)f); // prints 146 The bitstruct will follow the endianness of the underlying type: bitstruct Test : uint { ushort a : 0..15; ushort b : 16..31; } ... Test t; t.a = 0xABCD; t.b = 0x789A; char* c = (char*)&t; io::printfn(\"%X\", (uint)t); // Prints 789AABCD for (int i = 0; i < 4; i++) io::printf(\"%X\", c[i]); // Prints CDAB9A78 io::println(); It is however possible to pick a different endianness, in which case the entire representation will internally assume big endian layout: bitstruct Test : uint @bigendian { ushort a : 0..15; ushort b : 16..31; } In this case the same example yields CDAB9A78 and 789AABCD respectively. Bitstruct backing types may be integers or char arrays. The difference in layout is somewhat subtle: bitstruct Test1 : char[4] { ushort a : 0..15; ushort b : 16..31; } bitstruct Test2 : char[4] @bigendian { ushort a : 0..15; ushort b : 16..31; } ... Test1 t1; Test2 t2; t1.a = t2.a = 0xABCD; t1.b = t2.b = 0x789A; char* c = (char*)&t1; for (int i = 0; i < 4; i++) io::printf(\"%X\", c[i]); // Prints CDAB9A78 on x86 io::println(); c = (char*)&t2; for (int i = 0; i < 4; i++) io::printf(\"%X\", c[i]); // Prints ABCD789A io::println(); Bitstructs can be made to have ovelapping bit fields. This is useful when modelling a layout which has multiple different layouts depending on flag bits: bitstruct Foo : char @overlap { int a : 2..5; int b : 1..3; // Only valid due to the @overlap attribute }","title":"Types"},{"location":"types/#types","text":"As usual, types are divided into basic types and user defined types (enum, union, struct, faults, aliases). All types are defined on a global level. Using the public prefix is necessary for any type that is to be exposed outside of the current module.","title":"Types"},{"location":"types/#naming","text":"All user defined types in C3 starts with upper case. So MyStruct or Mystruct would be fine, mystruct_t or mystruct would not. This naming requirement ensures that the language is easy to parse for tools. It is possible to use attributes to change the external name of a type: struct Stat @extname(\"stat\") { // ... } fn CInt stat(const char* pathname, Stat* buf); This would for example affect generated C headers.","title":"Naming"},{"location":"types/#differences-from-c","text":"Unlike C, C3 does not use type qualifiers. const exists, but is a storage class modifier, not a type qualifier. Instead of volatile , volatile loads and stores are used. In order to signal restrictions on parameter usage, parameter preconditions are used. Instead of typedef , C3 uses a more general define construct, which also supports distinct types. C3 also requires all function pointers to be used with an alias, so: define Callback = fn void(); Callback a = null; // Ok! fn Callback getCallback() { ... } // Ok! // fn fn void() getCallback() { ... } - ERROR! // fn void() a = null; - ERROR!```","title":"Differences from C"},{"location":"types/#basic-types","text":"Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned.","title":"Basic types"},{"location":"types/#integer-types","text":"Name bit size signed bool* 1 no ichar 8 yes char 8 no short 16 yes ushort 16 no int 32 yes uint 32 no long 64 yes ulong 64 no iptr** varies yes uptr** varies no isz** varies yes usz** varies no * bool will be stored as a byte. ** size, pointer and pointer sized types depend on platform.","title":"Integer types"},{"location":"types/#integer-arithmetics","text":"All signed integer arithmetics uses 2's complement.","title":"Integer arithmetics"},{"location":"types/#integer-constants","text":"Integer constants are 1293832 or -918212. Without a suffix, suffix type is assumed to the signed integer of arithmetic promotion width . Adding the u suffix gives a unsigned integer of the same width. Use ixx and uxx \u2013 where xx is the bitwidth for typed integers, e.g. 1234u16 Integers may be written in decimal, but also in binary with the prefix 0b e.g. 0b0101000111011 , 0b011 in octal with the prefix 0o e.g. 0o0770 , 0o12345670 in hexadecimal with the prefix 0x e.g. 0xdeadbeef 0x7f7f7f Furthermore, underscore _ may be used to add space between digits to improve readability e.g. 0xFFFF_1234_4511_0000 , 123_000_101_100","title":"Integer constants"},{"location":"types/#twocc-fourcc-and-eightcc","text":"FourCC codes are often used to identify binary format types. C3 adds direct support for 4 character codes, but also 2 and 8 characters: 2 character strings, e.g. 'C3' , would convert to an ushort or short. 4 character strings, e.g. 'TEST' , converts to an uint or int. 8 character strings, e.g. 'FOOBAR11' converts to an ulong or long. Conversion is always done so that the character string has the correct ordering in memory. This means that the same characters may have different integer values on different architectures due to endianess.","title":"TwoCC, FourCC and EightCC"},{"location":"types/#base64-and-hex-data-literals","text":"Base64 encoded values work like TwoCC/FourCC/EightCC, in that is it laid out in byte order in memory. It uses the format b64'<base64>' . Hex encoded values work as base64 but with the format x'<hex>' . In data literals any whitespace is ignored, so '00 00 11'x encodes to the same value as x'000011' . In our case we could encode b64'Rk9PQkFSMTE=' as 'FOOBAR11' . Base64 and hex data literals initializes to arrays of the char type: char[*] hello_world_base64 = b64\"SGVsbG8gV29ybGQh\"; char[*] hello_world_hex = x\"4865 6c6c 6f20 776f 726c 6421\";","title":"Base64 and hex data literals"},{"location":"types/#string-literals-and-raw-strings","text":"Regular string literals is text enclosed in \" ... \" just like in C. C3 also offers two other types of literals: multi-line strings and raw strings . Raw strings uses text between ` `. Inside of a raw string, no escapes are available. To write a ` double the character: char* foo = `C:\\foo\\bar.dll`; char* bar = `\"Say ``hello``\"`; // Same as char* foo = \"C:\\\\foo\\\\bar.dll\"; char* bar = \"\\\"Say `hello`\\\"\";","title":"String literals, and raw strings"},{"location":"types/#floating-point-types","text":"Name bit size float16* 16 float 32 double 64 float128* 128 *support depends on platform","title":"Floating point types"},{"location":"types/#floating-point-constants","text":"Floating point constants will at least use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediately before or after a dot or an exponential. Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: -2.22e-21 -0x21.93p-10 It is possible to type a floating point by adding a suffix: Suffix type f16 float16 f32 or f float f64 double f128 float128","title":"Floating point constants"},{"location":"types/#c-compatibility","text":"For C compatibility the following types are also defined in std::core::cinterop Name c type CChar char CShort short int CUShort unsigned short int CInt int CUInt unsigned int CLong long int CULong unsigned long int CLongLong long long CULongLong unsigned long long CFloat float CDouble double CLongDouble long double Note that signed C char and unsigned char will correspond to ichar and char . CChar is only available to match the default signedness of char on the platform.","title":"C compatibility"},{"location":"types/#other-built-in-types","text":"","title":"Other built-in types"},{"location":"types/#pointer-types","text":"Pointers mirror C: Foo* is a pointer to a Foo , while Foo** is a pointer to a pointer of Foo.","title":"Pointer types"},{"location":"types/#the-typeid-type","text":"The typeid can hold a runtime identifier for a type. Using <typename>.typeid a type may be converted to its unique runtime id, e.g. typeid a = Foo.typeid; . This value is pointer-sized.","title":"The typeid type"},{"location":"types/#the-variant-type","text":"C3 contains a built-in variant type, which is essentially struct containing a typeid plus a void* pointer to a value. It is possible to cast the variant type to any pointer type, which will return null if the types don't match, or the pointer value otherwise. int x; variant y = &x; double *z = (double*)y; // Returns null int* w = (int*)x; // Returns the pointer to x Switching over the variant type is another method to unwrap the pointer inside: fn void test(variant z) { // Unwrapping switch switch (z) { case int: // z is unwrapped to int* here case double: // z is unwrapped to double* here } // Assignment switch switch (y = z) { case int: // y is int* here } // Direct unwrapping to a value is also possible: switch (w = *z) { case int: // w is int here } } variant.type returns the underlying pointee typeid of the contained value. variant.ptr returns the raw void* pointer.","title":"The variant type"},{"location":"types/#array-types","text":"Arrays are indicated by [size] after the type, e.g. int[4] . Subarrays use the type[] . For initialization the wildcard type[*] can be used to infer the size from the initializer. See the chapter on arrays .","title":"Array types"},{"location":"types/#vector-types","text":"Vectors use [<size>] after the type, e.g. float[<3>] , with the restriction that vectors may only form out of integers, floats and booleans. Similar to arrays, wildcard can be used to infer the size of a vector: int[<*>] a = { 1, 2 } . Note: C3 will support scaled vectors using the syntax float[<>] , but this is currently not implemented.","title":"Vector types"},{"location":"types/#types-created-using-defined","text":"","title":"Types created using defined"},{"location":"types/#typedef","text":"Like in C, C3 has a \"typedef\" construct, define <typename> = <type> define Int32 = int; define Vector2 = float[<2>]; ... Int32 a = 1; int b = a;","title":"\"typedef\""},{"location":"types/#function-pointer-types","text":"Function pointers are always used through a define : define Callback = fn void(int value); Callback callback = &test; fn void test(int a) { ... } To form a function pointer, write a normal function declaration but skipping the function name. fn int foo(double x) -> fn int(double x) . Function pointers can have default arguments, e.g. define Callback = fn void(int value = 0) but default arguments and parameter names are not taken into account when determining function pointer assignability: define Callback = fn void(int value = 1); fn void test(int a = 0) { ... } Callback callback = &main; // Ok fn void main() { callback(); // Works, same as test(0); test(); // Works, same as test(1); callback(.value = 3); // Works, same as test(3) test(.a = 4); // Works, same as test(4) // callback(.a = 3); ERROR! }","title":"Function pointer types"},{"location":"types/#distinct-types","text":"Distinct types is a kind of typedef which creates a new type that has the same properties as the original type but is - as the name suggests - distinct from it. It cannot implicitly convert into the other type. A distinct type is created by adding distinct before the type name in a \"define\": define <typename> = distinct <type> define MyId = distinct int; fn void* get_by_id(MyId id) { ... } fn void test(MyId id) { void* val = get_by_id(id); // Ok void* val2 = get_by_id(1); // Literals convert implicitly int a = 1; // void* val3 = get_by_id(a); // ERROR expected a MyId void* val4 = get_by_id((MyId)a); // Works // a = id; // ERROR can't assign 'MyId' to 'int' }","title":"Distinct types"},{"location":"types/#generic-types","text":"Similar to function pointers, generic types are only available using define : import generic_list; // Contains the generic MyList struct Foo { int x; } define IntMyList = generic_list::MyList<int>; define FooMyList = generic_list::MyList<Foo>; Read more about generic types on the page about generics .","title":"Generic types"},{"location":"types/#enum","text":"Enum (enumerated) types use the following syntax: enum State : int { PENDING, RUNNING, TERMINATED } Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use State.PENDING rather than PENDING .","title":"Enum"},{"location":"types/#enum-type-inference","text":"When an enum is used in where the type can be inferred, like in case-clauses or in variable assignment, it is allowed to drop the enum name: State foo = PENDING; // State.PENDING is inferred. switch (foo) { case RUNNING: // State.RUNNING is inferred ... default: ... } fn void test(State s) { ... } ... test(RUNNING); // State.RUNNING is inferred In the case that it collides with a global in the same scope, it needs the qualifier: module test; fn void testState(State s) { ... } const State RUNNING = State.TERMINATED; // Don't do this! ... test(RUNNING); // Ambiguous test(test::RUNNING); // Uses global. test(State.RUNNING); // Uses enum constant.","title":"Enum type inference"},{"location":"types/#enum-associated-values","text":"It is possible to associate each enum value with a static value. enum State : int (String state_desc, bool active) { PENDING(\"pending start\", false), RUNNING(\"running\", true), TERMINATED(\"ended\", false) } ... State s = get_state(); io::printfn(\"Currently the process is %s\", s.state_desc); if (s.active) do_something();","title":"Enum associated values"},{"location":"types/#faults","text":"fault defines a set of optional result values, that are similar to enums, but are used for optional returns. fault IOResult { IO_ERROR, PARSE_ERROR } fault MapResult { NOT_FOUND } Like the typeid, the constants are pointer sized and each value is globally unique, even when compared to other faults. For example the underlying value of MapResult.NOT_FOUND is guaranteed to be different from IOResult.IO_ERROR . This is true even if they are separately compiled. A fault may be stored as a normal value, but is also unique in that it may be passed as the optional result value using the ! suffix operator.","title":"Faults"},{"location":"types/#optional-result-types","text":"An optional result type is created by taking a type and appending ! . An optional result type is a tagged union containing either the expected result or an optional result value (which is a fault). int! i; i = 5; // Assigning a real value to i. i = IOResult.IO_ERROR!; // Assigning an optional result to i. Only variables and return variables may be optionals. Function and macro parameters may not be optionals. fn Foo*! getFoo() { ... } // Ok! fn void processFoo(Foo*! f) { ... } // Error int! x = 0; // Ok! Read more about the optional types on the page about error handling .","title":"Optional Result Types"},{"location":"types/#struct-types","text":"Structs are always named: struct Person { char age; String name; } A struct's members may be accessed using dot notation, even for pointers to structs. Person p; p.age = 21; p.name = \"John Doe\"; libc::printf(\"%s is %d years old.\", p.age, p.name); Person* pPtr = &p; pPtr.age = 20; // Ok! libc::printf(\"%s is %d years old.\", pPtr.age, pPtr.name); (One might wonder whether it's possible to take a Person** and use dot access. \u2013 It's not allowed, only one level of dereference is done.) To change alignment and packing, optional attributes such as @packed may be used.","title":"Struct types"},{"location":"types/#struct-subtyping","text":"C3 allows creating struct subtypes using inline : struct ImportantPerson { inline Person person; String title; } fn void printPerson(Person p) { libc::printf(\"%s is %d years old.\", p.age, p.name); } ImportantPerson important_person; important_person.age = 25; important_person.name = \"Jane Doe\"; important_person.title = \"Rockstar\"; printPerson(important_person); // Only the first part of the struct is copied.","title":"Struct subtyping"},{"location":"types/#union-types","text":"Union types are defined just like structs and are fully compatible with C. union Integral { byte as_byte; short as_short; int as_int; long as_long; } As usual unions are used to hold one of many possible values: Integral i; i.as_byte = 40; // Setting the active member to as_byte i.as_int = 500; // Changing the active member to as_int // Undefined behaviour: as_byte is not the active member, // so this will probably print garbage. libc::printf(\"%d\\n\", i.as_byte); Note that unions only take up as much space as their largest member, so Integral.sizeof is equivalent to long.sizeof .","title":"Union types"},{"location":"types/#nested-sub-structs-unions","text":"Just like in C99 and later, nested anonymous sub-structs / unions are allowed. Note that the placement of struct / union names is different to match the difference in declaration. struct Person { char age; String name; union { int employee_nr; uint other_nr; } union subname { bool b; Callback cb; } }","title":"Nested sub-structs / unions"},{"location":"types/#bitstructs","text":"Bitstructs allows storing fields in a specific bit layout. A bitstruct may only contain integer types and booleans, in most other respects it works like a struct. The main differences is that the bitstruct has a backing type and each field has a specific bit range. In addition it's not possible to take the address of a bitstruct field. bitstruct Foo : char { int a : 0..2; int b : 4..6; bool c : 7; } ... Foo f; f.a = 2; char x = (char)f; io::printfn(\"%d\", (char)f); // prints 2 f.b = 1; io::printfn(\"%d\", (char)f); // prints 18 f.c = true; io::printfn(\"%d\", (char)f); // prints 146 The bitstruct will follow the endianness of the underlying type: bitstruct Test : uint { ushort a : 0..15; ushort b : 16..31; } ... Test t; t.a = 0xABCD; t.b = 0x789A; char* c = (char*)&t; io::printfn(\"%X\", (uint)t); // Prints 789AABCD for (int i = 0; i < 4; i++) io::printf(\"%X\", c[i]); // Prints CDAB9A78 io::println(); It is however possible to pick a different endianness, in which case the entire representation will internally assume big endian layout: bitstruct Test : uint @bigendian { ushort a : 0..15; ushort b : 16..31; } In this case the same example yields CDAB9A78 and 789AABCD respectively. Bitstruct backing types may be integers or char arrays. The difference in layout is somewhat subtle: bitstruct Test1 : char[4] { ushort a : 0..15; ushort b : 16..31; } bitstruct Test2 : char[4] @bigendian { ushort a : 0..15; ushort b : 16..31; } ... Test1 t1; Test2 t2; t1.a = t2.a = 0xABCD; t1.b = t2.b = 0x789A; char* c = (char*)&t1; for (int i = 0; i < 4; i++) io::printf(\"%X\", c[i]); // Prints CDAB9A78 on x86 io::println(); c = (char*)&t2; for (int i = 0; i < 4; i++) io::printf(\"%X\", c[i]); // Prints ABCD789A io::println(); Bitstructs can be made to have ovelapping bit fields. This is useful when modelling a layout which has multiple different layouts depending on flag bits: bitstruct Foo : char @overlap { int a : 2..5; int b : 1..3; // Only valid due to the @overlap attribute }","title":"Bitstructs"},{"location":"undefinedbehaviour/","text":"Undefined behaviour Like C, C3 uses undefined behaviour. In contrast, C3 will trap - that is, print an error trace and abort \u2013 on undefined behaviour in debug builds. This is similar to using C with a UB sanitizer. It is only during release builds that actual undefined behaviour occurs. In C3, undefined behaviour means that the compiler is free to interpret undefined behaviour as if behaviour cannot occur . In the example below: uint x = foo(); uint z = 255 / x; return x != 0; The case of x == 0 would invoke undefined behaviour for 255/x . For that reason, the compiler may assume that x != 0 and compile it into the following code: foo(); return true; As a contrast, the safe build will compile code equivalent to the following. uint x = foo(); if (x == 0) trap(\"Division by zero\") return true; List of undefined behaviours The following operations cause undefined behaviour in release builds of C3: operation will trap in safe builds int / 0 Yes int % 0 Yes reading explicitly uninitialized memory Possible* array index out of bounds Yes dereference null Yes dereferencing memory not allocated Possible* dereferencing memory outside of its lifetime Possible* casting pointer to the incorrect array or vararray Possible* violating pre or post conditions Yes violating asserts Yes reaching unreachable() code Yes * \"Possible\" indicates trapping is implementation dependent. List of implementation dependent behaviours Some behaviour is allowed to differ between implementations and platforms. operation will trap in safe builds permitted behaviour comparing pointers of different provenance Optional Any result subtracting pointers of different provenance Optional Any result shifting by more or equal to the bit width Yes Any result shifting by negative amount Yes Any result conversion floating point <-> integer type is out of range Optional Any result conversion between pointer types produces one with incorrect alignment Optional Any result / Error calling a function through a function pointer that does not match the function Optional Any result / Error attempt to modify a string literal Optional Partial modification / Error modifying a const variable Optional Partial modification / Error List of undefined behaviour in C, which is defined in C3 Signed Integer Overflow Signed integer is always wrapped using 2s complement. Modifying the intermediate results of an expression Behaves as if the intermediate result was stored in a variable on the stack.","title":"Undefined behaviour"},{"location":"undefinedbehaviour/#undefined-behaviour","text":"Like C, C3 uses undefined behaviour. In contrast, C3 will trap - that is, print an error trace and abort \u2013 on undefined behaviour in debug builds. This is similar to using C with a UB sanitizer. It is only during release builds that actual undefined behaviour occurs. In C3, undefined behaviour means that the compiler is free to interpret undefined behaviour as if behaviour cannot occur . In the example below: uint x = foo(); uint z = 255 / x; return x != 0; The case of x == 0 would invoke undefined behaviour for 255/x . For that reason, the compiler may assume that x != 0 and compile it into the following code: foo(); return true; As a contrast, the safe build will compile code equivalent to the following. uint x = foo(); if (x == 0) trap(\"Division by zero\") return true;","title":"Undefined behaviour"},{"location":"undefinedbehaviour/#list-of-undefined-behaviours","text":"The following operations cause undefined behaviour in release builds of C3: operation will trap in safe builds int / 0 Yes int % 0 Yes reading explicitly uninitialized memory Possible* array index out of bounds Yes dereference null Yes dereferencing memory not allocated Possible* dereferencing memory outside of its lifetime Possible* casting pointer to the incorrect array or vararray Possible* violating pre or post conditions Yes violating asserts Yes reaching unreachable() code Yes * \"Possible\" indicates trapping is implementation dependent.","title":"List of undefined behaviours"},{"location":"undefinedbehaviour/#list-of-implementation-dependent-behaviours","text":"Some behaviour is allowed to differ between implementations and platforms. operation will trap in safe builds permitted behaviour comparing pointers of different provenance Optional Any result subtracting pointers of different provenance Optional Any result shifting by more or equal to the bit width Yes Any result shifting by negative amount Yes Any result conversion floating point <-> integer type is out of range Optional Any result conversion between pointer types produces one with incorrect alignment Optional Any result / Error calling a function through a function pointer that does not match the function Optional Any result / Error attempt to modify a string literal Optional Partial modification / Error modifying a const variable Optional Partial modification / Error","title":"List of implementation dependent behaviours"},{"location":"undefinedbehaviour/#list-of-undefined-behaviour-in-c-which-is-defined-in-c3","text":"","title":"List of undefined behaviour in C, which is defined in C3"},{"location":"undefinedbehaviour/#signed-integer-overflow","text":"Signed integer is always wrapped using 2s complement.","title":"Signed Integer Overflow"},{"location":"undefinedbehaviour/#modifying-the-intermediate-results-of-an-expression","text":"Behaves as if the intermediate result was stored in a variable on the stack.","title":"Modifying the intermediate results of an expression"},{"location":"variables/","text":"Variables Zero init by default Unlike C, C3 local variables are zero-initialized by default. To avoid zero-init, you need to explicitly opt-out. int x; // x = 0 int y = void; // y is explicitly undefined and must be assigned before use. AStruct foo; // foo is implicitly zeroed AStruct bar = {}; // boo is explicitly zeroed AStruct baz = void; // baz is explicitly undefined Using a variable that is explicitly undefined before will trap in debug builds and is undefined behaviour in release builds.","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"},{"location":"variables/#zero-init-by-default","text":"Unlike C, C3 local variables are zero-initialized by default. To avoid zero-init, you need to explicitly opt-out. int x; // x = 0 int y = void; // y is explicitly undefined and must be assigned before use. AStruct foo; // foo is implicitly zeroed AStruct bar = {}; // boo is explicitly zeroed AStruct baz = void; // baz is explicitly undefined Using a variable that is explicitly undefined before will trap in debug builds and is undefined behaviour in release builds.","title":"Zero init by default"}]}
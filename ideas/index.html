<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Crazy ideas - C3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Crazy ideas";
    var mkdocs_page_input_path = "ideas.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C3 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">About C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Installing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../firstproject/">Your first project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../primer/">A quick primer on C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../changesfromc/">Changes from C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compare/">Comparisons with other languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../define/">Define</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statements/">Statements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../expressions/">Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../errorhandling/">Errors</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../undefinedbehaviour/">Undefined behaviour</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../conversion/">Conversions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../builtinmacros/">Built-in Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../precedence/">Precedence</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../generics/">Generics</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../macros/">Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../reflection/">Reflection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../preconditions/">Pre and post conditions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../library/">Library</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Crazy ideas</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#static-initializers">Static initializers</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#module-versioning">Module versioning</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#limited-operator-overloading">Limited operator overloading</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#generic-as-keyword-for-polymorphic-functions">Generic as keyword for polymorphic functions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#associative-array-literals">Associative array literals</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#array-literals">Array literals</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#allow-slicing-of-user-defined-containers">Allow slicing of user defined containers</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#allow-narrowing-conversions-for-floats">Allow narrowing conversions for floats</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#tests-built-in">Tests built in</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#attribute-to-ensure-alignment">Attribute to ensure alignment</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#binary-include">Binary include</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#compile-time-run-include">Compile time run-include</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-text-interpolation">Macro text interpolation</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-string-functions">Compile time string functions</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#implicit-this-in-method-functions">Implicit "this" in method functions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#c-interop">C interop</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#unsorted">Unsorted</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#tagged-any">Tagged any</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#extended-case">Extended "case"</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#case-as-a-range">Case as a range</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#easy-to-get-properties">Easy to get properties</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#associate-properties-to-an-enum">Associate properties to an enum</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tagged-unions">Tagged unions</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#interfaces">Interfaces</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#built-in-maps">Built in maps</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#built-in-string-type">Built in string type</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#built-in-managed-pointers">Built in managed pointers</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ideas-around-macros">Ideas around macros</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-variables">Compile time variables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#capturing-trailing-compound-statement">Capturing trailing compound statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#stepwise-from-c-macros-into-c3-macros">Stepwise from C macros into C3 macros</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#yet-another-macro-proposal-i-found">Yet another macro proposal I found</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../naming/">Naming rules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../comments/">Comments & Docs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../attributes/">Attributes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cinterop/">C Interop</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../syntax/">Grammar</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../sample/">More code examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../specification/">Specification</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Build system</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../buildintro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../project/">Project Structure</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../buildcommands/">Commands</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../contribute/">Contribute</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../changes/">Changes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../rejectedideas/">Rejected ideas</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C3 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Crazy ideas</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="ideas">Ideas</h1>
<p><strong>WARNING</strong> Unfinished ideas / brain dumps</p>
<h2 id="static-initializers">Static initializers</h2>
<p>Allow initialization of globals before main is invoked. Introduce a general <code>static</code> block.</p>
<pre><code>module foo;

int x;

static
{
    x = rand();
}

int y = rand();

fn int randomCalculation()
{
    return rand();
}
</code></pre>
<p>Sematic roughly work like in Java, except that all know globals are initialized before main, as opposed to when the class is invoked. The order of initialization is unspecified.</p>
<h2 id="module-versioning">Module versioning</h2>
<p>Follow Go Modules: </p>
<ol>
<li>Build file contains required library versions: e.g. 2.5.7</li>
<li>First number is major version number and is considered incompatible (basically a different module completely)</li>
<li>Dependency resolution per major library version is done by picking the minimal version. E.g. module Foo requires Bar 1.5+ and module Baz requires 1.3+. Our module using Bar and Baz will resolve the minimal version to 1.3. This is the version that will be used. Note that if Foo used 2.5+, then both Bar 2.5 and 1.3 would be required.</li>
</ol>
<h2 id="limited-operator-overloading">Limited operator overloading</h2>
<p>Use method macros to introduce some operator overloading and related functionality:</p>
<pre><code>macro Foo._foreach_index(Foo *f; index, value)
{
    $IndexType = $typeof(index);
    usize len = f.len;
    for (usize i = 0; i &lt; len; i++)
    {
        yield ($IndexType)(i), f.values[i];
    }
}

macro Foo._initializer_list(Foo *f, $list)
{
    $foreach ($i : $list):
        f.add($i);
    $endforeach;    
}
</code></pre>
<p>The above would allow:</p>
<pre><code class="language-c">Foo f = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; };
foreach(int i, value : f)
{
    printf(&quot;%d: %s\n&quot;, i, f);
}
</code></pre>
<p>Which is transformed during macro expansion to:</p>
<pre><code class="language-c">Foo f;
f.add(&quot;a&quot;);
f.add(&quot;b&quot;);
f.add(&quot;c&quot;);
usize len = f.len;
for (usize i = 0; i &lt; len; i++)
{
    printf(&quot;%d: %s\n&quot;, (int)i, f.values[i]);
}
</code></pre>
<h2 id="generic-as-keyword-for-polymorphic-functions">Generic as keyword for polymorphic functions</h2>
<p>For macros that essentially are polymorphic functions, we could use the keyword "generic" instead:</p>
<pre><code class="language-c">macro swap(&amp;a, &amp;b) { ... } // Cannot be generic, captures are not allowed.
macro max(a, b) { ... } // Can be generic
macro doSomething(a, #a) { ... } // Cannot be generic, uses unevaluated expressions
macro malloc($Type) { ... } // Can be generic.

// Example of &quot;max&quot;:
generic max(a, b)
{
    return a &gt; b ? b : a;
}
// Example of &quot;malloc&quot;
generic malloc($Type)
{
    _builtin_malloc($sizeof($Type));
}
</code></pre>
<p>Invocation changes:</p>
<pre><code class="language-c">int max_value = @max(foo(), bar()); // macro
int max_value = max(foo(), bar()); // generic
</code></pre>
<p>This would furthermore remove the "!" addition for escaping macros, adding it as an attribute:</p>
<pre><code class="language-c">macro returnme() @escaping
{
    return;
}
</code></pre>
<p>Macros could then also more natural invoke defer:</p>
<pre><code class="language-c">macro deferclose() @scopeless
{
    defer close();    
}
</code></pre>
<p>Both would be invoked:</p>
<pre><code class="language-c">@deferclose();
@returnme();
</code></pre>
<p>It would be possible to define a generic, such a generic could be taken the address of:</p>
<pre><code class="language-c">#define intmax = max(int, int);
#define TwoIntfn = fn int(int, int);
TwoIntFunc x = &amp;intmax;
</code></pre>
<h2 id="associative-array-literals">Associative array literals</h2>
<p><em>Syntax and implementation under consideration!</em></p>
<p>Associative arrays are mappings between keys and values:</p>
<pre><code>IntStringMap x = { &quot;a&quot;: 2, &quot;b&quot;: { &quot;3&quot; : &quot;foo&quot; } };
</code></pre>
<p>To use an associative array, the struct needs to define
the following generics: <code>_map_init()</code> and <code>_map_init_add</code>. In the example above, the actual code is compiled to:</p>
<pre><code>IntStringMap x;
_map_init(&amp;x);
_map_init_add(&amp;x, &quot;a&quot;, 2);
IntStringMap _temp;
_map_init(&amp;_temp);
_map_init_add(&amp;x, &quot;3&quot;, &quot;foo&quot;);
_map_init_add(&amp;x, &quot;b&quot;, _temp);
</code></pre>
<h2 id="array-literals">Array literals</h2>
<p>Arrays can be initialized using compound literals, but there is also a special format for array initialization using <code>[]</code>. In this case, the type is inferred. It allows uniform initialization of all types of arrays:</p>
<pre><code>int[3] y = [1, 2, 3]; // Fixed array allocated on the stack
int[] z = [1, 2, 3]; // Slice pointing at literal allocated on the stack
</code></pre>
<p>It offers some convenience when calling functions taking arrays:</p>
<pre><code>fn void test1(int[3] x) { ... }
fn void test2(int[] y) { ... }
fn void test2(int[3]* z) { ... }

test1([ 1, 2, 3 ]);
test2([ 1, 2, 3 ]);
test3([ 1, 2, 3 ]);
</code></pre>
<h2 id="allow-slicing-of-user-defined-containers">Allow slicing of user defined containers</h2>
<pre><code class="language-c">// Supporting the full set.
macro Foo._slice(Foo* foo, a, b, $a_from_end, $b_from_end)
{
    $if ($a_from_end):
        $if ($b_from_end):
            return foo.values[^a..^b];
        $endif:
        return foo.values[^a..b];
    $endif;    
    $if ($b_from_end):
        return foo.values[a..^b];
    $endif;
    return foo.values[a..b];    
}

// Not supporting reverse
macro Bar._slice(Bar *bar, a, b, $a_from_end, $b_from_end)
{
    $assert(!$a_from_end &amp;&amp; !$b_from_end, &quot;Slicing from the end is not possible for Bar types.&quot;);
    return bar.valyes[a..b];
}
</code></pre>
<h2 id="allow-narrowing-conversions-for-floats">Allow narrowing conversions for floats</h2>
<p>Narrowing conversions for double -&gt; float are common and might not be sufficiently important to do explicitly.</p>
<h2 id="tests-built-in">Tests built in</h2>
<p>Unit tests built in as an integral part of the language like D.</p>
<h2 id="attribute-to-ensure-alignment">Attribute to ensure alignment</h2>
<p><code>@assertalign</code> works as GCCs warn_if_not_aligned. On non packed structs, this will prevent compilation if padding is inserted in front of the member. On a packed struct, it will prevent compilation if it is not aligned.</p>
<h2 id="binary-include">Binary include</h2>
<p>The ability to include a binary file during compile time.</p>
<p>An additional <code>embed-path</code> gives search dirs.</p>
<pre><code>byte[] file = @binary_include(&quot;foo.dat&quot;);
</code></pre>
<p>Limiting embed to x bytes:</p>
<pre><code>byte[] file = @binary_include(&quot;/dev/urandomg&quot;, 16);
</code></pre>
<h2 id="compile-time-run-include">Compile time run-include</h2>
<p>The ability to run a piece of code at compile time and include the result in the code.</p>
<pre><code>@run_include(&quot;foo.sh&quot;, $some_param, &quot;-x&quot;, $another_param);
</code></pre>
<h2 id="macro-text-interpolation">Macro text interpolation</h2>
<p>For certain cases, pure text interpolation might be needed. Within macros, any text within <code>``</code> can be evaluated and parsed.</p>
<pre><code>macro void @foo($x, #f)
{
    `#f $x * $x`;
}

fn void test()
{
    int x = 1;
    @foo(4, &quot;x +=&quot;);
    // Expands to -&gt;
    // x += 4 * 4;
}
</code></pre>
<p>Another example, showing the difference between <code>#var</code> and <code>`#var`</code>:</p>
<pre><code>macro void @foo2(#f)
{
    printf(&quot;%s was %d\n&quot;, #f, `#f`);
}

funct void test2()
{
    int x = 1;
    @foo2(x);
    // Expands to -&gt;
    // printf(&quot;%s was %d\n&quot;, &quot;x&quot;, x);
}
</code></pre>
<h3 id="compile-time-string-functions">Compile time string functions</h3>
<p>In order to facilitate certain types of macros, the following macros are built in:</p>
<ul>
<li><code>@strToUpper(#f)</code> Convert string to upper case.</li>
<li><code>@strToLower(#f)</code> Convert string to lower case.</li>
<li><code>@strToVarName(#f, #space)</code> Convert string to camel case from a space-based name scheme.</li>
<li><code>@strToTypeName(#f, #space)</code> Convert string to title case from a space-based name scheme.</li>
<li><code>@strFromName(#f, #space)</code> Convert title case or lower camel case to a space based scheme.</li>
<li><code>@strReplace(#str, #pattern, #replacement, #count)</code> Replace a string with another.</li>
<li><code>@subString(#str, #start, #length)</code> Return a substring of a compile time string.</li>
<li><code>@strFind(#str, #stringToFind)</code> Find a substring in a compile time string.</li>
<li><code>@strHash(#str)</code> Return the FNV1a hash of a string.</li>
<li><code>@strLen(#str)</code> Return a compile time length of a string.</li>
<li><code>@stringify(#str)</code> Escapes a string so it becomes a valid string.</li>
</ul>
<h2 id="implicit-this-in-method-functions">Implicit "this" in method functions</h2>
<pre><code>struct Foo
{
    int i;
}

fn Foo.next(Foo*)
{
    i++;
}
</code></pre>
<h2 id="c-interop">C interop</h2>
<p>Steps:</p>
<ol>
<li>Add group header in the builds: [c-libs]</li>
<li>Add the search paths: cpath = ["/xxx/foo/<strong>", "/bar/headers/</strong>"]</li>
<li>Add each library: [[lib]]</li>
</ol>
<pre><code>[c-libs]
    cpath = [&quot;/xxx/foo/**&quot;, &quot;/bar/headers/**&quot;]
    [[lib]]
        module = &quot;windows&quot;
        header = &quot;windows.h&quot;
    [[lib]]
        module = &quot;stdlib&quot;
        header = &quot;stdlib.h&quot;
</code></pre>
<h2 id="unsorted">Unsorted</h2>
<h5 id="tagged-any">Tagged any</h5>
<p>A tagged pointer union type for any possible type.</p>
<h5 id="extended-case">Extended "case"</h5>
<p>Switch as "if-else"</p>
<pre><code>switch (x) 
{
    case x &gt; 200: 
        return 0;
    case x &lt; 2: 
        small_x_warning();
    case 0:
        ....
    case x &gt; y &amp;&amp; a &lt; 1:
        ...
}
</code></pre>
<h5 id="case-as-a-range">Case as a range</h5>
<pre><code>switch (x) 
{
    case 1 .. 10: 
        ...
    case 11 .. 100:
        ...
}
</code></pre>
<h5 id="easy-to-get-properties">Easy to get properties</h5>
<ul>
<li>Endianness</li>
<li>Register size</li>
<li>Query what type of add is the fastest (wrapping, trapped) for the processor (with macros to select type)</li>
<li>Query what type of overflow the processor supports</li>
</ul>
<h5 id="associate-properties-to-an-enum">Associate properties to an enum</h5>
<pre><code>enum State [char* name, byte bit] int
{
    START(&quot;begin!&quot;, 0x01) = 0,
    END(&quot;end it!&quot;, 0x10)
}

funct void test()
{
    printf(&quot;%s\n&quot;, State.START.name); // Prints &quot;begin!&quot;
    printf(&quot;%d\n&quot;, State.END.bit); // Prints &quot;16&quot;
}
</code></pre>
<h5 id="tagged-unions">Tagged unions</h5>
<pre><code>tagged union Foo {
    int i;
    const char *c;
};

Foo foo;
foo.i = 3;
@istag(foo.i) // =&gt; true
@istag(foo.c) // =&gt; false
foo.c = &quot;hello&quot;;
@istag(foo.i) // =&gt; false
@istag(foo.c) // =&gt; true

switch(@tag(foo)) 
{
    case Foo.i: 
        printf(&quot;Was %d\n&quot;, foo.i);
    case Foo.c: 
        printf(&quot;Was %s\n&quot;, foo.c);
}
</code></pre>
<p>Alternative syntax etc:</p>
<pre><code>struct Shape
{
    int centerX;
    int centerY;
    byte kind; // Implicit enum
    union (kind) 
    {
        SQUARE: { int side; }
        RECTANGLE: { int length, height; }
        CIRCLE: { int radius; }
    }
}
</code></pre>
<p>And another...</p>
<pre><code>struct Shape
{
    int centerX;
    int centerY;
    byte kind; // Implicit enum
    union (kind) 
    {
        struct square 
        {
            int side;
        }    
        struct rectangle 
        {
            int length;
            int height;
        }
        struct circle
        {
            int radius;
        }
    }
}


</code></pre>
<p>And yet another...</p>
<pre><code>struct Shape
{
    int centerX;
    int centerY;
    tagged union (kind)
    {
        case SQUARE:
            int side; 
        case RECTANGLE:
            int length;
            int height;
        case CIRCLE:
            int radius;            
    }
    byte kind;
}
</code></pre>
<h2 id="interfaces">Interfaces</h2>
<pre><code>fn void Foo.renderPage(Foo* foo, Page* info)
{
    /* ... */
}

interface Renderer
{
    void renderPage(virtual Renderer* renderer, Page* info);
}

fn void render(virtual Renderer* renderer, Page* info)
{
    if (!rendered) return;
    renderer-&gt;renderPage(info);
}

fn void test()
{
    Foo* foo = getFoo();
    Page* page = getPage(); 

    // Option 1
    Renderer.render(foo, page);

    // Option 2
    virtual Renderer* renderer = foo;
    renderer.render(page);
}


// C equivalent: 
// struct RendererVtable { 
//     void (*renderPage)(void*, Page*); 
// };
// struct RendererRef { 
//     void* ref; RendererVTable *vtable; 
// };
// void Renderer__render(struct RendererRef renderer, Page *info) {
//     if (renderer.ref == null) return;
//     renderer.vtable-&gt;renderPage(renderer.ref, info);
// }
// 
// void test() {
//     Foo *foo = getFoo();
//     Page *page = getPage(); 
//
//     static RenderVTable FooRendererVTable = { &amp;Foo__renderPage };
//     Renderer__render(struct RendererRef { foo, &amp;FooRendererVTable }, page);
//    
//     struct RendererRef renderer = { foo, &amp;FooRendererVTable };
//     Renderer__render(renderer, page);
// }
</code></pre>
<h2 id="built-in-maps">Built in maps</h2>
<p>Same reasoning as arrays. Question about memory management is the same.</p>
<pre><code>int[int] map; // Built-in maps
map[1] = 11;
// Retrieving a value
int i = map[0]!!; // Requires a rethrow

// Retrive or use default
int i = try map[12] else -1;

// Extend a map:
fn bool int[int].remove_if_negative(int[int] *map, int index)
{
    if (try map[index] &gt;= 0 else true) return false;    
    map.remove(index);
    return true;
}

// The underlying C function becomes:
// bool module_name__map_int_int__remove_if_negative(struct _map_int_int *map, int32_t index);
</code></pre>
<h2 id="built-in-string-type">Built in string type</h2>
<p>Strings are built-in, refcounted(?) null-terminated character arrays.</p>
<p>Take a long hard look at memory management (here too)</p>
<pre><code>string = &quot;Hello&quot;;
string += &quot; World&quot;;
char* data = &amp;string; // Taking a pointer to the string, which may later be invalid.
</code></pre>
<h2 id="built-in-managed-pointers">Built in managed pointers</h2>
<p>Taking a hint from Cyclone, Rust etc one could consider managed pointers / objects. There are several possibilities:</p>
<ol>
<li>Introduce something akin to move/borrow syntax with a special pointer type, eg. Foo@ x vs Foo* y and make the code track Foo@ to have unique ownership.</li>
<li>Introduce ref-counted objects with ref-counted pointers. Again use Foo@ x vs Foo* y with the latter being unretained. This should be internal refcounting to avoid any of the issues going from retained -&gt; unretained that shared_ptr has. Consequently any struct that is RC:ed needs to be explicitly declared as such.</li>
<li>Managed pointers: you alloc and the pointer gets a unique address that will always be invalid after use. Any overflows will be detected, but use of managed pointers is slower due to redirect and check.</li>
</ol>
<h2 id="ideas-around-macros">Ideas around macros</h2>
<p>Just some previous thoughts and ideas I've considered. Many of those actually go against the current design.</p>
<h3 id="compile-time-variables">Compile time variables</h3>
<p>This is a variant of what already exists in C, but in a syntactically more friendly way.</p>
<p>For example this would be ok:</p>
<pre><code>macro swap(a, b) 
{
    $x = $typeof(a);
    static_assert($typeof(b) == $x);
    $x temp = a;
    a = b;
    b = a;
}
</code></pre>
<p>The example above is a bit contrived as in the above example we could simply have:</p>
<pre><code>macro swap(a, b) 
{
    $static_assert($typeof(b) == $typeof(b));
    $typeof(a) temp = a;
    a = b;
    b = a;
}
</code></pre>
<p>But still, it serves as an example on how to use it.</p>
<h3 id="capturing-trailing-compound-statement">Capturing trailing compound statement</h3>
<pre><code>public macro foreach(thelist, @body(Element *) ) 
{ 
    Element* iname = thelist.first;
    while (iname != nil) 
    {
        @body(iname);
        iname = iname.next;
    }
}
</code></pre>
<p>Or a version that is more flexible:</p>
<pre><code>public macro foreach(thelist, @body(typeof(thelist.first)) ) 
{ 
    $typeof(thelist.first) iname = thelist.first;
    while (iname != nil) 
    {
        @body(iname);
        iname = iname.next;
    }
}

// Usage:

foreach(list, Element *i) // &lt;- Note type declaration!
{ 
    i.print();
}
</code></pre>
<p>Since type is going to appear very often, we could make a shortcut for it, like $@ as prefix meaning "typeof".</p>
<p>We then get</p>
<pre><code>public macro foreach(thelist, @body($@thelist.first)) 
{ 
    $@thelist.first iname = thelist.first;
    while (iname != nil) 
    {
        @body(iname);
        iname = iname.next;
    }
}
</code></pre>
<p>Possibly one could even write the code like this:</p>
<pre><code>public macro foreach(thelist, @body($element_type) ) 
{ 
    $element_type iname = thelist.first;
    while (iname != nil) {
        @body(iname);
        iname = iname.next;
    }
}
</code></pre>
<p>In this case <code>$element_type</code> works like "auto", but is also assigned the type, which then can be referred to in the signature.</p>
<h4 id="stepwise-from-c-macros-into-c3-macros">Stepwise from C macros into C3 macros</h4>
<pre><code>#define ADD_TO(x, y) {
    x += y;
}

ADD_TO(x, 1)
</code></pre>
<p>The { } introduces a multiline macro that does not need explicit linebreaks.</p>
<p>Now, add the "$" symbol to introduce hygienic temporaries:</p>
<pre><code>#define SWAP(x, y) {
    typeof(x) $tmp = x;
    x = y;
    y = $tmp;
}
</code></pre>
<p>Here $tmp will actually be replaced by <code>__&lt;macro&gt;_&lt;variable_name&gt;_&lt;instance&gt;</code> when translating to C, so <code>__SWAP_tmp_1</code>, <code>__SWAP_tmp_2</code> etc.</p>
<p>We then introduce the syntax macros using:</p>
<pre><code>macro swap(&amp;a, &amp;b) 
{
    typeof(a) $tmp = a;
    b = a;
    a = $tmp;
}
</code></pre>
<p>(Note the different use of $ here as compared to previous macro ideas where $ is a compile time evaluated variable!)</p>
<p>The use of &amp;a follows C++ standard: it simply refers to a variable OR EXPRESSION that is imported into its scope. Using the unadorned variable name as evaluated expression allows us to write this code:</p>
<pre><code>macro max(a, b) 
{
    return (a &gt; b ? a : b)
}
</code></pre>
<p>The above code is equivalent to:</p>
<pre><code>macro max(&amp;a, &amp;b) 
{
    typeof(a) $tmp_a = a;
    typeof(b) $tmp_b = b;
    $tmp_a &gt; $tmp_b ? $tmp_a : $tmp_b
}
</code></pre>
<p>Or in (GNU) C:</p>
<pre><code>#define max(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a &gt; _b ? _a : _b; })
</code></pre>
<p>To recap:</p>
<ol>
<li>Add the { } format to #define for multiline defines.</li>
<li>Add <code>$&lt;name&gt;</code> format as hygienic variable names.</li>
<li>Add the syntax "macro" type of definition.</li>
<li>The syntax macro makes a difference between "normal" parameters (with &amp; as prefix) and "evaluated" parameters (unadorned variables)</li>
</ol>
<p>Important is also to scope the macros:</p>
<p><code>#define</code> is always defined local to a scope (unlike in C). </p>
<p>This means that </p>
<pre><code>#define FOO printf(&quot;foo&quot;);
{
   #define BAR printf(&quot;bar&quot;);
}
FOO // adds printf(&quot;foo&quot;);
BAR; // Error, define not available in scope;
</code></pre>
<p>This also means that a define can be declared public to be accessed as if defined from the top of the file scope:</p>
<pre><code>// file 1
module foo
public #define FOO { printf(&quot;FOO!\n&quot;); }

// file 2
import foo

fn void test() {
  foo.FOO
}
</code></pre>
<p>Only defines in the file scope that exists in the file scope may be public and used in other modules.</p>
<h3 id="yet-another-macro-proposal-i-found">Yet another macro proposal I found</h3>
<p>Simple macros</p>
<pre><code>macro @foo(&amp;b)
{
    b++;
}

fn test()
{
    int x = 1;
    @foo(x); 
}

// Same as:
fn void test()
{
    int x = 1;
    x++;    
}

</code></pre>
<p>Macro with compile time values:</p>
<pre><code>macro @foo($x, &amp;b)
{
    b += $x;
}

fn void test()
{
    int x = 1;
    @foo(10, x);
}

// Expands to:
fn void test()
{
    int x = 1;
    x += 10;
}
</code></pre>
<p>Macro with string capture</p>
<pre><code>macro @foo($x, #f)
{
    `#f $x * $x`;
}

fn void test()
{
    int x = 1;
    @foo(4, &quot;x += &quot;);
}

// Expands to
fn void test()
{
    int x = 1;
    x += 4 * 4; 
}

macro @foo2(#f)
{
    printf(&quot;%s was %d\n&quot;, #f, `#f`);
}

funct void test2()
{
    i32 x = 1;
    @foo2(&quot;x&quot;);
}

// Expands to
funct void test2()
{
    i32 x = 1;
    printf(&quot;%s was %d\n&quot;, &quot;x&quot;, x);
}
</code></pre>
<p>Macro with conditional compile time values</p>
<pre><code>macro @foo($x, &amp;b)
{
    $IF ($x &gt; 3) 
    {
        b += $x * $x;
    } 
    $ELSE
    {
        b += $x;
    }
}

fn void test()
{
    i32 x = 1;

    @foo(10, x);
    @foo(2, x);
}

// Expands to
fn void test()
{
    i32 x = 1;

    x += 100;
    x += 2;
}

</code></pre>
<p>Nested macros (don't do this, but an example)</p>
<pre><code>macro @foo($a)
{
    printf(&quot;%d\n&quot;, $a);
    $IF($a &gt; 0) 
    {
        @foo($a - 1);
    }
}

fn void test()
{
    @foo(2);
}

// Expands to
fn void test()
{
    printf(&quot;%d\n&quot;, 2);
    printf(&quot;%d\n&quot;, 1);
    printf(&quot;%d\n&quot;, 0);
}
</code></pre>
<p>The above suggests macro sugar of loops:</p>
<pre><code>macro @foo($a)
{
    $EACH(0..$a AS $x) 
    {
        printf(&quot;%d\n&quot;, $x);     
    }
}

macro @foo_enum(&amp;a)
{
    $EACH(a AS $x)  
    {
        printf(&quot;%d\n&quot;, (int)($x));      
    }
}

enum MyEnum
{
    A,
    B,
    FOO
}

fn void test()
{
    @foo_enum(MyEnum);
}

// Expands to
fn void test()
{
    printf(&quot;%d\n&quot;, (int)(A));
    printf(&quot;%d\n&quot;, (int)(B));
    printf(&quot;%d\n&quot;, (int)(FOO));
}
</code></pre>
<p>Each may iterate over: struct members (returned as string), enums (returned as the enum value)</p>
<p>Type group helper</p>
<pre><code>macro @foo(int&amp; a) // Macro only valid for a is any type of signed integer
macro @foo(integer&amp; a) // Valid for unsigned and signed integers
macro @foo(number&amp; a) // Valid for any float or integer
</code></pre>
<p>Macros may force non local return</p>
<pre><code>macro @foo()        
{
    exit 1; 
    // other keyword? 'escape'? I think exit is good, 
    // but clashes with function name!
}

fn int test()
{
    @foo();
}

// expands to
fn int test()
{
    return 1;
}
</code></pre>
<p>Normal return creates a statement expression</p>
<pre><code>macro @foo(&amp;a)
{
    int x = a;
    x++;
    if (x &gt; 0) return 1;
    return 2; 
}

fn int test()
{
    b = 10;
    int y = @foo(b);
}

// Expands to:
fn int test()
{
    b = 10;
    int __macro_ret_1;
    do
    {
        int __macro_x = b;
        __macro_x++;
        if (__macro_x &gt; 0) 
        {
            __macro_ret_1 = 1;
            break;
        } 
        else 
        {
            __macro_ret_1 = 2;
            break;
        }
    } 
    while (0);
    int y = __macro_ret_1;
}
</code></pre>
<p>Bodies in macros</p>
<pre><code>macro @foo(&amp;a, @body)
{
    int z = 0;
    while (a &lt; 10) 
    {
        @body();
        z++;    
    } 
}

fn void test()
{
    int i = 0;
    @foo(i) 
    {
        i += 1;
    }
}

// Expands to
fn void test()
{
    int i = 0;
    {
        int __macro_z = 0;
        while (i &lt; 10) 
        {
            i += 1;
            __macro_z++;
        }
    }
}
</code></pre>
<p>Bodies in macros with parameters</p>
<pre><code>macro @foo(&amp;a, @body(&amp;x, $y))
{
    int z = 0;
    while (a &lt; 10) 
    {
        @body(z, 2);
        z++;    
    } 
}

fn void test()
{
    int i = 0;
    @foo(i) 
    {
        printf(&quot;%d / %d\n&quot;, x, y);
    }
}

// Expands to

fn void test()
{
    int i = 0;
    {
        int __macro_z = 0;
        while (i &lt; 10) {
            printf(&quot;%d / %d\n&quot;, __macro_z, 2);
            __macro_z++;
        }
    }
}
</code></pre>
<p>Expression is extended to parse:</p>
<p>MACRO_IDENT =&gt; lookup $x in current macro scope and replace it with literal. Error if not in macro.
MACRO_REPLACEMENT =&gt; invoke lexer on code inside, after doing a replace of any <code>#</code> inside. </p>
<p><code>$IF</code> requires that the expression can be evaluated to a constant value, similar holds for the range in <code>$EACH</code>.</p>
<p>The general rule:
1. An argument prefixed with <code>$</code> is always something that must be constant.
2. An argument prefixed with <code>&amp;</code> is always a reference to an outer variable.
3. An argument prefixed with <code>#</code> always matches a string. It will be expanded when lexed in `` statements
4. A $ variable can be converted to a <code>#</code> variable.
5. A <code>#</code> can be evaluated to a <code>$</code>
6. $ and <code>#</code> cannot be assigned to, they are always constant.
7. <code>$</code>, <code>&amp;</code> and <code>#</code> will never shadow variables from the outer scope.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../naming/" class="btn btn-neutral float-right" title="Naming rules">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../library/" class="btn btn-neutral" title="Library"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../library/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../naming/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
